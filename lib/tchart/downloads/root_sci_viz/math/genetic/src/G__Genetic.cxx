//
// File generated by core/utils/src/rootcint_tmp at Sat Jan 22 22:36:40 2011

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME mathdIgeneticdIsrcdIG__Genetic
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "G__Genetic.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GeneticMinimizerParameters GeneticMinimizerParameters;
      #else
      class GeneticMinimizerParameters  {
         public:
         //friend XX;
         int fPopSize; //
         int fNsteps; //
         int fCycles; //
         int fSC_steps; //
         int fSC_rate; //
         double fSC_factor; //
         double fConvCrit; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GeneticMinimizer GeneticMinimizer;
      #else
      class GeneticMinimizer  :  public ::ROOT::Math::Minimizer {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~GeneticMinimizer() throw() {};
         vector< ::TMVA::Interval* > fRanges; //
         ::TMVA::IFitterTarget* fFitness; //
         vector< double > fResult; //
         ::ROOT::Math::GeneticMinimizerParameters fParameters; //
      };
      #endif
      } } 
   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace ROOT {
   void ROOTcLcLMathcLcLGeneticMinimizerParameters_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGeneticMinimizerParameters_Dictionary();
   static void *new_ROOTcLcLMathcLcLGeneticMinimizerParameters(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGeneticMinimizerParameters(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGeneticMinimizerParameters(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGeneticMinimizerParameters(void *p);
   static void destruct_ROOTcLcLMathcLcLGeneticMinimizerParameters(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GeneticMinimizerParameters*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GeneticMinimizerParameters) == sizeof(::ROOT::Shadow::ROOT::Math::GeneticMinimizerParameters));
      ::ROOT::Math::GeneticMinimizerParameters *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GeneticMinimizerParameters),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GeneticMinimizerParameters", "include/Math/GeneticMinimizer.h", 30,
                  typeid(::ROOT::Math::GeneticMinimizerParameters), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGeneticMinimizerParameters_ShowMembers, &ROOTcLcLMathcLcLGeneticMinimizerParameters_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GeneticMinimizerParameters) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGeneticMinimizerParameters);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGeneticMinimizerParameters);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGeneticMinimizerParameters);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGeneticMinimizerParameters);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGeneticMinimizerParameters);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GeneticMinimizerParameters*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GeneticMinimizerParameters*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GeneticMinimizerParameters*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGeneticMinimizerParameters_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GeneticMinimizerParameters*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGeneticMinimizer_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGeneticMinimizer_Dictionary();
   static void *new_ROOTcLcLMathcLcLGeneticMinimizer(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGeneticMinimizer(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGeneticMinimizer(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGeneticMinimizer(void *p);
   static void destruct_ROOTcLcLMathcLcLGeneticMinimizer(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GeneticMinimizer*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GeneticMinimizer) == sizeof(::ROOT::Shadow::ROOT::Math::GeneticMinimizer));
      ::ROOT::Math::GeneticMinimizer *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GeneticMinimizer),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GeneticMinimizer", "include/Math/GeneticMinimizer.h", 52,
                  typeid(::ROOT::Math::GeneticMinimizer), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGeneticMinimizer_ShowMembers, &ROOTcLcLMathcLcLGeneticMinimizer_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GeneticMinimizer) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGeneticMinimizer);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGeneticMinimizer);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGeneticMinimizer);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGeneticMinimizer);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGeneticMinimizer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GeneticMinimizer*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GeneticMinimizer*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GeneticMinimizer*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGeneticMinimizer_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GeneticMinimizer*)0x0)->GetClass();
   }

} // end of namespace ROOT

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGeneticMinimizer_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GeneticMinimizer.
      typedef ::ROOT::Shadow::ROOT::Math::GeneticMinimizer ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GeneticMinimizer*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRanges", (void*)&sobj->fRanges);
      R__insp.InspectMember("vector<TMVA::Interval*>", (void*)&sobj->fRanges, "fRanges.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFitness", &sobj->fFitness);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fResult", (void*)&sobj->fResult);
      R__insp.InspectMember("vector<double>", (void*)&sobj->fResult, "fResult.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fParameters", (void*)&sobj->fParameters);
      R__insp.InspectMember("ROOT::Math::GeneticMinimizerParameters", (void*)&sobj->fParameters, "fParameters.", false);
      R__insp.GenericShowMembers("ROOT::Math::Minimizer", ( ::ROOT::Math::Minimizer * )( (::ROOT::Math::GeneticMinimizer*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGeneticMinimizer(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GeneticMinimizer : new ::ROOT::Math::GeneticMinimizer;
   }
   static void *newArray_ROOTcLcLMathcLcLGeneticMinimizer(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GeneticMinimizer[nElements] : new ::ROOT::Math::GeneticMinimizer[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGeneticMinimizer(void *p) {
      delete ((::ROOT::Math::GeneticMinimizer*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGeneticMinimizer(void *p) {
      delete [] ((::ROOT::Math::GeneticMinimizer*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGeneticMinimizer(void *p) {
      typedef ::ROOT::Math::GeneticMinimizer current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GeneticMinimizer

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGeneticMinimizerParameters_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GeneticMinimizerParameters.
      typedef ::ROOT::Shadow::ROOT::Math::GeneticMinimizerParameters ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GeneticMinimizerParameters*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fPopSize", &sobj->fPopSize);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNsteps", &sobj->fNsteps);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCycles", &sobj->fCycles);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSC_steps", &sobj->fSC_steps);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSC_rate", &sobj->fSC_rate);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSC_factor", &sobj->fSC_factor);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fConvCrit", &sobj->fConvCrit);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGeneticMinimizerParameters(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GeneticMinimizerParameters : new ::ROOT::Math::GeneticMinimizerParameters;
   }
   static void *newArray_ROOTcLcLMathcLcLGeneticMinimizerParameters(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GeneticMinimizerParameters[nElements] : new ::ROOT::Math::GeneticMinimizerParameters[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGeneticMinimizerParameters(void *p) {
      delete ((::ROOT::Math::GeneticMinimizerParameters*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGeneticMinimizerParameters(void *p) {
      delete [] ((::ROOT::Math::GeneticMinimizerParameters*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGeneticMinimizerParameters(void *p) {
      typedef ::ROOT::Math::GeneticMinimizerParameters current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GeneticMinimizerParameters

namespace ROOT {
   void vectorlETMVAcLcLIntervalmUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETMVAcLcLIntervalmUgR_Dictionary();
   static void *new_vectorlETMVAcLcLIntervalmUgR(void *p = 0);
   static void *newArray_vectorlETMVAcLcLIntervalmUgR(Long_t size, void *p);
   static void delete_vectorlETMVAcLcLIntervalmUgR(void *p);
   static void deleteArray_vectorlETMVAcLcLIntervalmUgR(void *p);
   static void destruct_vectorlETMVAcLcLIntervalmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TMVA::Interval*>*)
   {
      vector<TMVA::Interval*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TMVA::Interval*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TMVA::Interval*>", -2, "prec_stl/vector", 49,
                  typeid(vector<TMVA::Interval*>), DefineBehavior(ptr, ptr),
                  0, &vectorlETMVAcLcLIntervalmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TMVA::Interval*>) );
      instance.SetNew(&new_vectorlETMVAcLcLIntervalmUgR);
      instance.SetNewArray(&newArray_vectorlETMVAcLcLIntervalmUgR);
      instance.SetDelete(&delete_vectorlETMVAcLcLIntervalmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlETMVAcLcLIntervalmUgR);
      instance.SetDestructor(&destruct_vectorlETMVAcLcLIntervalmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TMVA::Interval*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TMVA::Interval*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETMVAcLcLIntervalmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TMVA::Interval*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETMVAcLcLIntervalmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TMVA::Interval*> : new vector<TMVA::Interval*>;
   }
   static void *newArray_vectorlETMVAcLcLIntervalmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TMVA::Interval*>[nElements] : new vector<TMVA::Interval*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETMVAcLcLIntervalmUgR(void *p) {
      delete ((vector<TMVA::Interval*>*)p);
   }
   static void deleteArray_vectorlETMVAcLcLIntervalmUgR(void *p) {
      delete [] ((vector<TMVA::Interval*>*)p);
   }
   static void destruct_vectorlETMVAcLcLIntervalmUgR(void *p) {
      typedef vector<TMVA::Interval*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TMVA::Interval*>

namespace ROOT {
   void vectorlEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEdoublegR_Dictionary();
   static void *new_vectorlEdoublegR(void *p = 0);
   static void *newArray_vectorlEdoublegR(Long_t size, void *p);
   static void delete_vectorlEdoublegR(void *p);
   static void deleteArray_vectorlEdoublegR(void *p);
   static void destruct_vectorlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<double>*)
   {
      vector<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<double>", -2, "prec_stl/vector", 49,
                  typeid(vector<double>), DefineBehavior(ptr, ptr),
                  0, &vectorlEdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(vector<double>) );
      instance.SetNew(&new_vectorlEdoublegR);
      instance.SetNewArray(&newArray_vectorlEdoublegR);
      instance.SetDelete(&delete_vectorlEdoublegR);
      instance.SetDeleteArray(&deleteArray_vectorlEdoublegR);
      instance.SetDestructor(&destruct_vectorlEdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<double> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double> : new vector<double>;
   }
   static void *newArray_vectorlEdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double>[nElements] : new vector<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEdoublegR(void *p) {
      delete ((vector<double>*)p);
   }
   static void deleteArray_vectorlEdoublegR(void *p) {
      delete [] ((vector<double>*)p);
   }
   static void destruct_vectorlEdoublegR(void *p) {
      typedef vector<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<double>

/********************************************************
* math/genetic/src/G__Genetic.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableG__Genetic();

extern "C" void G__set_cpp_environmentG__Genetic() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("Math/GeneticMinimizer.h");
  G__cpp_reset_tagtableG__Genetic();
}
#include <new>
extern "C" int G__cpp_dllrevG__Genetic() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* ROOT::Math::GeneticMinimizerParameters */
static int G__G__Genetic_146_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GeneticMinimizerParameters* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GeneticMinimizerParameters[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GeneticMinimizerParameters[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GeneticMinimizerParameters;
     } else {
       p = new((void*) gvp) ROOT::Math::GeneticMinimizerParameters;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizerParameters));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Genetic_146_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GeneticMinimizerParameters* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GeneticMinimizerParameters(*(ROOT::Math::GeneticMinimizerParameters*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizerParameters));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GeneticMinimizerParameters G__TROOTcLcLMathcLcLGeneticMinimizerParameters;
static int G__G__Genetic_146_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GeneticMinimizerParameters*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GeneticMinimizerParameters*) (soff+(sizeof(ROOT::Math::GeneticMinimizerParameters)*i)))->~G__TROOTcLcLMathcLcLGeneticMinimizerParameters();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GeneticMinimizerParameters*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GeneticMinimizerParameters*) (soff))->~G__TROOTcLcLMathcLcLGeneticMinimizerParameters();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Genetic_146_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GeneticMinimizerParameters* dest = (ROOT::Math::GeneticMinimizerParameters*) G__getstructoffset();
   *dest = *(ROOT::Math::GeneticMinimizerParameters*) libp->para[0].ref;
   const ROOT::Math::GeneticMinimizerParameters& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GeneticMinimizer */
static int G__G__Genetic_147_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GeneticMinimizer* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GeneticMinimizer((int) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::GeneticMinimizer((int) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GeneticMinimizer[n];
       } else {
         p = new((void*) gvp) ROOT::Math::GeneticMinimizer[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GeneticMinimizer;
       } else {
         p = new((void*) gvp) ROOT::Math::GeneticMinimizer;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizer));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Genetic_147_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GeneticMinimizer*) G__getstructoffset())->SetParameters(*(ROOT::Math::GeneticMinimizerParameters*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GeneticMinimizer G__TROOTcLcLMathcLcLGeneticMinimizer;
static int G__G__Genetic_147_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GeneticMinimizer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GeneticMinimizer*) (soff+(sizeof(ROOT::Math::GeneticMinimizer)*i)))->~G__TROOTcLcLMathcLcLGeneticMinimizer();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GeneticMinimizer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GeneticMinimizer*) (soff))->~G__TROOTcLcLMathcLcLGeneticMinimizer();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* ROOT::Math::GeneticMinimizerParameters */

/* ROOT::Math::GeneticMinimizer */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncG__Genetic {
 public:
  G__Sizep2memfuncG__Genetic(): p(&G__Sizep2memfuncG__Genetic::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncG__Genetic::*p)();
};

size_t G__get_sizep2memfuncG__Genetic()
{
  G__Sizep2memfuncG__Genetic a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceG__Genetic() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizer))) {
     ROOT::Math::GeneticMinimizer *G__Lderived;
     G__Lderived=(ROOT::Math::GeneticMinimizer*)0x1000;
     {
       ROOT::Math::Minimizer *G__Lpbase=(ROOT::Math::Minimizer*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizer),G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLMinimizer),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableG__Genetic() {

   /* Setting up typedef entry */
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__G__GeneticLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__GeneticLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__GeneticLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__GeneticLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__GeneticLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__G__GeneticLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__GeneticLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__GeneticLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__GeneticLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__GeneticLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<TString,TMVA::Types::EMVA>",117,G__get_linked_tagnum(&G__G__GeneticLN_maplETStringcOTMVAcLcLTypescLcLEMVAcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTMVAcLcLTypescLcLEMVAgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<TString,TMVA::Types::EMVA,less<TString> >",117,G__get_linked_tagnum(&G__G__GeneticLN_maplETStringcOTMVAcLcLTypescLcLEMVAcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTMVAcLcLTypescLcLEMVAgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Double_t>",117,G__get_linked_tagnum(&G__G__GeneticLN_vectorlEdoublecOallocatorlEdoublegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__GeneticLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__GeneticLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__GeneticLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__GeneticLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<double>",117,G__get_linked_tagnum(&G__G__GeneticLN_vectorlEdoublecOallocatorlEdoublegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TMVA::Interval*>",117,G__get_linked_tagnum(&G__G__GeneticLN_vectorlETMVAcLcLIntervalmUcOallocatorlETMVAcLcLIntervalmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__GeneticLN_reverse_iteratorlEvectorlETMVAcLcLIntervalmUcOallocatorlETMVAcLcLIntervalmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__GeneticLN_vectorlETMVAcLcLIntervalmUcOallocatorlETMVAcLcLIntervalmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__GeneticLN_reverse_iteratorlEvectorlETMVAcLcLIntervalmUcOallocatorlETMVAcLcLIntervalmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__GeneticLN_vectorlETMVAcLcLIntervalmUcOallocatorlETMVAcLcLIntervalmUgRsPgR));
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* ROOT::Math::GeneticMinimizerParameters */
static void G__setup_memvarROOTcLcLMathcLcLGeneticMinimizerParameters(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizerParameters));
   { ROOT::Math::GeneticMinimizerParameters *p; p=(ROOT::Math::GeneticMinimizerParameters*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fPopSize)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fPopSize=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fNsteps)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fNsteps=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fCycles)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fCycles=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fSC_steps)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fSC_steps=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fSC_rate)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fSC_rate=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fSC_factor)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"fSC_factor=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fConvCrit)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"fConvCrit=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GeneticMinimizer */
static void G__setup_memvarROOTcLcLMathcLcLGeneticMinimizer(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizer));
   { ROOT::Math::GeneticMinimizer *p; p=(ROOT::Math::GeneticMinimizer*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__GeneticLN_vectorlETMVAcLcLIntervalmUcOallocatorlETMVAcLcLIntervalmUgRsPgR),G__defined_typename("vector<TMVA::Interval*>"),-1,2,"fRanges=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__GeneticLN_TMVAcLcLIFitterTarget),-1,-1,2,"fFitness=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__GeneticLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,2,"fResult=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizerParameters),-1,-1,2,"fParameters=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarG__Genetic() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncROOTcLcLMathcLcLGeneticMinimizerParameters(void) {
   /* ROOT::Math::GeneticMinimizerParameters */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizerParameters));
   G__memfunc_setup("GeneticMinimizerParameters",2695,G__G__Genetic_146_0_1, 105, G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizerParameters), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GeneticMinimizerParameters", 2695, G__G__Genetic_146_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizerParameters), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GeneticMinimizerParameters' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GeneticMinimizerParameters", 2821, G__G__Genetic_146_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Genetic_146_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizerParameters), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GeneticMinimizerParameters' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGeneticMinimizer(void) {
   /* ROOT::Math::GeneticMinimizer */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizer));
   G__memfunc_setup("GeneticMinimizer",1651,G__G__Genetic_147_0_1, 105, G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizer), -1, 0, 1, 1, 1, 0, "i - - 0 '0' -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clear",487,(G__InterfaceMethod) NULL,121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - func", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetLimitedVariable",1818,(G__InterfaceMethod) NULL,103, -1, -1, 0, 6, 1, 1, 0, 
"h - - 0 - - u 'string' - 11 - - "
"d - - 0 - - d - - 0 - - "
"d - - 0 - - d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariable",1106,(G__InterfaceMethod) NULL,103, -1, -1, 0, 4, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Minimize",834,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("MinValue",801,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Edm",278,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("X",88,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("MinGradient",1106,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NCalls",573,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NDim",360,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NFree",464,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ProvidesError",1366,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Errors",637,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("CovMatrix",925,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 8, 
"h - - 0 - i h - - 0 - j", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetParameters",1344,G__G__Genetic_147_0_17, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GeneticMinimizerParameters' - 11 - params", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Options",748,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__G__GeneticLN_ROOTcLcLMathcLcLMinimizerOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetOptions",1048,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::MinimizerOptions' - 11 - opt", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetGeneticOptions",1739,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 2, 8, "u 'ROOT::Math::MinimizerOptions' - 1 - opt", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GeneticMinimizer", 1777, G__G__Genetic_147_0_21, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncG__Genetic() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalG__Genetic() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcG__Genetic() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__G__GeneticLN_ROOT = { "ROOT" , 110 , -1 };
G__linked_taginfo G__G__GeneticLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__G__GeneticLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__G__GeneticLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__GeneticLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__G__GeneticLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__GeneticLN_ROOTcLcLMath = { "ROOT::Math" , 110 , -1 };
G__linked_taginfo G__G__GeneticLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim = { "ROOT::Math::IBaseFunctionMultiDim" , 99 , -1 };
G__linked_taginfo G__G__GeneticLN_ROOTcLcLMathcLcLMinimizerOptions = { "ROOT::Math::MinimizerOptions" , 99 , -1 };
G__linked_taginfo G__G__GeneticLN_ROOTcLcLMathcLcLMinimizer = { "ROOT::Math::Minimizer" , 99 , -1 };
G__linked_taginfo G__G__GeneticLN_TMVA = { "TMVA" , 110 , -1 };
G__linked_taginfo G__G__GeneticLN_maplETStringcOTMVAcLcLTypescLcLEMVAcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTMVAcLcLTypescLcLEMVAgRsPgRsPgR = { "map<TString,TMVA::Types::EMVA,less<TString>,allocator<pair<const TString,TMVA::Types::EMVA> > >" , 99 , -1 };
G__linked_taginfo G__G__GeneticLN_TMVAcLcLIFitterTarget = { "TMVA::IFitterTarget" , 99 , -1 };
G__linked_taginfo G__G__GeneticLN_vectorlEdoublecOallocatorlEdoublegRsPgR = { "vector<double,allocator<double> >" , 99 , -1 };
G__linked_taginfo G__G__GeneticLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<double,allocator<double> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizerParameters = { "ROOT::Math::GeneticMinimizerParameters" , 115 , -1 };
G__linked_taginfo G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizer = { "ROOT::Math::GeneticMinimizer" , 99 , -1 };
G__linked_taginfo G__G__GeneticLN_vectorlETMVAcLcLIntervalmUcOallocatorlETMVAcLcLIntervalmUgRsPgR = { "vector<TMVA::Interval*,allocator<TMVA::Interval*> >" , 99 , -1 };
G__linked_taginfo G__G__GeneticLN_reverse_iteratorlEvectorlETMVAcLcLIntervalmUcOallocatorlETMVAcLcLIntervalmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TMVA::Interval*,allocator<TMVA::Interval*> >::iterator>" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableG__Genetic() {
  G__G__GeneticLN_ROOT.tagnum = -1 ;
  G__G__GeneticLN_string.tagnum = -1 ;
  G__G__GeneticLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__G__GeneticLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__GeneticLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__G__GeneticLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__GeneticLN_ROOTcLcLMath.tagnum = -1 ;
  G__G__GeneticLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim.tagnum = -1 ;
  G__G__GeneticLN_ROOTcLcLMathcLcLMinimizerOptions.tagnum = -1 ;
  G__G__GeneticLN_ROOTcLcLMathcLcLMinimizer.tagnum = -1 ;
  G__G__GeneticLN_TMVA.tagnum = -1 ;
  G__G__GeneticLN_maplETStringcOTMVAcLcLTypescLcLEMVAcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTMVAcLcLTypescLcLEMVAgRsPgRsPgR.tagnum = -1 ;
  G__G__GeneticLN_TMVAcLcLIFitterTarget.tagnum = -1 ;
  G__G__GeneticLN_vectorlEdoublecOallocatorlEdoublegRsPgR.tagnum = -1 ;
  G__G__GeneticLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizerParameters.tagnum = -1 ;
  G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizer.tagnum = -1 ;
  G__G__GeneticLN_vectorlETMVAcLcLIntervalmUcOallocatorlETMVAcLcLIntervalmUgRsPgR.tagnum = -1 ;
  G__G__GeneticLN_reverse_iteratorlEvectorlETMVAcLcLIntervalmUcOallocatorlETMVAcLcLIntervalmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableG__Genetic() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_ROOT);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_string);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_ROOTcLcLMath);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_ROOTcLcLMathcLcLMinimizerOptions);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_ROOTcLcLMathcLcLMinimizer);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_TMVA);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_maplETStringcOTMVAcLcLTypescLcLEMVAcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTMVAcLcLTypescLcLEMVAgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_TMVAcLcLIFitterTarget);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_vectorlEdoublecOallocatorlEdoublegRsPgR);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizerParameters),sizeof(ROOT::Math::GeneticMinimizerParameters),-1,262400,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGeneticMinimizerParameters,G__setup_memfuncROOTcLcLMathcLcLGeneticMinimizerParameters);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__GeneticLN_ROOTcLcLMathcLcLGeneticMinimizer),sizeof(ROOT::Math::GeneticMinimizer),-1,263424,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGeneticMinimizer,G__setup_memfuncROOTcLcLMathcLcLGeneticMinimizer);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_vectorlETMVAcLcLIntervalmUcOallocatorlETMVAcLcLIntervalmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__GeneticLN_reverse_iteratorlEvectorlETMVAcLcLIntervalmUcOallocatorlETMVAcLcLIntervalmUgRsPgRcLcLiteratorgR);
}
extern "C" void G__cpp_setupG__Genetic(void) {
  G__check_setup_version(30051515,"G__cpp_setupG__Genetic()");
  G__set_cpp_environmentG__Genetic();
  G__cpp_setup_tagtableG__Genetic();

  G__cpp_setup_inheritanceG__Genetic();

  G__cpp_setup_typetableG__Genetic();

  G__cpp_setup_memvarG__Genetic();

  G__cpp_setup_memfuncG__Genetic();
  G__cpp_setup_globalG__Genetic();
  G__cpp_setup_funcG__Genetic();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncG__Genetic();
  return;
}
class G__cpp_setup_initG__Genetic {
  public:
    G__cpp_setup_initG__Genetic() { G__add_setup_func("G__Genetic",(G__incsetup)(&G__cpp_setupG__Genetic)); G__call_setup_funcs(); }
   ~G__cpp_setup_initG__Genetic() { G__remove_setup_func("G__Genetic"); }
};
G__cpp_setup_initG__Genetic G__cpp_setup_initializerG__Genetic;

