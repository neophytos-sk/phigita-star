//
// File generated by core/utils/src/rootcint_tmp at Sat Jan 22 22:09:00 2011

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME mathdImathcoredIsrcdIG__MathCore
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "G__MathCore.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TKDTree< int, double > TKDTreelEintcOdoublegR;
      #else
      class TKDTreelEintcOdoublegR  :  public ::TObject {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~TKDTreelEintcOdoublegR() throw() {};
         int fDataOwner; //! 0 - not owner, 2 - owner of the pointer array, 1 - owner of the whole 2-d array
         int fNNodes; //size of node array
         int fTotalNodes; //total number of nodes (fNNodes + terminal nodes)
         int fNDim; //number of dimensions
         int fNDimm; //dummy 2*fNDim
         int fNPoints; //number of multidimensional points
         int fBucketSize; //size of the terminal nodes
         unsigned char* fAxis; //[fNNodes] nodes cutting axis
         double* fValue; //[fNNodes] nodes cutting value
         double* fRange; //[fNDimm] range of data for each dimension
         double** fData; //! data points
         double* fBoundaries; //! nodes boundaries
         int* fIndPoints; //! array of points indexes
         int fRowT0; //! smallest terminal row - first row that contains terminal nodes
         int fCrossNode; //! cross node - node that begins the last row (with terminal nodes only)
         int fOffset; //! offset in fIndPoints - if there are 2 rows, that contain terminal nodes
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TKDTree< int, float > TKDTreelEintcOfloatgR;
      #else
      class TKDTreelEintcOfloatgR  :  public ::TObject {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~TKDTreelEintcOfloatgR() throw() {};
         int fDataOwner; //! 0 - not owner, 2 - owner of the pointer array, 1 - owner of the whole 2-d array
         int fNNodes; //size of node array
         int fTotalNodes; //total number of nodes (fNNodes + terminal nodes)
         int fNDim; //number of dimensions
         int fNDimm; //dummy 2*fNDim
         int fNPoints; //number of multidimensional points
         int fBucketSize; //size of the terminal nodes
         unsigned char* fAxis; //[fNNodes] nodes cutting axis
         float* fValue; //[fNNodes] nodes cutting value
         float* fRange; //[fNDimm] range of data for each dimension
         float** fData; //! data points
         float* fBoundaries; //! nodes boundaries
         int* fIndPoints; //! array of points indexes
         int fRowT0; //! smallest terminal row - first row that contains terminal nodes
         int fCrossNode; //! cross node - node that begins the last row (with terminal nodes only)
         int fOffset; //! offset in fIndPoints - if there are 2 rows, that contain terminal nodes
      };
      #endif

      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IBaseFunctionOneDim IBaseFunctionOneDim;
      #else
      class IBaseFunctionOneDim  {
         public:
         //friend XX;
         typedef ::ROOT::Math::IBaseFunctionOneDim BaseFunc;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IBaseFunctionOneDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IGradientFunctionOneDim IGradientFunctionOneDim;
      #else
      class IGradientFunctionOneDim  :  virtual public ::ROOT::Math::IBaseFunctionOneDim,  public ::ROOT::Math::IGradientOneDim {
         public:
         //friend XX;
         typedef ::ROOT::Math::IBaseFunctionOneDim BaseFunc;
         typedef ::ROOT::Math::IGradientOneDim BaseGrad;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IGradientFunctionOneDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IBaseFunctionMultiDim IBaseFunctionMultiDim;
      #else
      class IBaseFunctionMultiDim  {
         public:
         //friend XX;
         typedef ::ROOT::Math::IBaseFunctionMultiDim BaseFunc;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IBaseFunctionMultiDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IGradientFunctionMultiDim IGradientFunctionMultiDim;
      #else
      class IGradientFunctionMultiDim  :  virtual public ::ROOT::Math::IBaseFunctionMultiDim,  public ::ROOT::Math::IGradientMultiDim {
         public:
         //friend XX;
         typedef ::ROOT::Math::IBaseFunctionMultiDim BaseFunc;
         typedef ::ROOT::Math::IGradientMultiDim BaseGrad;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IGradientFunctionMultiDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IGradientMultiDim IGradientMultiDim;
      #else
      class IGradientMultiDim  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IGradientMultiDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IGradientOneDim IGradientOneDim;
      #else
      class IGradientOneDim  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IGradientOneDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IParametricFunctionOneDim IParametricFunctionOneDim;
      #else
      class IParametricFunctionOneDim  :  virtual public ::ROOT::Math::IBaseFunctionOneDim,  public ::ROOT::Math::IBaseParam {
         public:
         //friend XX;
         typedef ::ROOT::Math::IBaseFunctionOneDim BaseFunc;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IParametricFunctionOneDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IParametricGradFunctionOneDim IParametricGradFunctionOneDim;
      #else
      class IParametricGradFunctionOneDim  :  public ::ROOT::Math::IParametricFunctionOneDim {
         public:
         //friend XX;
         typedef ::ROOT::Math::IParametricFunctionOneDim BaseParamFunc;
         typedef ::ROOT::Math::IGradientFunctionOneDim BaseGradFunc;
         typedef ::ROOT::Math::IBaseFunctionOneDim BaseFunc;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IParametricGradFunctionOneDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IParametricFunctionMultiDim IParametricFunctionMultiDim;
      #else
      class IParametricFunctionMultiDim  :  virtual public ::ROOT::Math::IBaseFunctionMultiDim,  public ::ROOT::Math::IBaseParam {
         public:
         //friend XX;
         typedef ::ROOT::Math::IBaseFunctionMultiDim BaseFunc;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IParametricFunctionMultiDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IParametricGradFunctionMultiDim IParametricGradFunctionMultiDim;
      #else
      class IParametricGradFunctionMultiDim  :  public ::ROOT::Math::IParametricFunctionMultiDim {
         public:
         //friend XX;
         typedef ::ROOT::Math::IParametricFunctionMultiDim BaseParamFunc;
         typedef ::ROOT::Math::IGradientFunctionMultiDim BaseGradFunc;
         typedef ::ROOT::Math::IBaseFunctionMultiDim BaseFunc;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IParametricGradFunctionMultiDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IBaseParam IBaseParam;
      #else
      class IBaseParam  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IBaseParam() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::ParamFunctor ParamFunctor;
      #else
      class ParamFunctor  {
         public:
         //friend XX;
         typedef ::ROOT::Math::ParamFunctionBase Impl;
         typedef void* (*FreeFunc)() ;
         // To force the creation of a virtual table, throw just in case.
         virtual ~ParamFunctor() throw() {};
         ::ROOT::Math::ParamFunctionBase* fImpl; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IOptions IOptions;
      #else
      class IOptions  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IOptions() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::MinimizerOptions MinimizerOptions;
      #else
      class MinimizerOptions  {
         public:
         //friend XX;
         int fLevel; //debug print level 
         int fMaxCalls; //maximum number of function calls
         int fMaxIter; //maximum number of iterations
         int fStrategy; //minimizer strategy (used by Minuit)
         double fErrorDef; //error definition (=1. for getting 1 sigma error for chi2 fits)
         double fTolerance; //minimize tolerance to reach solution
         double fPrecision; //precision of the objective function evaluation (value <=0 means left to default)
         string fMinimType; //Minimizer type (Minuit, Minuit2, etc..
         string fAlgoType; //Minimizer algorithmic specification (Migrad, Minimize, ...)
         ::ROOT::Math::IOptions* fExtraOptions; //extra options 
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Minimizer Minimizer;
      #else
      class Minimizer  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~Minimizer() throw() {};
         bool fValidError; //flag to control if errors have been validated (Hesse has been run in case of Minuit)
         int fDebug; //print level
         int fStrategy; //minimizer strategy
         int fStatus; //status of minimizer    
         unsigned int fMaxCalls; //max number of function calls 
         unsigned int fMaxIter; //max number or iterations used to find the minimum
         double fTol; //tolerance (absolute)
         double fPrec; //precision
         double fUp; //error scale 
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::BaseIntegratorOptions BaseIntegratorOptions;
      #else
      class BaseIntegratorOptions  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~BaseIntegratorOptions() throw() {};
         int fIntegType; //Integrator type (value converted from enum)
         unsigned int fWKSize; //workspace size
         unsigned int fNCalls; //(max) funxtion calls
         double fAbsTolerance; //absolute tolerance 
         double fRelTolerance; //relative tolerance 
         ::ROOT::Math::IOptions* fExtraOptions; //extra options 
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IntegratorOneDimOptions IntegratorOneDimOptions;
      #else
      class IntegratorOneDimOptions  :  public ::ROOT::Math::BaseIntegratorOptions {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IntegratorOneDimOptions() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IntegratorMultiDimOptions IntegratorMultiDimOptions;
      #else
      class IntegratorMultiDimOptions  :  public ::ROOT::Math::BaseIntegratorOptions {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IntegratorMultiDimOptions() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::VirtualIntegrator VirtualIntegrator;
      #else
      class VirtualIntegrator  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~VirtualIntegrator() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::VirtualIntegratorOneDim VirtualIntegratorOneDim;
      #else
      class VirtualIntegratorOneDim  :  public ::ROOT::Math::VirtualIntegrator {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~VirtualIntegratorOneDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::VirtualIntegratorMultiDim VirtualIntegratorMultiDim;
      #else
      class VirtualIntegratorMultiDim  :  public ::ROOT::Math::VirtualIntegrator {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~VirtualIntegratorMultiDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IntegratorOneDim IntegratorOneDim;
      #else
      class IntegratorOneDim  {
         public:
         //friend XX;
         typedef ::ROOT::Math::IntegrationOneDim::Type Type;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IntegratorOneDim() throw() {};
         ::ROOT::Math::VirtualIntegratorOneDim* fIntegrator; //pointer to integrator interface class
         ::auto_ptr< ::ROOT::Math::IBaseFunctionOneDim > fFunc; //pointer to owned function
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::AdaptiveIntegratorMultiDim AdaptiveIntegratorMultiDim;
      #else
      class AdaptiveIntegratorMultiDim  :  public ::ROOT::Math::VirtualIntegratorMultiDim {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AdaptiveIntegratorMultiDim() throw() {};
         unsigned int fDim; //dimentionality of integrand
         unsigned int fMinPts; //minimum number of function evaluation requested 
         unsigned int fMaxPts; //maximum number of function evaluation requested 
         unsigned int fSize; //max size of working array (explode with dimension)
         double fAbsTol; //absolute tolerance
         double fRelTol; //relative tolerance
         double fResult; //last integration result 
         double fError; //integration error 
         double fRelError; //Relative error
         int fNEval; //number of function evaluation
         int fStatus; //status of algorithm (error if not zero)
         :: ROOT::Math::IBaseFunctionMultiDim* fFun; //pointer to integrand function 
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IntegratorMultiDim IntegratorMultiDim;
      #else
      class IntegratorMultiDim  {
         public:
         //friend XX;
         typedef ::ROOT::Math::IntegrationMultiDim::Type Type;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IntegratorMultiDim() throw() {};
         ::ROOT::Math::VirtualIntegratorMultiDim* fIntegrator; //pointer to multi-dimensional integrator base class
         ::auto_ptr< ::ROOT::Math::IBaseFunctionMultiDim > fFunc; //pointer to owned function
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::DistSampler DistSampler;
      #else
      class DistSampler  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~DistSampler() throw() {};
         bool fOwnFunc; //flag to indicate if the function is owned
         vector< double > fData; //internal array used to cached the sample data 
         ::ROOT::Fit::DataRange* fRange; //data range 
         :: ROOT::Math::IBaseFunctionMultiDim* fFunc; //internal function (ND)
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Factory Factory;
      #else
      class Factory  {
         public:
         //friend XX;
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::BasicFitMethodFunction< ::ROOT::Math::IBaseFunctionMultiDim > BasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR;
      #else
      class BasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR  :  public ::ROOT::Math::IBaseFunctionMultiDim {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::ROOT::Math::BasicFitMethodFunction< ::ROOT::Math::IBaseFunctionMultiDim >::Type_t Type_t;
         #else
         enum Type_t  {
         };
         #endif

         typedef ::ROOT::Math::IBaseFunctionMultiDim BaseFunction;
         // To force the creation of a virtual table, throw just in case.
         virtual ~BasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR() throw() {};
         unsigned int fNDim; //function dimension 
         unsigned int fNPoints; //size of the data
         unsigned int fNCalls; //number of function calls
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::BasicFitMethodFunction< ::ROOT::Math::IGradientFunctionMultiDim > BasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR;
      #else
      class BasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR  :  public ::ROOT::Math::IGradientFunctionMultiDim {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::ROOT::Math::BasicFitMethodFunction< ::ROOT::Math::IGradientFunctionMultiDim >::Type_t Type_t;
         #else
         enum Type_t  {
         };
         #endif

         typedef ::ROOT::Math::IBaseFunctionMultiDim BaseFunction;
         // To force the creation of a virtual table, throw just in case.
         virtual ~BasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR() throw() {};
         unsigned int fNDim; //function dimension 
         unsigned int fNPoints; //size of the data
         unsigned int fNCalls; //number of function calls
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GaussIntegrator GaussIntegrator;
      #else
      class GaussIntegrator  :  public ::ROOT::Math::VirtualIntegratorOneDim {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~GaussIntegrator() throw() {};
         double fEpsilon; //Relative error.
         bool fUsedOnce; //Bool value to check if the function was at least called once.
         double fLastResult; //Result from the last stimation.
         double fLastError; //Error from the last stimation.
         :: ROOT::Math::IBaseFunctionOneDim* fFunction; //Pointer to function used.
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GaussLegendreIntegrator GaussLegendreIntegrator;
      #else
      class GaussLegendreIntegrator  :  public ::ROOT::Math::GaussIntegrator {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~GaussLegendreIntegrator() throw() {};
         int fNum; //Number of points used in the stimation of the integral.
         double* fX; //Abscisa of the points used.
         double* fW; //Weights of the points used.
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IRootFinderMethod IRootFinderMethod;
      #else
      class IRootFinderMethod  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IRootFinderMethod() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::RootFinder RootFinder;
      #else
      class RootFinder  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::ROOT::Math::RootFinder::EType EType;
         #else
         enum EType  {
         };
         #endif

         // To force the creation of a virtual table, throw just in case.
         virtual ~RootFinder() throw() {};
         ::ROOT::Math::IRootFinderMethod* fSolver; //type of algorithm to be used 
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::RichardsonDerivator RichardsonDerivator;
      #else
      class RichardsonDerivator  {
         public:
         //friend XX;
         bool fFunctionCopied; //flag to control if function is copied in the class
         double fStepSize; //step size used for derivative calculation
         double fLastError; //error estimate of last derivative calculation
         :: ROOT::Math::IBaseFunctionOneDim* fFunction; //pointer to function
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IMinimizer1D IMinimizer1D;
      #else
      class IMinimizer1D  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IMinimizer1D() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::BrentMinimizer1D BrentMinimizer1D;
      #else
      class BrentMinimizer1D  :  private ::ROOT::Math::IMinimizer1D {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~BrentMinimizer1D() throw() {};
         :: ROOT::Math::IBaseFunctionOneDim* fFunction; //Pointer to the function.
         bool fLogScan; //flag to control usage of a log scan
         int fNIter; //Number of iterations needed for the last estimation.
         int fNpx; //Number of points to bracket minimum with grid (def is 100)
         int fStatus; //Status of code of the last estimate
         double fXMin; //Lower bound of the search interval.
         double fXMax; //Upper bound of the search interval
         double fXMinimum; //Position of the stimated minimum.
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::BrentRootFinder BrentRootFinder;
      #else
      class BrentRootFinder  :  public ::ROOT::Math::IRootFinderMethod {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~BrentRootFinder() throw() {};
         :: ROOT::Math::IBaseFunctionOneDim* fFunction; //Pointer to the function.
         bool fLogScan; //flag to control usage of a log scan      
         int fNIter; //Number of iterations needed for the last estimation.
         int fNpx; //Number of points to bracket root with initial grid (def is 100)
         int fStatus; //Status of code of the last estimate
         double fXMin; //Lower bound of the search interval.
         double fXMax; //Upper bound of the search interval
         double fRoot; //Current stimation of the function root.
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::DistSamplerOptions DistSamplerOptions;
      #else
      class DistSamplerOptions  {
         public:
         //friend XX;
         int fLevel; //debug print level 
         string fSamplerType; //DistSampler type (Unuran, Foam, etc...)xs
         string fAlgoType; //DistSampler algorithmic specification (for Unuran only)
         ::ROOT::Math::IOptions* fExtraOptions; //extra options 
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GoFTest GoFTest;
      #else
      class GoFTest  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::ROOT::Math::GoFTest::EDistribution EDistribution;
         #else
         enum EDistribution  {
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::ROOT::Math::GoFTest::EUserDistribution EUserDistribution;
         #else
         enum EUserDistribution  {
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::ROOT::Math::GoFTest::ETestType ETestType;
         #else
         enum ETestType  {
         };
         #endif

         // To force the creation of a virtual table, throw just in case.
         virtual ~GoFTest() throw() {};
         ::auto_ptr< ::ROOT::Math::IBaseFunctionOneDim > fCDF; //
         EDistribution fDist; //
         double fMean; //
         double fSigma; //
         vector< Double_t > fCombinedSamples; //
         vector< vector< double, allocator< double >  >  > fSamples; //
         bool fTestSampleFromH0; //
      };
      #endif
      } } 
   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ROOT_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT", 0 /*version*/, "include/Math/QuantFuncMathCore.h", 31,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ROOT_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ROOT_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }

namespace ROOT {
   void TRandom_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_TRandom(void *p = 0);
   static void *newArray_TRandom(Long_t size, void *p);
   static void delete_TRandom(void *p);
   static void deleteArray_TRandom(void *p);
   static void destruct_TRandom(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRandom*)
   {
      ::TRandom *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRandom >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TRandom", ::TRandom::Class_Version(), "include/TRandom.h", 29,
                  typeid(::TRandom), DefineBehavior(ptr, ptr),
                  &::TRandom::Dictionary, isa_proxy, 4,
                  sizeof(::TRandom) );
      instance.SetNew(&new_TRandom);
      instance.SetNewArray(&newArray_TRandom);
      instance.SetDelete(&delete_TRandom);
      instance.SetDeleteArray(&deleteArray_TRandom);
      instance.SetDestructor(&destruct_TRandom);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRandom*)
   {
      return GenerateInitInstanceLocal((::TRandom*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TRandom*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TRandom1_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_TRandom1(void *p = 0);
   static void *newArray_TRandom1(Long_t size, void *p);
   static void delete_TRandom1(void *p);
   static void deleteArray_TRandom1(void *p);
   static void destruct_TRandom1(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRandom1*)
   {
      ::TRandom1 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRandom1 >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TRandom1", ::TRandom1::Class_Version(), "include/TRandom1.h", 29,
                  typeid(::TRandom1), DefineBehavior(ptr, ptr),
                  &::TRandom1::Dictionary, isa_proxy, 4,
                  sizeof(::TRandom1) );
      instance.SetNew(&new_TRandom1);
      instance.SetNewArray(&newArray_TRandom1);
      instance.SetDelete(&delete_TRandom1);
      instance.SetDeleteArray(&deleteArray_TRandom1);
      instance.SetDestructor(&destruct_TRandom1);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRandom1*)
   {
      return GenerateInitInstanceLocal((::TRandom1*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TRandom1*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TRandom2_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_TRandom2(void *p = 0);
   static void *newArray_TRandom2(Long_t size, void *p);
   static void delete_TRandom2(void *p);
   static void deleteArray_TRandom2(void *p);
   static void destruct_TRandom2(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRandom2*)
   {
      ::TRandom2 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRandom2 >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TRandom2", ::TRandom2::Class_Version(), "include/TRandom2.h", 29,
                  typeid(::TRandom2), DefineBehavior(ptr, ptr),
                  &::TRandom2::Dictionary, isa_proxy, 4,
                  sizeof(::TRandom2) );
      instance.SetNew(&new_TRandom2);
      instance.SetNewArray(&newArray_TRandom2);
      instance.SetDelete(&delete_TRandom2);
      instance.SetDeleteArray(&deleteArray_TRandom2);
      instance.SetDestructor(&destruct_TRandom2);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRandom2*)
   {
      return GenerateInitInstanceLocal((::TRandom2*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TRandom2*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TRandom3_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_TRandom3(void *p = 0);
   static void *newArray_TRandom3(Long_t size, void *p);
   static void delete_TRandom3(void *p);
   static void deleteArray_TRandom3(void *p);
   static void destruct_TRandom3(void *p);
   static void streamer_TRandom3(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRandom3*)
   {
      ::TRandom3 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRandom3 >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TRandom3", ::TRandom3::Class_Version(), "include/TRandom3.h", 29,
                  typeid(::TRandom3), DefineBehavior(ptr, ptr),
                  &::TRandom3::Dictionary, isa_proxy, 1,
                  sizeof(::TRandom3) );
      instance.SetNew(&new_TRandom3);
      instance.SetNewArray(&newArray_TRandom3);
      instance.SetDelete(&delete_TRandom3);
      instance.SetDeleteArray(&deleteArray_TRandom3);
      instance.SetDestructor(&destruct_TRandom3);
      instance.SetStreamerFunc(&streamer_TRandom3);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRandom3*)
   {
      return GenerateInitInstanceLocal((::TRandom3*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TRandom3*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TVirtualFitter_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void delete_TVirtualFitter(void *p);
   static void deleteArray_TVirtualFitter(void *p);
   static void destruct_TVirtualFitter(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualFitter*)
   {
      ::TVirtualFitter *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualFitter >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualFitter", ::TVirtualFitter::Class_Version(), "include/TVirtualFitter.h", 33,
                  typeid(::TVirtualFitter), DefineBehavior(ptr, ptr),
                  &::TVirtualFitter::Dictionary, isa_proxy, 4,
                  sizeof(::TVirtualFitter) );
      instance.SetDelete(&delete_TVirtualFitter);
      instance.SetDeleteArray(&deleteArray_TVirtualFitter);
      instance.SetDestructor(&destruct_TVirtualFitter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualFitter*)
   {
      return GenerateInitInstanceLocal((::TVirtualFitter*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TVirtualFitter*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TKDTreelEintcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TKDTreelEintcOdoublegR_Dictionary();
   static void *new_TKDTreelEintcOdoublegR(void *p = 0);
   static void *newArray_TKDTreelEintcOdoublegR(Long_t size, void *p);
   static void delete_TKDTreelEintcOdoublegR(void *p);
   static void deleteArray_TKDTreelEintcOdoublegR(void *p);
   static void destruct_TKDTreelEintcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TKDTree<int,double>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TKDTree<int,double>) == sizeof(::ROOT::Shadow::TKDTreelEintcOdoublegR));
      ::TKDTree<int,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TKDTree<int,double> >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TKDTree<int,double>", ::TKDTree<int,double>::Class_Version(), "include/TKDTree.h", 12,
                  typeid(::TKDTree<int,double>), DefineBehavior(ptr, ptr),
                  &TKDTreelEintcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(::TKDTree<int,double>) );
      instance.SetNew(&new_TKDTreelEintcOdoublegR);
      instance.SetNewArray(&newArray_TKDTreelEintcOdoublegR);
      instance.SetDelete(&delete_TKDTreelEintcOdoublegR);
      instance.SetDeleteArray(&deleteArray_TKDTreelEintcOdoublegR);
      instance.SetDestructor(&destruct_TKDTreelEintcOdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TKDTree<int,double>*)
   {
      return GenerateInitInstanceLocal((::TKDTree<int,double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TKDTree<int,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TKDTreelEintcOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TKDTreelEintcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TKDTreelEintcOfloatgR_Dictionary();
   static void *new_TKDTreelEintcOfloatgR(void *p = 0);
   static void *newArray_TKDTreelEintcOfloatgR(Long_t size, void *p);
   static void delete_TKDTreelEintcOfloatgR(void *p);
   static void deleteArray_TKDTreelEintcOfloatgR(void *p);
   static void destruct_TKDTreelEintcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TKDTree<int,float>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TKDTree<int,float>) == sizeof(::ROOT::Shadow::TKDTreelEintcOfloatgR));
      ::TKDTree<int,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TKDTree<int,float> >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TKDTree<int,float>", ::TKDTree<int,float>::Class_Version(), "include/TKDTree.h", 12,
                  typeid(::TKDTree<int,float>), DefineBehavior(ptr, ptr),
                  &TKDTreelEintcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(::TKDTree<int,float>) );
      instance.SetNew(&new_TKDTreelEintcOfloatgR);
      instance.SetNewArray(&newArray_TKDTreelEintcOfloatgR);
      instance.SetDelete(&delete_TKDTreelEintcOfloatgR);
      instance.SetDeleteArray(&deleteArray_TKDTreelEintcOfloatgR);
      instance.SetDestructor(&destruct_TKDTreelEintcOfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TKDTree<int,float>*)
   {
      return GenerateInitInstanceLocal((::TKDTree<int,float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TKDTree<int,float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TKDTreelEintcOfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TKDTreeBinning_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void delete_TKDTreeBinning(void *p);
   static void deleteArray_TKDTreeBinning(void *p);
   static void destruct_TKDTreeBinning(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TKDTreeBinning*)
   {
      ::TKDTreeBinning *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TKDTreeBinning >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TKDTreeBinning", ::TKDTreeBinning::Class_Version(), "include/TKDTreeBinning.h", 28,
                  typeid(::TKDTreeBinning), DefineBehavior(ptr, ptr),
                  &::TKDTreeBinning::Dictionary, isa_proxy, 4,
                  sizeof(::TKDTreeBinning) );
      instance.SetDelete(&delete_TKDTreeBinning);
      instance.SetDeleteArray(&deleteArray_TKDTreeBinning);
      instance.SetDestructor(&destruct_TKDTreeBinning);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TKDTreeBinning*)
   {
      return GenerateInitInstanceLocal((::TKDTreeBinning*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TKDTreeBinning*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator_Dictionary();
   static void *new_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p = 0);
   static void *newArray_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(Long_t size, void *p);
   static void delete_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p);
   static void deleteArray_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p);
   static void destruct_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::vector<double,allocator<double> >::iterator*)
   {
      ::vector<double,allocator<double> >::iterator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::vector<double,allocator<double> >::iterator),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<double,allocator<double> >::iterator", "prec_stl/vector", 218,
                  typeid(::vector<double,allocator<double> >::iterator), DefineBehavior(ptr, ptr),
                  0, &vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator_Dictionary, isa_proxy, 0,
                  sizeof(::vector<double,allocator<double> >::iterator) );
      instance.SetNew(&new_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator);
      instance.SetNewArray(&newArray_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator);
      instance.SetDelete(&delete_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator);
      instance.SetDeleteArray(&deleteArray_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator);
      instance.SetDestructor(&destruct_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::vector<double,allocator<double> >::iterator*)
   {
      return GenerateInitInstanceLocal((::vector<double,allocator<double> >::iterator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::vector<double,allocator<double> >::iterator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::vector<double,allocator<double> >::iterator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR_Dictionary();
   static void *new_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p = 0);
   static void *newArray_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(Long_t size, void *p);
   static void delete_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p);
   static void deleteArray_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p);
   static void destruct_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::reverse_iterator<vector<double,allocator<double> >::iterator>*)
   {
      ::reverse_iterator<vector<double,allocator<double> >::iterator> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::reverse_iterator<vector<double,allocator<double> >::iterator>),0);
      static ::ROOT::TGenericClassInfo 
         instance("reverse_iterator<vector<double,allocator<double> >::iterator>", "prec_stl/iterator", 166,
                  typeid(::reverse_iterator<vector<double,allocator<double> >::iterator>), DefineBehavior(ptr, ptr),
                  0, &reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR_Dictionary, isa_proxy, 0,
                  sizeof(::reverse_iterator<vector<double,allocator<double> >::iterator>) );
      instance.SetNew(&new_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
      instance.SetNewArray(&newArray_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
      instance.SetDelete(&delete_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
      instance.SetDeleteArray(&deleteArray_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
      instance.SetDestructor(&destruct_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::reverse_iterator<vector<double,allocator<double> >::iterator>*)
   {
      return GenerateInitInstanceLocal((::reverse_iterator<vector<double,allocator<double> >::iterator>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::reverse_iterator<vector<double,allocator<double> >::iterator>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::reverse_iterator<vector<double,allocator<double> >::iterator>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
namespace Math {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ROOTcLcLMath_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT::Math", 0 /*version*/, "include/Math/QuantFuncMathCore.h", 32,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ROOTcLcLMath_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ROOTcLcLMath_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}
}

namespace ROOT {
   void ROOTcLcLMathcLcLIBaseFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIBaseFunctionOneDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIBaseFunctionOneDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIBaseFunctionOneDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIBaseFunctionOneDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IBaseFunctionOneDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IBaseFunctionOneDim) == sizeof(::ROOT::Shadow::ROOT::Math::IBaseFunctionOneDim));
      ::ROOT::Math::IBaseFunctionOneDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IBaseFunctionOneDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IBaseFunctionOneDim", "include/Math/IFunction.h", 130,
                  typeid(::ROOT::Math::IBaseFunctionOneDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIBaseFunctionOneDim_ShowMembers, &ROOTcLcLMathcLcLIBaseFunctionOneDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IBaseFunctionOneDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIBaseFunctionOneDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIBaseFunctionOneDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIBaseFunctionOneDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IBaseFunctionOneDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IBaseFunctionOneDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IBaseFunctionOneDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIBaseFunctionOneDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IBaseFunctionOneDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIGradientFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIGradientFunctionOneDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIGradientFunctionOneDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIGradientFunctionOneDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIGradientFunctionOneDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IGradientFunctionOneDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IGradientFunctionOneDim) == sizeof(::ROOT::Shadow::ROOT::Math::IGradientFunctionOneDim));
      ::ROOT::Math::IGradientFunctionOneDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IGradientFunctionOneDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IGradientFunctionOneDim", "include/Math/IFunction.h", 380,
                  typeid(::ROOT::Math::IGradientFunctionOneDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIGradientFunctionOneDim_ShowMembers, &ROOTcLcLMathcLcLIGradientFunctionOneDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IGradientFunctionOneDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIGradientFunctionOneDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIGradientFunctionOneDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIGradientFunctionOneDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IGradientFunctionOneDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IGradientFunctionOneDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IGradientFunctionOneDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIGradientFunctionOneDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientFunctionOneDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIBaseFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIBaseFunctionMultiDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIBaseFunctionMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIBaseFunctionMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIBaseFunctionMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IBaseFunctionMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IBaseFunctionMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::IBaseFunctionMultiDim));
      ::ROOT::Math::IBaseFunctionMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IBaseFunctionMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IBaseFunctionMultiDim", "include/Math/IFunction.h", 60,
                  typeid(::ROOT::Math::IBaseFunctionMultiDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIBaseFunctionMultiDim_ShowMembers, &ROOTcLcLMathcLcLIBaseFunctionMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IBaseFunctionMultiDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIBaseFunctionMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIBaseFunctionMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIBaseFunctionMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IBaseFunctionMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IBaseFunctionMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IBaseFunctionMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIBaseFunctionMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IBaseFunctionMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIGradientFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIGradientFunctionMultiDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIGradientFunctionMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIGradientFunctionMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIGradientFunctionMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IGradientFunctionMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IGradientFunctionMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::IGradientFunctionMultiDim));
      ::ROOT::Math::IGradientFunctionMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IGradientFunctionMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IGradientFunctionMultiDim", "include/Math/IFunction.h", 320,
                  typeid(::ROOT::Math::IGradientFunctionMultiDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIGradientFunctionMultiDim_ShowMembers, &ROOTcLcLMathcLcLIGradientFunctionMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IGradientFunctionMultiDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIGradientFunctionMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIGradientFunctionMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIGradientFunctionMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IGradientFunctionMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IGradientFunctionMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IGradientFunctionMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIGradientFunctionMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientFunctionMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIGradientMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIGradientMultiDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIGradientMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIGradientMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIGradientMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IGradientMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IGradientMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::IGradientMultiDim));
      ::ROOT::Math::IGradientMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IGradientMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IGradientMultiDim", "include/Math/IFunction.h", 193,
                  typeid(::ROOT::Math::IGradientMultiDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIGradientMultiDim_ShowMembers, &ROOTcLcLMathcLcLIGradientMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IGradientMultiDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIGradientMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIGradientMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIGradientMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IGradientMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IGradientMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IGradientMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIGradientMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIGradientOneDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIGradientOneDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIGradientOneDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIGradientOneDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIGradientOneDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IGradientOneDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IGradientOneDim) == sizeof(::ROOT::Shadow::ROOT::Math::IGradientOneDim));
      ::ROOT::Math::IGradientOneDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IGradientOneDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IGradientOneDim", "include/Math/IFunction.h", 244,
                  typeid(::ROOT::Math::IGradientOneDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIGradientOneDim_ShowMembers, &ROOTcLcLMathcLcLIGradientOneDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IGradientOneDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIGradientOneDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIGradientOneDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIGradientOneDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IGradientOneDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IGradientOneDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IGradientOneDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIGradientOneDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientOneDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIParametricFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIParametricFunctionOneDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIParametricFunctionOneDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIParametricFunctionOneDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIParametricFunctionOneDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IParametricFunctionOneDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IParametricFunctionOneDim) == sizeof(::ROOT::Shadow::ROOT::Math::IParametricFunctionOneDim));
      ::ROOT::Math::IParametricFunctionOneDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IParametricFunctionOneDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IParametricFunctionOneDim", "include/Math/IParamFunction.h", 159,
                  typeid(::ROOT::Math::IParametricFunctionOneDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIParametricFunctionOneDim_ShowMembers, &ROOTcLcLMathcLcLIParametricFunctionOneDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IParametricFunctionOneDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIParametricFunctionOneDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIParametricFunctionOneDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIParametricFunctionOneDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IParametricFunctionOneDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IParametricFunctionOneDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IParametricFunctionOneDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIParametricFunctionOneDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricFunctionOneDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIParametricGradFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIParametricGradFunctionOneDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIParametricGradFunctionOneDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIParametricGradFunctionOneDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIParametricGradFunctionOneDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IParametricGradFunctionOneDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IParametricGradFunctionOneDim) == sizeof(::ROOT::Shadow::ROOT::Math::IParametricGradFunctionOneDim));
      ::ROOT::Math::IParametricGradFunctionOneDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IParametricGradFunctionOneDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IParametricGradFunctionOneDim", "include/Math/IParamFunction.h", 302,
                  typeid(::ROOT::Math::IParametricGradFunctionOneDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIParametricGradFunctionOneDim_ShowMembers, &ROOTcLcLMathcLcLIParametricGradFunctionOneDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IParametricGradFunctionOneDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIParametricGradFunctionOneDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIParametricGradFunctionOneDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIParametricGradFunctionOneDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IParametricGradFunctionOneDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IParametricGradFunctionOneDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IParametricGradFunctionOneDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIParametricGradFunctionOneDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricGradFunctionOneDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIParametricFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIParametricFunctionMultiDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIParametricFunctionMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIParametricFunctionMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIParametricFunctionMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IParametricFunctionMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IParametricFunctionMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::IParametricFunctionMultiDim));
      ::ROOT::Math::IParametricFunctionMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IParametricFunctionMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IParametricFunctionMultiDim", "include/Math/IParamFunction.h", 109,
                  typeid(::ROOT::Math::IParametricFunctionMultiDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIParametricFunctionMultiDim_ShowMembers, &ROOTcLcLMathcLcLIParametricFunctionMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IParametricFunctionMultiDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIParametricFunctionMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIParametricFunctionMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIParametricFunctionMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IParametricFunctionMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IParametricFunctionMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IParametricFunctionMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIParametricFunctionMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricFunctionMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IParametricGradFunctionMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IParametricGradFunctionMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::IParametricGradFunctionMultiDim));
      ::ROOT::Math::IParametricGradFunctionMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IParametricGradFunctionMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IParametricGradFunctionMultiDim", "include/Math/IParamFunction.h", 225,
                  typeid(::ROOT::Math::IParametricGradFunctionMultiDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_ShowMembers, &ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IParametricGradFunctionMultiDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IParametricGradFunctionMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IParametricGradFunctionMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IParametricGradFunctionMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricGradFunctionMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIBaseParam_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIBaseParam_Dictionary();
   static void delete_ROOTcLcLMathcLcLIBaseParam(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIBaseParam(void *p);
   static void destruct_ROOTcLcLMathcLcLIBaseParam(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IBaseParam*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IBaseParam) == sizeof(::ROOT::Shadow::ROOT::Math::IBaseParam));
      ::ROOT::Math::IBaseParam *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IBaseParam),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IBaseParam", "include/Math/IParamFunction.h", 53,
                  typeid(::ROOT::Math::IBaseParam), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIBaseParam_ShowMembers, &ROOTcLcLMathcLcLIBaseParam_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IBaseParam) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIBaseParam);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIBaseParam);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIBaseParam);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IBaseParam*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IBaseParam*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IBaseParam*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIBaseParam_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IBaseParam*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLParamFunctor_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLParamFunctor_Dictionary();
   static void *new_ROOTcLcLMathcLcLParamFunctor(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLParamFunctor(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLParamFunctor(void *p);
   static void deleteArray_ROOTcLcLMathcLcLParamFunctor(void *p);
   static void destruct_ROOTcLcLMathcLcLParamFunctor(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::ParamFunctor*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::ParamFunctor) == sizeof(::ROOT::Shadow::ROOT::Math::ParamFunctor));
      ::ROOT::Math::ParamFunctor *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::ParamFunctor),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::ParamFunctor", "include/Math/ParamFunctor.h", 209,
                  typeid(::ROOT::Math::ParamFunctor), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLParamFunctor_ShowMembers, &ROOTcLcLMathcLcLParamFunctor_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::ParamFunctor) );
      instance.SetNew(&new_ROOTcLcLMathcLcLParamFunctor);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLParamFunctor);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLParamFunctor);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLParamFunctor);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLParamFunctor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::ParamFunctor*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::ParamFunctor*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::ParamFunctor*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLParamFunctor_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::ParamFunctor*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLFunctor_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLFunctor_Dictionary();
   static void *new_ROOTcLcLMathcLcLFunctor(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLFunctor(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLFunctor(void *p);
   static void deleteArray_ROOTcLcLMathcLcLFunctor(void *p);
   static void destruct_ROOTcLcLMathcLcLFunctor(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Functor*)
   {
      ::ROOT::Math::Functor *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Functor),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Functor", "include/Math/Functor.h", 340,
                  typeid(::ROOT::Math::Functor), DefineBehavior(ptr, ptr),
                  0, &ROOTcLcLMathcLcLFunctor_Dictionary, isa_proxy, 1,
                  sizeof(::ROOT::Math::Functor) );
      instance.SetNew(&new_ROOTcLcLMathcLcLFunctor);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLFunctor);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLFunctor);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLFunctor);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLFunctor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Functor*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Functor*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Functor*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLFunctor_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Functor*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLFunctor1D_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLFunctor1D_Dictionary();
   static void *new_ROOTcLcLMathcLcLFunctor1D(void *p = 0);
   static void delete_ROOTcLcLMathcLcLFunctor1D(void *p);
   static void deleteArray_ROOTcLcLMathcLcLFunctor1D(void *p);
   static void destruct_ROOTcLcLMathcLcLFunctor1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Functor1D*)
   {
      ::ROOT::Math::Functor1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Functor1D),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Functor1D", "include/Math/Functor.h", 447,
                  typeid(::ROOT::Math::Functor1D), DefineBehavior(ptr, ptr),
                  0, &ROOTcLcLMathcLcLFunctor1D_Dictionary, isa_proxy, 1,
                  sizeof(::ROOT::Math::Functor1D) );
      instance.SetNew(&new_ROOTcLcLMathcLcLFunctor1D);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLFunctor1D);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLFunctor1D);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLFunctor1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Functor1D*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Functor1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Functor1D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLFunctor1D_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Functor1D*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGradFunctor_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGradFunctor_Dictionary();
   static void *new_ROOTcLcLMathcLcLGradFunctor(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGradFunctor(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGradFunctor(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGradFunctor(void *p);
   static void destruct_ROOTcLcLMathcLcLGradFunctor(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GradFunctor*)
   {
      ::ROOT::Math::GradFunctor *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GradFunctor),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GradFunctor", "include/Math/Functor.h", 554,
                  typeid(::ROOT::Math::GradFunctor), DefineBehavior(ptr, ptr),
                  0, &ROOTcLcLMathcLcLGradFunctor_Dictionary, isa_proxy, 1,
                  sizeof(::ROOT::Math::GradFunctor) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGradFunctor);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGradFunctor);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGradFunctor);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGradFunctor);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGradFunctor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GradFunctor*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GradFunctor*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GradFunctor*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGradFunctor_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GradFunctor*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGradFunctor1D_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGradFunctor1D_Dictionary();
   static void *new_ROOTcLcLMathcLcLGradFunctor1D(void *p = 0);
   static void delete_ROOTcLcLMathcLcLGradFunctor1D(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGradFunctor1D(void *p);
   static void destruct_ROOTcLcLMathcLcLGradFunctor1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GradFunctor1D*)
   {
      ::ROOT::Math::GradFunctor1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GradFunctor1D),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GradFunctor1D", "include/Math/Functor.h", 677,
                  typeid(::ROOT::Math::GradFunctor1D), DefineBehavior(ptr, ptr),
                  0, &ROOTcLcLMathcLcLGradFunctor1D_Dictionary, isa_proxy, 1,
                  sizeof(::ROOT::Math::GradFunctor1D) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGradFunctor1D);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGradFunctor1D);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGradFunctor1D);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGradFunctor1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GradFunctor1D*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GradFunctor1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GradFunctor1D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGradFunctor1D_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GradFunctor1D*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIOptions_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIOptions_Dictionary();
   static void delete_ROOTcLcLMathcLcLIOptions(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIOptions(void *p);
   static void destruct_ROOTcLcLMathcLcLIOptions(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IOptions*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IOptions) == sizeof(::ROOT::Shadow::ROOT::Math::IOptions));
      ::ROOT::Math::IOptions *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IOptions),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IOptions", "include/Math/IOptions.h", 32,
                  typeid(::ROOT::Math::IOptions), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIOptions_ShowMembers, &ROOTcLcLMathcLcLIOptions_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IOptions) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIOptions);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIOptions);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIOptions);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IOptions*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IOptions*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IOptions*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIOptions_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IOptions*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLMinimizerOptions_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLMinimizerOptions_Dictionary();
   static void *new_ROOTcLcLMathcLcLMinimizerOptions(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLMinimizerOptions(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLMinimizerOptions(void *p);
   static void deleteArray_ROOTcLcLMathcLcLMinimizerOptions(void *p);
   static void destruct_ROOTcLcLMathcLcLMinimizerOptions(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::MinimizerOptions*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::MinimizerOptions) == sizeof(::ROOT::Shadow::ROOT::Math::MinimizerOptions));
      ::ROOT::Math::MinimizerOptions *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::MinimizerOptions),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::MinimizerOptions", "include/Math/MinimizerOptions.h", 32,
                  typeid(::ROOT::Math::MinimizerOptions), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLMinimizerOptions_ShowMembers, &ROOTcLcLMathcLcLMinimizerOptions_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::MinimizerOptions) );
      instance.SetNew(&new_ROOTcLcLMathcLcLMinimizerOptions);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLMinimizerOptions);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLMinimizerOptions);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLMinimizerOptions);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLMinimizerOptions);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::MinimizerOptions*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::MinimizerOptions*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::MinimizerOptions*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLMinimizerOptions_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::MinimizerOptions*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLMinimizer_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLMinimizer_Dictionary();
   static void delete_ROOTcLcLMathcLcLMinimizer(void *p);
   static void deleteArray_ROOTcLcLMathcLcLMinimizer(void *p);
   static void destruct_ROOTcLcLMathcLcLMinimizer(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Minimizer*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Minimizer) == sizeof(::ROOT::Shadow::ROOT::Math::Minimizer));
      ::ROOT::Math::Minimizer *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Minimizer),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Minimizer", "include/Math/Minimizer.h", 73,
                  typeid(::ROOT::Math::Minimizer), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLMinimizer_ShowMembers, &ROOTcLcLMathcLcLMinimizer_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Minimizer) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLMinimizer);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLMinimizer);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLMinimizer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Minimizer*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Minimizer*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Minimizer*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLMinimizer_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Minimizer*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
namespace Math {
namespace IntegrationOneDim {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ROOTcLcLMathcLcLIntegrationOneDim_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT::Math::IntegrationOneDim", 0 /*version*/, "include/Math/AllIntegrationTypes.h", 30,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ROOTcLcLMathcLcLIntegrationOneDim_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ROOTcLcLMathcLcLIntegrationOneDim_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}
}
}

namespace ROOT {
namespace Math {
namespace IntegrationMultiDim {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ROOTcLcLMathcLcLIntegrationMultiDim_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT::Math::IntegrationMultiDim", 0 /*version*/, "include/Math/AllIntegrationTypes.h", 50,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ROOTcLcLMathcLcLIntegrationMultiDim_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ROOTcLcLMathcLcLIntegrationMultiDim_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}
}
}

namespace ROOT {
   void ROOTcLcLMathcLcLBaseIntegratorOptions_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLBaseIntegratorOptions_Dictionary();
   static void delete_ROOTcLcLMathcLcLBaseIntegratorOptions(void *p);
   static void deleteArray_ROOTcLcLMathcLcLBaseIntegratorOptions(void *p);
   static void destruct_ROOTcLcLMathcLcLBaseIntegratorOptions(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::BaseIntegratorOptions*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::BaseIntegratorOptions) == sizeof(::ROOT::Shadow::ROOT::Math::BaseIntegratorOptions));
      ::ROOT::Math::BaseIntegratorOptions *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::BaseIntegratorOptions),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::BaseIntegratorOptions", "include/Math/IntegratorOptions.h", 37,
                  typeid(::ROOT::Math::BaseIntegratorOptions), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLBaseIntegratorOptions_ShowMembers, &ROOTcLcLMathcLcLBaseIntegratorOptions_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::BaseIntegratorOptions) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLBaseIntegratorOptions);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLBaseIntegratorOptions);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLBaseIntegratorOptions);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::BaseIntegratorOptions*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::BaseIntegratorOptions*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::BaseIntegratorOptions*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLBaseIntegratorOptions_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BaseIntegratorOptions*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIntegratorOneDimOptions_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIntegratorOneDimOptions_Dictionary();
   static void *new_ROOTcLcLMathcLcLIntegratorOneDimOptions(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLIntegratorOneDimOptions(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLIntegratorOneDimOptions(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIntegratorOneDimOptions(void *p);
   static void destruct_ROOTcLcLMathcLcLIntegratorOneDimOptions(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IntegratorOneDimOptions*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IntegratorOneDimOptions) == sizeof(::ROOT::Shadow::ROOT::Math::IntegratorOneDimOptions));
      ::ROOT::Math::IntegratorOneDimOptions *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IntegratorOneDimOptions),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IntegratorOneDimOptions", "include/Math/IntegratorOptions.h", 115,
                  typeid(::ROOT::Math::IntegratorOneDimOptions), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIntegratorOneDimOptions_ShowMembers, &ROOTcLcLMathcLcLIntegratorOneDimOptions_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IntegratorOneDimOptions) );
      instance.SetNew(&new_ROOTcLcLMathcLcLIntegratorOneDimOptions);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLIntegratorOneDimOptions);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIntegratorOneDimOptions);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIntegratorOneDimOptions);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIntegratorOneDimOptions);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IntegratorOneDimOptions*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IntegratorOneDimOptions*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorOneDimOptions*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIntegratorOneDimOptions_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorOneDimOptions*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIntegratorMultiDimOptions_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIntegratorMultiDimOptions_Dictionary();
   static void *new_ROOTcLcLMathcLcLIntegratorMultiDimOptions(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLIntegratorMultiDimOptions(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLIntegratorMultiDimOptions(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIntegratorMultiDimOptions(void *p);
   static void destruct_ROOTcLcLMathcLcLIntegratorMultiDimOptions(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IntegratorMultiDimOptions*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IntegratorMultiDimOptions) == sizeof(::ROOT::Shadow::ROOT::Math::IntegratorMultiDimOptions));
      ::ROOT::Math::IntegratorMultiDimOptions *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IntegratorMultiDimOptions),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IntegratorMultiDimOptions", "include/Math/IntegratorOptions.h", 196,
                  typeid(::ROOT::Math::IntegratorMultiDimOptions), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIntegratorMultiDimOptions_ShowMembers, &ROOTcLcLMathcLcLIntegratorMultiDimOptions_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IntegratorMultiDimOptions) );
      instance.SetNew(&new_ROOTcLcLMathcLcLIntegratorMultiDimOptions);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLIntegratorMultiDimOptions);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIntegratorMultiDimOptions);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIntegratorMultiDimOptions);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIntegratorMultiDimOptions);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IntegratorMultiDimOptions*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IntegratorMultiDimOptions*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorMultiDimOptions*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIntegratorMultiDimOptions_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorMultiDimOptions*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLVirtualIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLVirtualIntegrator_Dictionary();
   static void delete_ROOTcLcLMathcLcLVirtualIntegrator(void *p);
   static void deleteArray_ROOTcLcLMathcLcLVirtualIntegrator(void *p);
   static void destruct_ROOTcLcLMathcLcLVirtualIntegrator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::VirtualIntegrator*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::VirtualIntegrator) == sizeof(::ROOT::Shadow::ROOT::Math::VirtualIntegrator));
      ::ROOT::Math::VirtualIntegrator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::VirtualIntegrator),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::VirtualIntegrator", "include/Math/VirtualIntegrator.h", 55,
                  typeid(::ROOT::Math::VirtualIntegrator), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLVirtualIntegrator_ShowMembers, &ROOTcLcLMathcLcLVirtualIntegrator_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::VirtualIntegrator) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLVirtualIntegrator);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLVirtualIntegrator);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLVirtualIntegrator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::VirtualIntegrator*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::VirtualIntegrator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegrator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLVirtualIntegrator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegrator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLVirtualIntegratorOneDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLVirtualIntegratorOneDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLVirtualIntegratorOneDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLVirtualIntegratorOneDim(void *p);
   static void destruct_ROOTcLcLMathcLcLVirtualIntegratorOneDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::VirtualIntegratorOneDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::VirtualIntegratorOneDim) == sizeof(::ROOT::Shadow::ROOT::Math::VirtualIntegratorOneDim));
      ::ROOT::Math::VirtualIntegratorOneDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::VirtualIntegratorOneDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::VirtualIntegratorOneDim", "include/Math/VirtualIntegrator.h", 111,
                  typeid(::ROOT::Math::VirtualIntegratorOneDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLVirtualIntegratorOneDim_ShowMembers, &ROOTcLcLMathcLcLVirtualIntegratorOneDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::VirtualIntegratorOneDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLVirtualIntegratorOneDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLVirtualIntegratorOneDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLVirtualIntegratorOneDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::VirtualIntegratorOneDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::VirtualIntegratorOneDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegratorOneDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLVirtualIntegratorOneDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegratorOneDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLVirtualIntegratorMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLVirtualIntegratorMultiDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLVirtualIntegratorMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLVirtualIntegratorMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLVirtualIntegratorMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::VirtualIntegratorMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::VirtualIntegratorMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::VirtualIntegratorMultiDim));
      ::ROOT::Math::VirtualIntegratorMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::VirtualIntegratorMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::VirtualIntegratorMultiDim", "include/Math/VirtualIntegrator.h", 172,
                  typeid(::ROOT::Math::VirtualIntegratorMultiDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLVirtualIntegratorMultiDim_ShowMembers, &ROOTcLcLMathcLcLVirtualIntegratorMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::VirtualIntegratorMultiDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLVirtualIntegratorMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLVirtualIntegratorMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLVirtualIntegratorMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::VirtualIntegratorMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::VirtualIntegratorMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegratorMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLVirtualIntegratorMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegratorMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIntegratorOneDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIntegratorOneDim_Dictionary();
   static void *new_ROOTcLcLMathcLcLIntegratorOneDim(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLIntegratorOneDim(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLIntegratorOneDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIntegratorOneDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIntegratorOneDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IntegratorOneDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IntegratorOneDim) == sizeof(::ROOT::Shadow::ROOT::Math::IntegratorOneDim));
      ::ROOT::Math::IntegratorOneDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IntegratorOneDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IntegratorOneDim", "include/Math/Integrator.h", 85,
                  typeid(::ROOT::Math::IntegratorOneDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIntegratorOneDim_ShowMembers, &ROOTcLcLMathcLcLIntegratorOneDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IntegratorOneDim) );
      instance.SetNew(&new_ROOTcLcLMathcLcLIntegratorOneDim);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLIntegratorOneDim);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIntegratorOneDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIntegratorOneDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIntegratorOneDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IntegratorOneDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IntegratorOneDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorOneDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIntegratorOneDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorOneDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim_Dictionary();
   static void *new_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::AdaptiveIntegratorMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::AdaptiveIntegratorMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::AdaptiveIntegratorMultiDim));
      ::ROOT::Math::AdaptiveIntegratorMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::AdaptiveIntegratorMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::AdaptiveIntegratorMultiDim", "include/Math/AdaptiveIntegratorMultiDim.h", 41,
                  typeid(::ROOT::Math::AdaptiveIntegratorMultiDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim_ShowMembers, &ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::AdaptiveIntegratorMultiDim) );
      instance.SetNew(&new_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::AdaptiveIntegratorMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::AdaptiveIntegratorMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::AdaptiveIntegratorMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::AdaptiveIntegratorMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIntegratorMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIntegratorMultiDim_Dictionary();
   static void *new_ROOTcLcLMathcLcLIntegratorMultiDim(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLIntegratorMultiDim(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLIntegratorMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIntegratorMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIntegratorMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IntegratorMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IntegratorMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::IntegratorMultiDim));
      ::ROOT::Math::IntegratorMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IntegratorMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IntegratorMultiDim", "include/Math/IntegratorMultiDim.h", 60,
                  typeid(::ROOT::Math::IntegratorMultiDim), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIntegratorMultiDim_ShowMembers, &ROOTcLcLMathcLcLIntegratorMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IntegratorMultiDim) );
      instance.SetNew(&new_ROOTcLcLMathcLcLIntegratorMultiDim);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLIntegratorMultiDim);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIntegratorMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIntegratorMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIntegratorMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IntegratorMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IntegratorMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIntegratorMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLDistSampler_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLDistSampler_Dictionary();
   static void delete_ROOTcLcLMathcLcLDistSampler(void *p);
   static void deleteArray_ROOTcLcLMathcLcLDistSampler(void *p);
   static void destruct_ROOTcLcLMathcLcLDistSampler(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::DistSampler*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::DistSampler) == sizeof(::ROOT::Shadow::ROOT::Math::DistSampler));
      ::ROOT::Math::DistSampler *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::DistSampler),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::DistSampler", "include/Math/DistSampler.h", 59,
                  typeid(::ROOT::Math::DistSampler), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLDistSampler_ShowMembers, &ROOTcLcLMathcLcLDistSampler_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::DistSampler) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLDistSampler);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLDistSampler);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLDistSampler);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::DistSampler*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::DistSampler*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::DistSampler*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLDistSampler_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::DistSampler*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLFactory_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLFactory_Dictionary();
   static void *new_ROOTcLcLMathcLcLFactory(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLFactory(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLFactory(void *p);
   static void deleteArray_ROOTcLcLMathcLcLFactory(void *p);
   static void destruct_ROOTcLcLMathcLcLFactory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Factory*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Factory) == sizeof(::ROOT::Shadow::ROOT::Math::Factory));
      ::ROOT::Math::Factory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Factory),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Factory", "include/Math/Factory.h", 31,
                  typeid(::ROOT::Math::Factory), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLFactory_ShowMembers, &ROOTcLcLMathcLcLFactory_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Factory) );
      instance.SetNew(&new_ROOTcLcLMathcLcLFactory);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLFactory);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLFactory);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLFactory);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLFactory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Factory*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Factory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Factory*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLFactory_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Factory*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR_Dictionary();
   static void delete_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void *p);
   static void destruct_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>) == sizeof(::ROOT::Shadow::ROOT::Math::BasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR));
      ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>", "include/Math/FitMethodFunction.h", 34,
                  typeid(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR_ShowMembers, &ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_Dictionary();
   static void delete_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void *p);
   static void destruct_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>) == sizeof(::ROOT::Shadow::ROOT::Math::BasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR));
      ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>", "include/Math/FitMethodFunction.h", 34,
                  typeid(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_ShowMembers, &ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGaussIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGaussIntegrator_Dictionary();
   static void *new_ROOTcLcLMathcLcLGaussIntegrator(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGaussIntegrator(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGaussIntegrator(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGaussIntegrator(void *p);
   static void destruct_ROOTcLcLMathcLcLGaussIntegrator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GaussIntegrator*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GaussIntegrator) == sizeof(::ROOT::Shadow::ROOT::Math::GaussIntegrator));
      ::ROOT::Math::GaussIntegrator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GaussIntegrator),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GaussIntegrator", "include/Math/GaussIntegrator.h", 43,
                  typeid(::ROOT::Math::GaussIntegrator), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGaussIntegrator_ShowMembers, &ROOTcLcLMathcLcLGaussIntegrator_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GaussIntegrator) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGaussIntegrator);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGaussIntegrator);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGaussIntegrator);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGaussIntegrator);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGaussIntegrator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GaussIntegrator*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GaussIntegrator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GaussIntegrator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGaussIntegrator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GaussIntegrator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGaussLegendreIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGaussLegendreIntegrator_Dictionary();
   static void *new_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGaussLegendreIntegrator(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p);
   static void destruct_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GaussLegendreIntegrator*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GaussLegendreIntegrator) == sizeof(::ROOT::Shadow::ROOT::Math::GaussLegendreIntegrator));
      ::ROOT::Math::GaussLegendreIntegrator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GaussLegendreIntegrator),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GaussLegendreIntegrator", "include/Math/GaussLegendreIntegrator.h", 39,
                  typeid(::ROOT::Math::GaussLegendreIntegrator), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGaussLegendreIntegrator_ShowMembers, &ROOTcLcLMathcLcLGaussLegendreIntegrator_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GaussLegendreIntegrator) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGaussLegendreIntegrator);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGaussLegendreIntegrator);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGaussLegendreIntegrator);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGaussLegendreIntegrator);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGaussLegendreIntegrator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GaussLegendreIntegrator*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GaussLegendreIntegrator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GaussLegendreIntegrator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGaussLegendreIntegrator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GaussLegendreIntegrator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIRootFinderMethod_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIRootFinderMethod_Dictionary();
   static void delete_ROOTcLcLMathcLcLIRootFinderMethod(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIRootFinderMethod(void *p);
   static void destruct_ROOTcLcLMathcLcLIRootFinderMethod(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IRootFinderMethod*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IRootFinderMethod) == sizeof(::ROOT::Shadow::ROOT::Math::IRootFinderMethod));
      ::ROOT::Math::IRootFinderMethod *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IRootFinderMethod),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IRootFinderMethod", "include/Math/IRootFinderMethod.h", 38,
                  typeid(::ROOT::Math::IRootFinderMethod), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIRootFinderMethod_ShowMembers, &ROOTcLcLMathcLcLIRootFinderMethod_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IRootFinderMethod) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIRootFinderMethod);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIRootFinderMethod);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIRootFinderMethod);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IRootFinderMethod*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IRootFinderMethod*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IRootFinderMethod*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIRootFinderMethod_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IRootFinderMethod*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRootFinder_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRootFinder_Dictionary();
   static void *new_ROOTcLcLMathcLcLRootFinder(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRootFinder(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRootFinder(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRootFinder(void *p);
   static void destruct_ROOTcLcLMathcLcLRootFinder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::RootFinder*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::RootFinder) == sizeof(::ROOT::Shadow::ROOT::Math::RootFinder));
      ::ROOT::Math::RootFinder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::RootFinder),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::RootFinder", "include/Math/RootFinder.h", 87,
                  typeid(::ROOT::Math::RootFinder), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRootFinder_ShowMembers, &ROOTcLcLMathcLcLRootFinder_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::RootFinder) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRootFinder);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRootFinder);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRootFinder);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRootFinder);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRootFinder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::RootFinder*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::RootFinder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::RootFinder*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRootFinder_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::RootFinder*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRichardsonDerivator_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRichardsonDerivator_Dictionary();
   static void *new_ROOTcLcLMathcLcLRichardsonDerivator(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRichardsonDerivator(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRichardsonDerivator(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRichardsonDerivator(void *p);
   static void destruct_ROOTcLcLMathcLcLRichardsonDerivator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::RichardsonDerivator*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::RichardsonDerivator) == sizeof(::ROOT::Shadow::ROOT::Math::RichardsonDerivator));
      ::ROOT::Math::RichardsonDerivator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::RichardsonDerivator),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::RichardsonDerivator", "include/Math/RichardsonDerivator.h", 48,
                  typeid(::ROOT::Math::RichardsonDerivator), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRichardsonDerivator_ShowMembers, &ROOTcLcLMathcLcLRichardsonDerivator_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::RichardsonDerivator) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRichardsonDerivator);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRichardsonDerivator);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRichardsonDerivator);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRichardsonDerivator);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRichardsonDerivator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::RichardsonDerivator*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::RichardsonDerivator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::RichardsonDerivator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRichardsonDerivator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::RichardsonDerivator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIMinimizer1D_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLIMinimizer1D_Dictionary();
   static void delete_ROOTcLcLMathcLcLIMinimizer1D(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIMinimizer1D(void *p);
   static void destruct_ROOTcLcLMathcLcLIMinimizer1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IMinimizer1D*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IMinimizer1D) == sizeof(::ROOT::Shadow::ROOT::Math::IMinimizer1D));
      ::ROOT::Math::IMinimizer1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IMinimizer1D),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IMinimizer1D", "include/Math/IMinimizer1D.h", 49,
                  typeid(::ROOT::Math::IMinimizer1D), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLIMinimizer1D_ShowMembers, &ROOTcLcLMathcLcLIMinimizer1D_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IMinimizer1D) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIMinimizer1D);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIMinimizer1D);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIMinimizer1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IMinimizer1D*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IMinimizer1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IMinimizer1D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIMinimizer1D_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IMinimizer1D*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLBrentMinimizer1D_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLBrentMinimizer1D_Dictionary();
   static void *new_ROOTcLcLMathcLcLBrentMinimizer1D(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLBrentMinimizer1D(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLBrentMinimizer1D(void *p);
   static void deleteArray_ROOTcLcLMathcLcLBrentMinimizer1D(void *p);
   static void destruct_ROOTcLcLMathcLcLBrentMinimizer1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::BrentMinimizer1D*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::BrentMinimizer1D) == sizeof(::ROOT::Shadow::ROOT::Math::BrentMinimizer1D));
      ::ROOT::Math::BrentMinimizer1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::BrentMinimizer1D),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::BrentMinimizer1D", "include/Math/BrentMinimizer1D.h", 77,
                  typeid(::ROOT::Math::BrentMinimizer1D), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLBrentMinimizer1D_ShowMembers, &ROOTcLcLMathcLcLBrentMinimizer1D_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::BrentMinimizer1D) );
      instance.SetNew(&new_ROOTcLcLMathcLcLBrentMinimizer1D);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLBrentMinimizer1D);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLBrentMinimizer1D);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLBrentMinimizer1D);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLBrentMinimizer1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::BrentMinimizer1D*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::BrentMinimizer1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::BrentMinimizer1D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLBrentMinimizer1D_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BrentMinimizer1D*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLBrentRootFinder_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLBrentRootFinder_Dictionary();
   static void *new_ROOTcLcLMathcLcLBrentRootFinder(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLBrentRootFinder(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLBrentRootFinder(void *p);
   static void deleteArray_ROOTcLcLMathcLcLBrentRootFinder(void *p);
   static void destruct_ROOTcLcLMathcLcLBrentRootFinder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::BrentRootFinder*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::BrentRootFinder) == sizeof(::ROOT::Shadow::ROOT::Math::BrentRootFinder));
      ::ROOT::Math::BrentRootFinder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::BrentRootFinder),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::BrentRootFinder", "include/Math/BrentRootFinder.h", 66,
                  typeid(::ROOT::Math::BrentRootFinder), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLBrentRootFinder_ShowMembers, &ROOTcLcLMathcLcLBrentRootFinder_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::BrentRootFinder) );
      instance.SetNew(&new_ROOTcLcLMathcLcLBrentRootFinder);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLBrentRootFinder);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLBrentRootFinder);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLBrentRootFinder);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLBrentRootFinder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::BrentRootFinder*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::BrentRootFinder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::BrentRootFinder*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLBrentRootFinder_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BrentRootFinder*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLDistSamplerOptions_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLDistSamplerOptions_Dictionary();
   static void *new_ROOTcLcLMathcLcLDistSamplerOptions(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLDistSamplerOptions(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLDistSamplerOptions(void *p);
   static void deleteArray_ROOTcLcLMathcLcLDistSamplerOptions(void *p);
   static void destruct_ROOTcLcLMathcLcLDistSamplerOptions(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::DistSamplerOptions*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::DistSamplerOptions) == sizeof(::ROOT::Shadow::ROOT::Math::DistSamplerOptions));
      ::ROOT::Math::DistSamplerOptions *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::DistSamplerOptions),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::DistSamplerOptions", "include/Math/DistSamplerOptions.h", 32,
                  typeid(::ROOT::Math::DistSamplerOptions), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLDistSamplerOptions_ShowMembers, &ROOTcLcLMathcLcLDistSamplerOptions_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::DistSamplerOptions) );
      instance.SetNew(&new_ROOTcLcLMathcLcLDistSamplerOptions);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLDistSamplerOptions);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLDistSamplerOptions);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLDistSamplerOptions);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLDistSamplerOptions);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::DistSamplerOptions*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::DistSamplerOptions*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::DistSamplerOptions*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLDistSamplerOptions_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::DistSamplerOptions*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGoFTest_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGoFTest_Dictionary();
   static void delete_ROOTcLcLMathcLcLGoFTest(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGoFTest(void *p);
   static void destruct_ROOTcLcLMathcLcLGoFTest(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GoFTest*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GoFTest) == sizeof(::ROOT::Shadow::ROOT::Math::GoFTest));
      ::ROOT::Math::GoFTest *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GoFTest),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GoFTest", "include/Math/GoFTest.h", 30,
                  typeid(::ROOT::Math::GoFTest), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGoFTest_ShowMembers, &ROOTcLcLMathcLcLGoFTest_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GoFTest) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGoFTest);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGoFTest);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGoFTest);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GoFTest*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GoFTest*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GoFTest*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGoFTest_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GoFTest*)0x0)->GetClass();
   }

} // end of namespace ROOT

//______________________________________________________________________________
TClass *TRandom::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TRandom::Class_Name()
{
   return "TRandom";
}

//______________________________________________________________________________
const char *TRandom::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TRandom::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TRandom::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TRandom::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRandom1::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TRandom1::Class_Name()
{
   return "TRandom1";
}

//______________________________________________________________________________
const char *TRandom1::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom1*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TRandom1::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom1*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TRandom1::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom1*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TRandom1::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom1*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRandom2::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TRandom2::Class_Name()
{
   return "TRandom2";
}

//______________________________________________________________________________
const char *TRandom2::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom2*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TRandom2::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom2*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TRandom2::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom2*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TRandom2::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom2*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRandom3::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TRandom3::Class_Name()
{
   return "TRandom3";
}

//______________________________________________________________________________
const char *TRandom3::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom3*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TRandom3::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom3*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TRandom3::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom3*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TRandom3::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom3*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualFitter::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualFitter::Class_Name()
{
   return "TVirtualFitter";
}

//______________________________________________________________________________
const char *TVirtualFitter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualFitter*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualFitter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualFitter*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TVirtualFitter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualFitter*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TVirtualFitter::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualFitter*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TKDTree<int,double>::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TKDTree<int,double>::Class_Name()
{
   return "TKDTree<int,double>";
}

//______________________________________________________________________________
template <> const char *TKDTree<int,double>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,double>*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TKDTree<int,double>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,double>*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
template <> void TKDTree<int,double>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,double>*)0x0)->GetClass();
}

//______________________________________________________________________________
template <> TClass *TKDTree<int,double>::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,double>*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TKDTree<int,float>::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TKDTree<int,float>::Class_Name()
{
   return "TKDTree<int,float>";
}

//______________________________________________________________________________
template <> const char *TKDTree<int,float>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,float>*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TKDTree<int,float>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,float>*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
template <> void TKDTree<int,float>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,float>*)0x0)->GetClass();
}

//______________________________________________________________________________
template <> TClass *TKDTree<int,float>::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,float>*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TKDTreeBinning::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TKDTreeBinning::Class_Name()
{
   return "TKDTreeBinning";
}

//______________________________________________________________________________
const char *TKDTreeBinning::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TKDTreeBinning*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TKDTreeBinning::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TKDTreeBinning*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TKDTreeBinning::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TKDTreeBinning*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TKDTreeBinning::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TKDTreeBinning*)0x0)->GetClass();
   return fgIsA;
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::vector<double,allocator<double> >::iterator : new ::vector<double,allocator<double> >::iterator;
   }
   static void *newArray_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::vector<double,allocator<double> >::iterator[nElements] : new ::vector<double,allocator<double> >::iterator[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p) {
      delete ((::vector<double,allocator<double> >::iterator*)p);
   }
   static void deleteArray_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p) {
      delete [] ((::vector<double,allocator<double> >::iterator*)p);
   }
   static void destruct_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p) {
      typedef ::vector<double,allocator<double> >::iterator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::vector<double,allocator<double> >::iterator

namespace ROOT {
   // Wrappers around operator new
   static void *new_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::reverse_iterator<vector<double,allocator<double> >::iterator> : new ::reverse_iterator<vector<double,allocator<double> >::iterator>;
   }
   static void *newArray_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::reverse_iterator<vector<double,allocator<double> >::iterator>[nElements] : new ::reverse_iterator<vector<double,allocator<double> >::iterator>[nElements];
   }
   // Wrapper around operator delete
   static void delete_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p) {
      delete ((::reverse_iterator<vector<double,allocator<double> >::iterator>*)p);
   }
   static void deleteArray_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p) {
      delete [] ((::reverse_iterator<vector<double,allocator<double> >::iterator>*)p);
   }
   static void destruct_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p) {
      typedef ::reverse_iterator<vector<double,allocator<double> >::iterator> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::reverse_iterator<vector<double,allocator<double> >::iterator>

//______________________________________________________________________________
void TRandom::Streamer(TBuffer &R__b)
{
   // Stream an object of class TRandom.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TRandom::Class(),this);
   } else {
      R__b.WriteClassBuffer(TRandom::Class(),this);
   }
}

//______________________________________________________________________________
void TRandom::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class TRandom.
      TClass *R__cl = ::TRandom::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSeed", &fSeed);
      TNamed::ShowMembers(R__insp);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRandom(void *p) {
      return  p ? new(p) ::TRandom : new ::TRandom;
   }
   static void *newArray_TRandom(Long_t nElements, void *p) {
      return p ? new(p) ::TRandom[nElements] : new ::TRandom[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRandom(void *p) {
      delete ((::TRandom*)p);
   }
   static void deleteArray_TRandom(void *p) {
      delete [] ((::TRandom*)p);
   }
   static void destruct_TRandom(void *p) {
      typedef ::TRandom current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TRandom

//______________________________________________________________________________
void TRandom1::Streamer(TBuffer &R__b)
{
   // Stream an object of class TRandom1.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TRandom1::Class(),this);
   } else {
      R__b.WriteClassBuffer(TRandom1::Class(),this);
   }
}

//______________________________________________________________________________
void TRandom1::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class TRandom1.
      TClass *R__cl = ::TRandom1::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNskip", &fNskip);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fLuxury", &fLuxury);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fIlag", &fIlag);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fJlag", &fJlag);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCount24", &fCount24);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fFloatSeedTable[24]", fFloatSeedTable);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCarry", &fCarry);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fIntModulus", &fIntModulus);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fTheSeeds", &fTheSeeds);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMantissaBit24", &fMantissaBit24);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMantissaBit12", &fMantissaBit12);
      TRandom::ShowMembers(R__insp);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRandom1(void *p) {
      return  p ? new(p) ::TRandom1 : new ::TRandom1;
   }
   static void *newArray_TRandom1(Long_t nElements, void *p) {
      return p ? new(p) ::TRandom1[nElements] : new ::TRandom1[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRandom1(void *p) {
      delete ((::TRandom1*)p);
   }
   static void deleteArray_TRandom1(void *p) {
      delete [] ((::TRandom1*)p);
   }
   static void destruct_TRandom1(void *p) {
      typedef ::TRandom1 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TRandom1

//______________________________________________________________________________
void TRandom2::Streamer(TBuffer &R__b)
{
   // Stream an object of class TRandom2.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TRandom2::Class(),this);
   } else {
      R__b.WriteClassBuffer(TRandom2::Class(),this);
   }
}

//______________________________________________________________________________
void TRandom2::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class TRandom2.
      TClass *R__cl = ::TRandom2::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSeed1", &fSeed1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSeed2", &fSeed2);
      TRandom::ShowMembers(R__insp);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRandom2(void *p) {
      return  p ? new(p) ::TRandom2 : new ::TRandom2;
   }
   static void *newArray_TRandom2(Long_t nElements, void *p) {
      return p ? new(p) ::TRandom2[nElements] : new ::TRandom2[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRandom2(void *p) {
      delete ((::TRandom2*)p);
   }
   static void deleteArray_TRandom2(void *p) {
      delete [] ((::TRandom2*)p);
   }
   static void destruct_TRandom2(void *p) {
      typedef ::TRandom2 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TRandom2

//______________________________________________________________________________
void TRandom3::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class TRandom3.
      TClass *R__cl = ::TRandom3::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMt[624]", fMt);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCount624", &fCount624);
      TRandom::ShowMembers(R__insp);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRandom3(void *p) {
      return  p ? new(p) ::TRandom3 : new ::TRandom3;
   }
   static void *newArray_TRandom3(Long_t nElements, void *p) {
      return p ? new(p) ::TRandom3[nElements] : new ::TRandom3[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRandom3(void *p) {
      delete ((::TRandom3*)p);
   }
   static void deleteArray_TRandom3(void *p) {
      delete [] ((::TRandom3*)p);
   }
   static void destruct_TRandom3(void *p) {
      typedef ::TRandom3 current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TRandom3(TBuffer &buf, void *obj) {
      ((::TRandom3*)obj)->::TRandom3::Streamer(buf);
   }
} // end of namespace ROOT for class ::TRandom3

//______________________________________________________________________________
void TVirtualFitter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualFitter.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TVirtualFitter::Class(),this);
   } else {
      R__b.WriteClassBuffer(TVirtualFitter::Class(),this);
   }
}

//______________________________________________________________________________
void TVirtualFitter::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class TVirtualFitter.
      TClass *R__cl = ::TVirtualFitter::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fOption", (void*)&fOption);
      R__insp.InspectMember("Foption_t", (void*)&fOption, "fOption.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fXfirst", &fXfirst);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fXlast", &fXlast);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fYfirst", &fYfirst);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fYlast", &fYlast);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fZfirst", &fZfirst);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fZlast", &fZlast);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNpoints", &fNpoints);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fPointSize", &fPointSize);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCacheSize", &fCacheSize);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fCache", &fCache);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fObjectFit", &fObjectFit);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fUserFunc", &fUserFunc);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fMethodCall", &fMethodCall);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fFCN", &fFCN);
      TNamed::ShowMembers(R__insp);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualFitter(void *p) {
      delete ((::TVirtualFitter*)p);
   }
   static void deleteArray_TVirtualFitter(void *p) {
      delete [] ((::TVirtualFitter*)p);
   }
   static void destruct_TVirtualFitter(void *p) {
      typedef ::TVirtualFitter current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TVirtualFitter

//______________________________________________________________________________
template <> void TKDTree<int,double>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TKDTree<int,double>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TKDTree<int,double>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TKDTree<int,double>::Class(),this);
   }
}

//______________________________________________________________________________
namespace ROOT {
   void TKDTreelEintcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TKDTree<int,double>.
      typedef ::ROOT::Shadow::TKDTreelEintcOdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,double>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fDataOwner", &sobj->fDataOwner);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNNodes", &sobj->fNNodes);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fTotalNodes", &sobj->fTotalNodes);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNDim", &sobj->fNDim);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNDimm", &sobj->fNDimm);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNPoints", &sobj->fNPoints);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fBucketSize", &sobj->fBucketSize);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fAxis", &sobj->fAxis);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fValue", &sobj->fValue);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fRange", &sobj->fRange);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fData", &sobj->fData);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fBoundaries", &sobj->fBoundaries);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fIndPoints", &sobj->fIndPoints);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRowT0", &sobj->fRowT0);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCrossNode", &sobj->fCrossNode);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fOffset", &sobj->fOffset);
      sobj->TObject::ShowMembers(R__insp);
   }

}

template <> void TKDTree<int,double>::ShowMembers(TMemberInspector &R__insp)
{
   ::ROOT::TKDTreelEintcOdoublegR_ShowMembers(this, R__insp);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TKDTreelEintcOdoublegR(void *p) {
      return  p ? new(p) ::TKDTree<int,double> : new ::TKDTree<int,double>;
   }
   static void *newArray_TKDTreelEintcOdoublegR(Long_t nElements, void *p) {
      return p ? new(p) ::TKDTree<int,double>[nElements] : new ::TKDTree<int,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TKDTreelEintcOdoublegR(void *p) {
      delete ((::TKDTree<int,double>*)p);
   }
   static void deleteArray_TKDTreelEintcOdoublegR(void *p) {
      delete [] ((::TKDTree<int,double>*)p);
   }
   static void destruct_TKDTreelEintcOdoublegR(void *p) {
      typedef ::TKDTree<int,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TKDTree<int,double>

//______________________________________________________________________________
template <> void TKDTree<int,float>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TKDTree<int,float>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TKDTree<int,float>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TKDTree<int,float>::Class(),this);
   }
}

//______________________________________________________________________________
namespace ROOT {
   void TKDTreelEintcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TKDTree<int,float>.
      typedef ::ROOT::Shadow::TKDTreelEintcOfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,float>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fDataOwner", &sobj->fDataOwner);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNNodes", &sobj->fNNodes);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fTotalNodes", &sobj->fTotalNodes);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNDim", &sobj->fNDim);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNDimm", &sobj->fNDimm);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNPoints", &sobj->fNPoints);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fBucketSize", &sobj->fBucketSize);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fAxis", &sobj->fAxis);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fValue", &sobj->fValue);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fRange", &sobj->fRange);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fData", &sobj->fData);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fBoundaries", &sobj->fBoundaries);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fIndPoints", &sobj->fIndPoints);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRowT0", &sobj->fRowT0);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCrossNode", &sobj->fCrossNode);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fOffset", &sobj->fOffset);
      sobj->TObject::ShowMembers(R__insp);
   }

}

template <> void TKDTree<int,float>::ShowMembers(TMemberInspector &R__insp)
{
   ::ROOT::TKDTreelEintcOfloatgR_ShowMembers(this, R__insp);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TKDTreelEintcOfloatgR(void *p) {
      return  p ? new(p) ::TKDTree<int,float> : new ::TKDTree<int,float>;
   }
   static void *newArray_TKDTreelEintcOfloatgR(Long_t nElements, void *p) {
      return p ? new(p) ::TKDTree<int,float>[nElements] : new ::TKDTree<int,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TKDTreelEintcOfloatgR(void *p) {
      delete ((::TKDTree<int,float>*)p);
   }
   static void deleteArray_TKDTreelEintcOfloatgR(void *p) {
      delete [] ((::TKDTree<int,float>*)p);
   }
   static void destruct_TKDTreelEintcOfloatgR(void *p) {
      typedef ::TKDTree<int,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TKDTree<int,float>

//______________________________________________________________________________
void TKDTreeBinning::Streamer(TBuffer &R__b)
{
   // Stream an object of class TKDTreeBinning.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TKDTreeBinning::Class(),this);
   } else {
      R__b.WriteClassBuffer(TKDTreeBinning::Class(),this);
   }
}

//______________________________________________________________________________
void TKDTreeBinning::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class TKDTreeBinning.
      TClass *R__cl = ::TKDTreeBinning::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fData", &fData);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fBinMinEdges", (void*)&fBinMinEdges);
      R__insp.InspectMember("vector<Double_t>", (void*)&fBinMinEdges, "fBinMinEdges.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fBinMaxEdges", (void*)&fBinMaxEdges);
      R__insp.InspectMember("vector<Double_t>", (void*)&fBinMaxEdges, "fBinMaxEdges.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fDataBins", &fDataBins);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNBins", &fNBins);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fDim", &fDim);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fDataSize", &fDataSize);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fDataThresholds", (void*)&fDataThresholds);
      R__insp.InspectMember("vector<std::pair<Double_t,Double_t> >", (void*)&fDataThresholds, "fDataThresholds.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCheckedBinEdges", (void*)&fCheckedBinEdges);
      R__insp.InspectMember("vector<std::vector<std::pair<Bool_t,Bool_t> > >", (void*)&fCheckedBinEdges, "fCheckedBinEdges.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCommonBinEdges", (void*)&fCommonBinEdges);
      R__insp.InspectMember("vector<std::map<Double_t,std::vector<UInt_t> > >", (void*)&fCommonBinEdges, "fCommonBinEdges.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fIsSorted", &fIsSorted);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fIsSortedAsc", &fIsSortedAsc);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fBinsContent", (void*)&fBinsContent);
      R__insp.InspectMember("vector<UInt_t>", (void*)&fBinsContent, "fBinsContent.", false);
      TObject::ShowMembers(R__insp);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TKDTreeBinning(void *p) {
      delete ((::TKDTreeBinning*)p);
   }
   static void deleteArray_TKDTreeBinning(void *p) {
      delete [] ((::TKDTreeBinning*)p);
   }
   static void destruct_TKDTreeBinning(void *p) {
      typedef ::TKDTreeBinning current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TKDTreeBinning

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIBaseFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IBaseFunctionOneDim.
      typedef ::ROOT::Shadow::ROOT::Math::IBaseFunctionOneDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IBaseFunctionOneDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIBaseFunctionOneDim(void *p) {
      delete ((::ROOT::Math::IBaseFunctionOneDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIBaseFunctionOneDim(void *p) {
      delete [] ((::ROOT::Math::IBaseFunctionOneDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIBaseFunctionOneDim(void *p) {
      typedef ::ROOT::Math::IBaseFunctionOneDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IBaseFunctionOneDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIGradientOneDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IGradientOneDim.
      typedef ::ROOT::Shadow::ROOT::Math::IGradientOneDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientOneDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIGradientOneDim(void *p) {
      delete ((::ROOT::Math::IGradientOneDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIGradientOneDim(void *p) {
      delete [] ((::ROOT::Math::IGradientOneDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIGradientOneDim(void *p) {
      typedef ::ROOT::Math::IGradientOneDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IGradientOneDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIGradientFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IGradientFunctionOneDim.
      typedef ::ROOT::Shadow::ROOT::Math::IGradientFunctionOneDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientFunctionOneDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::IBaseFunctionOneDim", ( ::ROOT::Math::IBaseFunctionOneDim * )( (::ROOT::Math::IGradientFunctionOneDim*) obj ), false);
      R__insp.GenericShowMembers("ROOT::Math::IGradientOneDim", ( ::ROOT::Math::IGradientOneDim * )( (::ROOT::Math::IGradientFunctionOneDim*) obj ), false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIGradientFunctionOneDim(void *p) {
      delete ((::ROOT::Math::IGradientFunctionOneDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIGradientFunctionOneDim(void *p) {
      delete [] ((::ROOT::Math::IGradientFunctionOneDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIGradientFunctionOneDim(void *p) {
      typedef ::ROOT::Math::IGradientFunctionOneDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IGradientFunctionOneDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIBaseParam_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IBaseParam.
      typedef ::ROOT::Shadow::ROOT::Math::IBaseParam ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IBaseParam*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIBaseParam(void *p) {
      delete ((::ROOT::Math::IBaseParam*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIBaseParam(void *p) {
      delete [] ((::ROOT::Math::IBaseParam*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIBaseParam(void *p) {
      typedef ::ROOT::Math::IBaseParam current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IBaseParam

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIParametricFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IParametricFunctionOneDim.
      typedef ::ROOT::Shadow::ROOT::Math::IParametricFunctionOneDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricFunctionOneDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::IBaseFunctionOneDim", ( ::ROOT::Math::IBaseFunctionOneDim * )( (::ROOT::Math::IParametricFunctionOneDim*) obj ), false);
      R__insp.GenericShowMembers("ROOT::Math::IBaseParam", ( ::ROOT::Math::IBaseParam * )( (::ROOT::Math::IParametricFunctionOneDim*) obj ), false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIParametricFunctionOneDim(void *p) {
      delete ((::ROOT::Math::IParametricFunctionOneDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIParametricFunctionOneDim(void *p) {
      delete [] ((::ROOT::Math::IParametricFunctionOneDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIParametricFunctionOneDim(void *p) {
      typedef ::ROOT::Math::IParametricFunctionOneDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IParametricFunctionOneDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIParametricGradFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IParametricGradFunctionOneDim.
      typedef ::ROOT::Shadow::ROOT::Math::IParametricGradFunctionOneDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricGradFunctionOneDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::IParametricFunctionOneDim", ( ::ROOT::Math::IParametricFunctionOneDim * )( (::ROOT::Math::IParametricGradFunctionOneDim*) obj ), false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIParametricGradFunctionOneDim(void *p) {
      delete ((::ROOT::Math::IParametricGradFunctionOneDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIParametricGradFunctionOneDim(void *p) {
      delete [] ((::ROOT::Math::IParametricGradFunctionOneDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIParametricGradFunctionOneDim(void *p) {
      typedef ::ROOT::Math::IParametricGradFunctionOneDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IParametricGradFunctionOneDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIBaseFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IBaseFunctionMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::IBaseFunctionMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IBaseFunctionMultiDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIBaseFunctionMultiDim(void *p) {
      delete ((::ROOT::Math::IBaseFunctionMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIBaseFunctionMultiDim(void *p) {
      delete [] ((::ROOT::Math::IBaseFunctionMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIBaseFunctionMultiDim(void *p) {
      typedef ::ROOT::Math::IBaseFunctionMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IBaseFunctionMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIGradientMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IGradientMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::IGradientMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientMultiDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIGradientMultiDim(void *p) {
      delete ((::ROOT::Math::IGradientMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIGradientMultiDim(void *p) {
      delete [] ((::ROOT::Math::IGradientMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIGradientMultiDim(void *p) {
      typedef ::ROOT::Math::IGradientMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IGradientMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIGradientFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IGradientFunctionMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::IGradientFunctionMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientFunctionMultiDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::IBaseFunctionMultiDim", ( ::ROOT::Math::IBaseFunctionMultiDim * )( (::ROOT::Math::IGradientFunctionMultiDim*) obj ), false);
      R__insp.GenericShowMembers("ROOT::Math::IGradientMultiDim", ( ::ROOT::Math::IGradientMultiDim * )( (::ROOT::Math::IGradientFunctionMultiDim*) obj ), false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIGradientFunctionMultiDim(void *p) {
      delete ((::ROOT::Math::IGradientFunctionMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIGradientFunctionMultiDim(void *p) {
      delete [] ((::ROOT::Math::IGradientFunctionMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIGradientFunctionMultiDim(void *p) {
      typedef ::ROOT::Math::IGradientFunctionMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IGradientFunctionMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIParametricFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IParametricFunctionMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::IParametricFunctionMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricFunctionMultiDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::IBaseFunctionMultiDim", ( ::ROOT::Math::IBaseFunctionMultiDim * )( (::ROOT::Math::IParametricFunctionMultiDim*) obj ), false);
      R__insp.GenericShowMembers("ROOT::Math::IBaseParam", ( ::ROOT::Math::IBaseParam * )( (::ROOT::Math::IParametricFunctionMultiDim*) obj ), false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIParametricFunctionMultiDim(void *p) {
      delete ((::ROOT::Math::IParametricFunctionMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIParametricFunctionMultiDim(void *p) {
      delete [] ((::ROOT::Math::IParametricFunctionMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIParametricFunctionMultiDim(void *p) {
      typedef ::ROOT::Math::IParametricFunctionMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IParametricFunctionMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IParametricGradFunctionMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::IParametricGradFunctionMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricGradFunctionMultiDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::IParametricFunctionMultiDim", ( ::ROOT::Math::IParametricFunctionMultiDim * )( (::ROOT::Math::IParametricGradFunctionMultiDim*) obj ), false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void *p) {
      delete ((::ROOT::Math::IParametricGradFunctionMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void *p) {
      delete [] ((::ROOT::Math::IParametricGradFunctionMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void *p) {
      typedef ::ROOT::Math::IParametricGradFunctionMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IParametricGradFunctionMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLParamFunctor_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::ParamFunctor.
      typedef ::ROOT::Shadow::ROOT::Math::ParamFunctor ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::ParamFunctor*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fImpl", &sobj->fImpl);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLParamFunctor(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::ParamFunctor : new ::ROOT::Math::ParamFunctor;
   }
   static void *newArray_ROOTcLcLMathcLcLParamFunctor(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::ParamFunctor[nElements] : new ::ROOT::Math::ParamFunctor[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLParamFunctor(void *p) {
      delete ((::ROOT::Math::ParamFunctor*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLParamFunctor(void *p) {
      delete [] ((::ROOT::Math::ParamFunctor*)p);
   }
   static void destruct_ROOTcLcLMathcLcLParamFunctor(void *p) {
      typedef ::ROOT::Math::ParamFunctor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::ParamFunctor

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLFunctor(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Functor : new ::ROOT::Math::Functor;
   }
   static void *newArray_ROOTcLcLMathcLcLFunctor(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Functor[nElements] : new ::ROOT::Math::Functor[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLFunctor(void *p) {
      delete ((::ROOT::Math::Functor*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLFunctor(void *p) {
      delete [] ((::ROOT::Math::Functor*)p);
   }
   static void destruct_ROOTcLcLMathcLcLFunctor(void *p) {
      typedef ::ROOT::Math::Functor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Functor

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGradFunctor(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GradFunctor : new ::ROOT::Math::GradFunctor;
   }
   static void *newArray_ROOTcLcLMathcLcLGradFunctor(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GradFunctor[nElements] : new ::ROOT::Math::GradFunctor[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGradFunctor(void *p) {
      delete ((::ROOT::Math::GradFunctor*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGradFunctor(void *p) {
      delete [] ((::ROOT::Math::GradFunctor*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGradFunctor(void *p) {
      typedef ::ROOT::Math::GradFunctor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GradFunctor

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLFunctor1D(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Functor1D( (TRootIOCtor*)0 ) : new ::ROOT::Math::Functor1D( (TRootIOCtor*)0 );
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLFunctor1D(void *p) {
      delete ((::ROOT::Math::Functor1D*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLFunctor1D(void *p) {
      delete [] ((::ROOT::Math::Functor1D*)p);
   }
   static void destruct_ROOTcLcLMathcLcLFunctor1D(void *p) {
      typedef ::ROOT::Math::Functor1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Functor1D

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGradFunctor1D(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GradFunctor1D( (TRootIOCtor*)0 ) : new ::ROOT::Math::GradFunctor1D( (TRootIOCtor*)0 );
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGradFunctor1D(void *p) {
      delete ((::ROOT::Math::GradFunctor1D*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGradFunctor1D(void *p) {
      delete [] ((::ROOT::Math::GradFunctor1D*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGradFunctor1D(void *p) {
      typedef ::ROOT::Math::GradFunctor1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GradFunctor1D

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLMinimizer_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Minimizer.
      typedef ::ROOT::Shadow::ROOT::Math::Minimizer ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Minimizer*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fValidError", &sobj->fValidError);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fDebug", &sobj->fDebug);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fStrategy", &sobj->fStrategy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fStatus", &sobj->fStatus);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMaxCalls", &sobj->fMaxCalls);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMaxIter", &sobj->fMaxIter);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fTol", &sobj->fTol);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fPrec", &sobj->fPrec);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fUp", &sobj->fUp);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLMinimizer(void *p) {
      delete ((::ROOT::Math::Minimizer*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLMinimizer(void *p) {
      delete [] ((::ROOT::Math::Minimizer*)p);
   }
   static void destruct_ROOTcLcLMathcLcLMinimizer(void *p) {
      typedef ::ROOT::Math::Minimizer current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Minimizer

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLMinimizerOptions_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::MinimizerOptions.
      typedef ::ROOT::Shadow::ROOT::Math::MinimizerOptions ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::MinimizerOptions*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fLevel", &sobj->fLevel);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMaxCalls", &sobj->fMaxCalls);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMaxIter", &sobj->fMaxIter);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fStrategy", &sobj->fStrategy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fErrorDef", &sobj->fErrorDef);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fTolerance", &sobj->fTolerance);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fPrecision", &sobj->fPrecision);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMinimType", (void*)&sobj->fMinimType);
      R__insp.InspectMember("string", (void*)&sobj->fMinimType, "fMinimType.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fAlgoType", (void*)&sobj->fAlgoType);
      R__insp.InspectMember("string", (void*)&sobj->fAlgoType, "fAlgoType.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fExtraOptions", &sobj->fExtraOptions);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLMinimizerOptions(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::MinimizerOptions : new ::ROOT::Math::MinimizerOptions;
   }
   static void *newArray_ROOTcLcLMathcLcLMinimizerOptions(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::MinimizerOptions[nElements] : new ::ROOT::Math::MinimizerOptions[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLMinimizerOptions(void *p) {
      delete ((::ROOT::Math::MinimizerOptions*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLMinimizerOptions(void *p) {
      delete [] ((::ROOT::Math::MinimizerOptions*)p);
   }
   static void destruct_ROOTcLcLMathcLcLMinimizerOptions(void *p) {
      typedef ::ROOT::Math::MinimizerOptions current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::MinimizerOptions

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIntegratorOneDimOptions_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IntegratorOneDimOptions.
      typedef ::ROOT::Shadow::ROOT::Math::IntegratorOneDimOptions ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorOneDimOptions*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::BaseIntegratorOptions", ( ::ROOT::Math::BaseIntegratorOptions * )( (::ROOT::Math::IntegratorOneDimOptions*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLIntegratorOneDimOptions(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::IntegratorOneDimOptions : new ::ROOT::Math::IntegratorOneDimOptions;
   }
   static void *newArray_ROOTcLcLMathcLcLIntegratorOneDimOptions(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::IntegratorOneDimOptions[nElements] : new ::ROOT::Math::IntegratorOneDimOptions[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIntegratorOneDimOptions(void *p) {
      delete ((::ROOT::Math::IntegratorOneDimOptions*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIntegratorOneDimOptions(void *p) {
      delete [] ((::ROOT::Math::IntegratorOneDimOptions*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIntegratorOneDimOptions(void *p) {
      typedef ::ROOT::Math::IntegratorOneDimOptions current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IntegratorOneDimOptions

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIntegratorMultiDimOptions_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IntegratorMultiDimOptions.
      typedef ::ROOT::Shadow::ROOT::Math::IntegratorMultiDimOptions ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorMultiDimOptions*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::BaseIntegratorOptions", ( ::ROOT::Math::BaseIntegratorOptions * )( (::ROOT::Math::IntegratorMultiDimOptions*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLIntegratorMultiDimOptions(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::IntegratorMultiDimOptions : new ::ROOT::Math::IntegratorMultiDimOptions;
   }
   static void *newArray_ROOTcLcLMathcLcLIntegratorMultiDimOptions(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::IntegratorMultiDimOptions[nElements] : new ::ROOT::Math::IntegratorMultiDimOptions[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIntegratorMultiDimOptions(void *p) {
      delete ((::ROOT::Math::IntegratorMultiDimOptions*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIntegratorMultiDimOptions(void *p) {
      delete [] ((::ROOT::Math::IntegratorMultiDimOptions*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIntegratorMultiDimOptions(void *p) {
      typedef ::ROOT::Math::IntegratorMultiDimOptions current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IntegratorMultiDimOptions

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLBaseIntegratorOptions_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::BaseIntegratorOptions.
      typedef ::ROOT::Shadow::ROOT::Math::BaseIntegratorOptions ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BaseIntegratorOptions*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fIntegType", &sobj->fIntegType);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fWKSize", &sobj->fWKSize);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNCalls", &sobj->fNCalls);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fAbsTolerance", &sobj->fAbsTolerance);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRelTolerance", &sobj->fRelTolerance);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fExtraOptions", &sobj->fExtraOptions);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLBaseIntegratorOptions(void *p) {
      delete ((::ROOT::Math::BaseIntegratorOptions*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLBaseIntegratorOptions(void *p) {
      delete [] ((::ROOT::Math::BaseIntegratorOptions*)p);
   }
   static void destruct_ROOTcLcLMathcLcLBaseIntegratorOptions(void *p) {
      typedef ::ROOT::Math::BaseIntegratorOptions current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::BaseIntegratorOptions

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIOptions_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IOptions.
      typedef ::ROOT::Shadow::ROOT::Math::IOptions ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IOptions*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIOptions(void *p) {
      delete ((::ROOT::Math::IOptions*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIOptions(void *p) {
      delete [] ((::ROOT::Math::IOptions*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIOptions(void *p) {
      typedef ::ROOT::Math::IOptions current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IOptions

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIntegratorOneDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IntegratorOneDim.
      typedef ::ROOT::Shadow::ROOT::Math::IntegratorOneDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorOneDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fIntegrator", &sobj->fIntegrator);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fFunc", (void*)&sobj->fFunc);
      R__insp.InspectMember("auto_ptr<ROOT::Math::IBaseFunctionOneDim>", (void*)&sobj->fFunc, "fFunc.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLIntegratorOneDim(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::IntegratorOneDim : new ::ROOT::Math::IntegratorOneDim;
   }
   static void *newArray_ROOTcLcLMathcLcLIntegratorOneDim(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::IntegratorOneDim[nElements] : new ::ROOT::Math::IntegratorOneDim[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIntegratorOneDim(void *p) {
      delete ((::ROOT::Math::IntegratorOneDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIntegratorOneDim(void *p) {
      delete [] ((::ROOT::Math::IntegratorOneDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIntegratorOneDim(void *p) {
      typedef ::ROOT::Math::IntegratorOneDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IntegratorOneDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIntegratorMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IntegratorMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::IntegratorMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorMultiDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fIntegrator", &sobj->fIntegrator);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fFunc", (void*)&sobj->fFunc);
      R__insp.InspectMember("auto_ptr<ROOT::Math::IBaseFunctionMultiDim>", (void*)&sobj->fFunc, "fFunc.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLIntegratorMultiDim(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::IntegratorMultiDim : new ::ROOT::Math::IntegratorMultiDim;
   }
   static void *newArray_ROOTcLcLMathcLcLIntegratorMultiDim(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::IntegratorMultiDim[nElements] : new ::ROOT::Math::IntegratorMultiDim[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIntegratorMultiDim(void *p) {
      delete ((::ROOT::Math::IntegratorMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIntegratorMultiDim(void *p) {
      delete [] ((::ROOT::Math::IntegratorMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIntegratorMultiDim(void *p) {
      typedef ::ROOT::Math::IntegratorMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IntegratorMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLVirtualIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::VirtualIntegrator.
      typedef ::ROOT::Shadow::ROOT::Math::VirtualIntegrator ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegrator*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLVirtualIntegrator(void *p) {
      delete ((::ROOT::Math::VirtualIntegrator*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLVirtualIntegrator(void *p) {
      delete [] ((::ROOT::Math::VirtualIntegrator*)p);
   }
   static void destruct_ROOTcLcLMathcLcLVirtualIntegrator(void *p) {
      typedef ::ROOT::Math::VirtualIntegrator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::VirtualIntegrator

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLVirtualIntegratorOneDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::VirtualIntegratorOneDim.
      typedef ::ROOT::Shadow::ROOT::Math::VirtualIntegratorOneDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegratorOneDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::VirtualIntegrator", ( ::ROOT::Math::VirtualIntegrator * )( (::ROOT::Math::VirtualIntegratorOneDim*) obj ), false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLVirtualIntegratorOneDim(void *p) {
      delete ((::ROOT::Math::VirtualIntegratorOneDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLVirtualIntegratorOneDim(void *p) {
      delete [] ((::ROOT::Math::VirtualIntegratorOneDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLVirtualIntegratorOneDim(void *p) {
      typedef ::ROOT::Math::VirtualIntegratorOneDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::VirtualIntegratorOneDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLVirtualIntegratorMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::VirtualIntegratorMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::VirtualIntegratorMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegratorMultiDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::VirtualIntegrator", ( ::ROOT::Math::VirtualIntegrator * )( (::ROOT::Math::VirtualIntegratorMultiDim*) obj ), false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLVirtualIntegratorMultiDim(void *p) {
      delete ((::ROOT::Math::VirtualIntegratorMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLVirtualIntegratorMultiDim(void *p) {
      delete [] ((::ROOT::Math::VirtualIntegratorMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLVirtualIntegratorMultiDim(void *p) {
      typedef ::ROOT::Math::VirtualIntegratorMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::VirtualIntegratorMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::AdaptiveIntegratorMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::AdaptiveIntegratorMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::AdaptiveIntegratorMultiDim*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fDim", &sobj->fDim);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMinPts", &sobj->fMinPts);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMaxPts", &sobj->fMaxPts);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSize", &sobj->fSize);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fAbsTol", &sobj->fAbsTol);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRelTol", &sobj->fRelTol);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fResult", &sobj->fResult);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fError", &sobj->fError);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRelError", &sobj->fRelError);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNEval", &sobj->fNEval);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fStatus", &sobj->fStatus);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFun", &sobj->fFun);
      R__insp.GenericShowMembers("ROOT::Math::VirtualIntegratorMultiDim", ( ::ROOT::Math::VirtualIntegratorMultiDim * )( (::ROOT::Math::AdaptiveIntegratorMultiDim*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::AdaptiveIntegratorMultiDim : new ::ROOT::Math::AdaptiveIntegratorMultiDim;
   }
   static void *newArray_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::AdaptiveIntegratorMultiDim[nElements] : new ::ROOT::Math::AdaptiveIntegratorMultiDim[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p) {
      delete ((::ROOT::Math::AdaptiveIntegratorMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p) {
      delete [] ((::ROOT::Math::AdaptiveIntegratorMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p) {
      typedef ::ROOT::Math::AdaptiveIntegratorMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::AdaptiveIntegratorMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>.
      typedef ::ROOT::Shadow::ROOT::Math::BasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNDim", &sobj->fNDim);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNPoints", &sobj->fNPoints);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNCalls", &sobj->fNCalls);
      R__insp.GenericShowMembers("ROOT::Math::IBaseFunctionMultiDim", ( ::ROOT::Math::IBaseFunctionMultiDim * )( (::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) obj ), false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void *p) {
      delete ((::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void *p) {
      delete [] ((::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void *p) {
      typedef ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>.
      typedef ::ROOT::Shadow::ROOT::Math::BasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNDim", &sobj->fNDim);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNPoints", &sobj->fNPoints);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNCalls", &sobj->fNCalls);
      R__insp.GenericShowMembers("ROOT::Math::IGradientFunctionMultiDim", ( ::ROOT::Math::IGradientFunctionMultiDim * )( (::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) obj ), false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void *p) {
      delete ((::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void *p) {
      delete [] ((::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void *p) {
      typedef ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLFactory_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Factory.
      typedef ::ROOT::Shadow::ROOT::Math::Factory ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Factory*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLFactory(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Factory : new ::ROOT::Math::Factory;
   }
   static void *newArray_ROOTcLcLMathcLcLFactory(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Factory[nElements] : new ::ROOT::Math::Factory[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLFactory(void *p) {
      delete ((::ROOT::Math::Factory*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLFactory(void *p) {
      delete [] ((::ROOT::Math::Factory*)p);
   }
   static void destruct_ROOTcLcLMathcLcLFactory(void *p) {
      typedef ::ROOT::Math::Factory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Factory

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGaussIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GaussIntegrator.
      typedef ::ROOT::Shadow::ROOT::Math::GaussIntegrator ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GaussIntegrator*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fEpsilon", &sobj->fEpsilon);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fUsedOnce", &sobj->fUsedOnce);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fLastResult", &sobj->fLastResult);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fLastError", &sobj->fLastError);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFunction", &sobj->fFunction);
      R__insp.GenericShowMembers("ROOT::Math::VirtualIntegratorOneDim", ( ::ROOT::Math::VirtualIntegratorOneDim * )( (::ROOT::Math::GaussIntegrator*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGaussIntegrator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GaussIntegrator : new ::ROOT::Math::GaussIntegrator;
   }
   static void *newArray_ROOTcLcLMathcLcLGaussIntegrator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GaussIntegrator[nElements] : new ::ROOT::Math::GaussIntegrator[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGaussIntegrator(void *p) {
      delete ((::ROOT::Math::GaussIntegrator*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGaussIntegrator(void *p) {
      delete [] ((::ROOT::Math::GaussIntegrator*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGaussIntegrator(void *p) {
      typedef ::ROOT::Math::GaussIntegrator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GaussIntegrator

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGaussLegendreIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GaussLegendreIntegrator.
      typedef ::ROOT::Shadow::ROOT::Math::GaussLegendreIntegrator ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GaussLegendreIntegrator*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNum", &sobj->fNum);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fX", &sobj->fX);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fW", &sobj->fW);
      R__insp.GenericShowMembers("ROOT::Math::GaussIntegrator", ( ::ROOT::Math::GaussIntegrator * )( (::ROOT::Math::GaussLegendreIntegrator*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GaussLegendreIntegrator : new ::ROOT::Math::GaussLegendreIntegrator;
   }
   static void *newArray_ROOTcLcLMathcLcLGaussLegendreIntegrator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GaussLegendreIntegrator[nElements] : new ::ROOT::Math::GaussLegendreIntegrator[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p) {
      delete ((::ROOT::Math::GaussLegendreIntegrator*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p) {
      delete [] ((::ROOT::Math::GaussLegendreIntegrator*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p) {
      typedef ::ROOT::Math::GaussLegendreIntegrator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GaussLegendreIntegrator

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRichardsonDerivator_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::RichardsonDerivator.
      typedef ::ROOT::Shadow::ROOT::Math::RichardsonDerivator ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::RichardsonDerivator*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fFunctionCopied", &sobj->fFunctionCopied);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fStepSize", &sobj->fStepSize);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fLastError", &sobj->fLastError);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFunction", &sobj->fFunction);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRichardsonDerivator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::RichardsonDerivator : new ::ROOT::Math::RichardsonDerivator;
   }
   static void *newArray_ROOTcLcLMathcLcLRichardsonDerivator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::RichardsonDerivator[nElements] : new ::ROOT::Math::RichardsonDerivator[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRichardsonDerivator(void *p) {
      delete ((::ROOT::Math::RichardsonDerivator*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRichardsonDerivator(void *p) {
      delete [] ((::ROOT::Math::RichardsonDerivator*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRichardsonDerivator(void *p) {
      typedef ::ROOT::Math::RichardsonDerivator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::RichardsonDerivator

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRootFinder_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::RootFinder.
      typedef ::ROOT::Shadow::ROOT::Math::RootFinder ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::RootFinder*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fSolver", &sobj->fSolver);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRootFinder(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::RootFinder : new ::ROOT::Math::RootFinder;
   }
   static void *newArray_ROOTcLcLMathcLcLRootFinder(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::RootFinder[nElements] : new ::ROOT::Math::RootFinder[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRootFinder(void *p) {
      delete ((::ROOT::Math::RootFinder*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRootFinder(void *p) {
      delete [] ((::ROOT::Math::RootFinder*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRootFinder(void *p) {
      typedef ::ROOT::Math::RootFinder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::RootFinder

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIRootFinderMethod_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IRootFinderMethod.
      typedef ::ROOT::Shadow::ROOT::Math::IRootFinderMethod ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IRootFinderMethod*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIRootFinderMethod(void *p) {
      delete ((::ROOT::Math::IRootFinderMethod*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIRootFinderMethod(void *p) {
      delete [] ((::ROOT::Math::IRootFinderMethod*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIRootFinderMethod(void *p) {
      typedef ::ROOT::Math::IRootFinderMethod current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IRootFinderMethod

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLBrentRootFinder_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::BrentRootFinder.
      typedef ::ROOT::Shadow::ROOT::Math::BrentRootFinder ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BrentRootFinder*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFunction", &sobj->fFunction);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fLogScan", &sobj->fLogScan);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNIter", &sobj->fNIter);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNpx", &sobj->fNpx);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fStatus", &sobj->fStatus);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fXMin", &sobj->fXMin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fXMax", &sobj->fXMax);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRoot", &sobj->fRoot);
      R__insp.GenericShowMembers("ROOT::Math::IRootFinderMethod", ( ::ROOT::Math::IRootFinderMethod * )( (::ROOT::Math::BrentRootFinder*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLBrentRootFinder(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::BrentRootFinder : new ::ROOT::Math::BrentRootFinder;
   }
   static void *newArray_ROOTcLcLMathcLcLBrentRootFinder(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::BrentRootFinder[nElements] : new ::ROOT::Math::BrentRootFinder[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLBrentRootFinder(void *p) {
      delete ((::ROOT::Math::BrentRootFinder*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLBrentRootFinder(void *p) {
      delete [] ((::ROOT::Math::BrentRootFinder*)p);
   }
   static void destruct_ROOTcLcLMathcLcLBrentRootFinder(void *p) {
      typedef ::ROOT::Math::BrentRootFinder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::BrentRootFinder

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIMinimizer1D_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::IMinimizer1D.
      typedef ::ROOT::Shadow::ROOT::Math::IMinimizer1D ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IMinimizer1D*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIMinimizer1D(void *p) {
      delete ((::ROOT::Math::IMinimizer1D*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIMinimizer1D(void *p) {
      delete [] ((::ROOT::Math::IMinimizer1D*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIMinimizer1D(void *p) {
      typedef ::ROOT::Math::IMinimizer1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IMinimizer1D

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLBrentMinimizer1D_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::BrentMinimizer1D.
      typedef ::ROOT::Shadow::ROOT::Math::BrentMinimizer1D ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BrentMinimizer1D*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFunction", &sobj->fFunction);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fLogScan", &sobj->fLogScan);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNIter", &sobj->fNIter);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNpx", &sobj->fNpx);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fStatus", &sobj->fStatus);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fXMin", &sobj->fXMin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fXMax", &sobj->fXMax);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fXMinimum", &sobj->fXMinimum);
      R__insp.GenericShowMembers("ROOT::Math::IMinimizer1D", ( ::ROOT::Math::IMinimizer1D * )( (::ROOT::Math::BrentMinimizer1D*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLBrentMinimizer1D(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::BrentMinimizer1D : new ::ROOT::Math::BrentMinimizer1D;
   }
   static void *newArray_ROOTcLcLMathcLcLBrentMinimizer1D(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::BrentMinimizer1D[nElements] : new ::ROOT::Math::BrentMinimizer1D[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLBrentMinimizer1D(void *p) {
      delete ((::ROOT::Math::BrentMinimizer1D*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLBrentMinimizer1D(void *p) {
      delete [] ((::ROOT::Math::BrentMinimizer1D*)p);
   }
   static void destruct_ROOTcLcLMathcLcLBrentMinimizer1D(void *p) {
      typedef ::ROOT::Math::BrentMinimizer1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::BrentMinimizer1D

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLDistSampler_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::DistSampler.
      typedef ::ROOT::Shadow::ROOT::Math::DistSampler ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::DistSampler*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fOwnFunc", &sobj->fOwnFunc);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fData", (void*)&sobj->fData);
      R__insp.InspectMember("vector<double>", (void*)&sobj->fData, "fData.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fRange", &sobj->fRange);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFunc", &sobj->fFunc);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLDistSampler(void *p) {
      delete ((::ROOT::Math::DistSampler*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLDistSampler(void *p) {
      delete [] ((::ROOT::Math::DistSampler*)p);
   }
   static void destruct_ROOTcLcLMathcLcLDistSampler(void *p) {
      typedef ::ROOT::Math::DistSampler current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::DistSampler

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLDistSamplerOptions_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::DistSamplerOptions.
      typedef ::ROOT::Shadow::ROOT::Math::DistSamplerOptions ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::DistSamplerOptions*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fLevel", &sobj->fLevel);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSamplerType", (void*)&sobj->fSamplerType);
      R__insp.InspectMember("string", (void*)&sobj->fSamplerType, "fSamplerType.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fAlgoType", (void*)&sobj->fAlgoType);
      R__insp.InspectMember("string", (void*)&sobj->fAlgoType, "fAlgoType.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fExtraOptions", &sobj->fExtraOptions);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLDistSamplerOptions(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::DistSamplerOptions : new ::ROOT::Math::DistSamplerOptions;
   }
   static void *newArray_ROOTcLcLMathcLcLDistSamplerOptions(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::DistSamplerOptions[nElements] : new ::ROOT::Math::DistSamplerOptions[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLDistSamplerOptions(void *p) {
      delete ((::ROOT::Math::DistSamplerOptions*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLDistSamplerOptions(void *p) {
      delete [] ((::ROOT::Math::DistSamplerOptions*)p);
   }
   static void destruct_ROOTcLcLMathcLcLDistSamplerOptions(void *p) {
      typedef ::ROOT::Math::DistSamplerOptions current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::DistSamplerOptions

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGoFTest_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GoFTest.
      typedef ::ROOT::Shadow::ROOT::Math::GoFTest ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GoFTest*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCDF", (void*)&sobj->fCDF);
      R__insp.InspectMember("auto_ptr<ROOT::Math::IBaseFunctionOneDim>", (void*)&sobj->fCDF, "fCDF.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fDist", &sobj->fDist);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMean", &sobj->fMean);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSigma", &sobj->fSigma);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCombinedSamples", (void*)&sobj->fCombinedSamples);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->fCombinedSamples, "fCombinedSamples.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSamples", (void*)&sobj->fSamples);
      R__insp.InspectMember("vector<std::vector<Double_t> >", (void*)&sobj->fSamples, "fSamples.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fTestSampleFromH0", &sobj->fTestSampleFromH0);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGoFTest(void *p) {
      delete ((::ROOT::Math::GoFTest*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGoFTest(void *p) {
      delete [] ((::ROOT::Math::GoFTest*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGoFTest(void *p) {
      typedef ::ROOT::Math::GoFTest current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GoFTest

namespace ROOT {
   void maplEdoublecOvectorlEunsignedsPintgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void maplEdoublecOvectorlEunsignedsPintgRsPgR_Dictionary();
   static void *new_maplEdoublecOvectorlEunsignedsPintgRsPgR(void *p = 0);
   static void *newArray_maplEdoublecOvectorlEunsignedsPintgRsPgR(Long_t size, void *p);
   static void delete_maplEdoublecOvectorlEunsignedsPintgRsPgR(void *p);
   static void deleteArray_maplEdoublecOvectorlEunsignedsPintgRsPgR(void *p);
   static void destruct_maplEdoublecOvectorlEunsignedsPintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<double,vector<unsigned int> >*)
   {
      map<double,vector<unsigned int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<double,vector<unsigned int> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("map<double,vector<unsigned int> >", -2, "prec_stl/map", 63,
                  typeid(map<double,vector<unsigned int> >), DefineBehavior(ptr, ptr),
                  0, &maplEdoublecOvectorlEunsignedsPintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(map<double,vector<unsigned int> >) );
      instance.SetNew(&new_maplEdoublecOvectorlEunsignedsPintgRsPgR);
      instance.SetNewArray(&newArray_maplEdoublecOvectorlEunsignedsPintgRsPgR);
      instance.SetDelete(&delete_maplEdoublecOvectorlEunsignedsPintgRsPgR);
      instance.SetDeleteArray(&deleteArray_maplEdoublecOvectorlEunsignedsPintgRsPgR);
      instance.SetDestructor(&destruct_maplEdoublecOvectorlEunsignedsPintgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<double,vector<unsigned int> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const map<double,vector<unsigned int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void maplEdoublecOvectorlEunsignedsPintgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const map<double,vector<unsigned int> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEdoublecOvectorlEunsignedsPintgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) map<double,vector<unsigned int> > : new map<double,vector<unsigned int> >;
   }
   static void *newArray_maplEdoublecOvectorlEunsignedsPintgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) map<double,vector<unsigned int> >[nElements] : new map<double,vector<unsigned int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEdoublecOvectorlEunsignedsPintgRsPgR(void *p) {
      delete ((map<double,vector<unsigned int> >*)p);
   }
   static void deleteArray_maplEdoublecOvectorlEunsignedsPintgRsPgR(void *p) {
      delete [] ((map<double,vector<unsigned int> >*)p);
   }
   static void destruct_maplEdoublecOvectorlEunsignedsPintgRsPgR(void *p) {
      typedef map<double,vector<unsigned int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<double,vector<unsigned int> >

namespace ROOT {
   void vectorlEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEdoublegR_Dictionary();
   static void *new_vectorlEdoublegR(void *p = 0);
   static void *newArray_vectorlEdoublegR(Long_t size, void *p);
   static void delete_vectorlEdoublegR(void *p);
   static void deleteArray_vectorlEdoublegR(void *p);
   static void destruct_vectorlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<double>*)
   {
      vector<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<double>", -2, "prec_stl/vector", 49,
                  typeid(vector<double>), DefineBehavior(ptr, ptr),
                  0, &vectorlEdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(vector<double>) );
      instance.SetNew(&new_vectorlEdoublegR);
      instance.SetNewArray(&newArray_vectorlEdoublegR);
      instance.SetDelete(&delete_vectorlEdoublegR);
      instance.SetDeleteArray(&deleteArray_vectorlEdoublegR);
      instance.SetDestructor(&destruct_vectorlEdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<double> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double> : new vector<double>;
   }
   static void *newArray_vectorlEdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double>[nElements] : new vector<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEdoublegR(void *p) {
      delete ((vector<double>*)p);
   }
   static void deleteArray_vectorlEdoublegR(void *p) {
      delete [] ((vector<double>*)p);
   }
   static void destruct_vectorlEdoublegR(void *p) {
      typedef vector<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<double>

namespace ROOT {
   void vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR_Dictionary();
   static void *new_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR(void *p);
   static void deleteArray_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR(void *p);
   static void destruct_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<map<double,vector<unsigned int> > >*)
   {
      vector<map<double,vector<unsigned int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<map<double,vector<unsigned int> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<map<double,vector<unsigned int> > >", -2, "prec_stl/vector", 49,
                  typeid(vector<map<double,vector<unsigned int> > >), DefineBehavior(ptr, ptr),
                  0, &vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<map<double,vector<unsigned int> > >) );
      instance.SetNew(&new_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<map<double,vector<unsigned int> > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<map<double,vector<unsigned int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<map<double,vector<unsigned int> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<map<double,vector<unsigned int> > > : new vector<map<double,vector<unsigned int> > >;
   }
   static void *newArray_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<map<double,vector<unsigned int> > >[nElements] : new vector<map<double,vector<unsigned int> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR(void *p) {
      delete ((vector<map<double,vector<unsigned int> > >*)p);
   }
   static void deleteArray_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR(void *p) {
      delete [] ((vector<map<double,vector<unsigned int> > >*)p);
   }
   static void destruct_vectorlEmaplEdoublecOvectorlEunsignedsPintgRsPgRsPgR(void *p) {
      typedef vector<map<double,vector<unsigned int> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<map<double,vector<unsigned int> > >

namespace ROOT {
   void vectorlEpairlEboolcOboolgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEpairlEboolcOboolgRsPgR_Dictionary();
   static void *new_vectorlEpairlEboolcOboolgRsPgR(void *p = 0);
   static void *newArray_vectorlEpairlEboolcOboolgRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEboolcOboolgRsPgR(void *p);
   static void deleteArray_vectorlEpairlEboolcOboolgRsPgR(void *p);
   static void destruct_vectorlEpairlEboolcOboolgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<bool,bool> >*)
   {
      vector<pair<bool,bool> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<bool,bool> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<bool,bool> >", -2, "prec_stl/vector", 49,
                  typeid(vector<pair<bool,bool> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEpairlEboolcOboolgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<pair<bool,bool> >) );
      instance.SetNew(&new_vectorlEpairlEboolcOboolgRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEboolcOboolgRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEboolcOboolgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEboolcOboolgRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEboolcOboolgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pair<bool,bool> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pair<bool,bool> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEpairlEboolcOboolgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<pair<bool,bool> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpairlEboolcOboolgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<bool,bool> > : new vector<pair<bool,bool> >;
   }
   static void *newArray_vectorlEpairlEboolcOboolgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<bool,bool> >[nElements] : new vector<pair<bool,bool> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEboolcOboolgRsPgR(void *p) {
      delete ((vector<pair<bool,bool> >*)p);
   }
   static void deleteArray_vectorlEpairlEboolcOboolgRsPgR(void *p) {
      delete [] ((vector<pair<bool,bool> >*)p);
   }
   static void destruct_vectorlEpairlEboolcOboolgRsPgR(void *p) {
      typedef vector<pair<bool,bool> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pair<bool,bool> >

namespace ROOT {
   void vectorlEpairlEdoublecOdoublegRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEpairlEdoublecOdoublegRsPgR_Dictionary();
   static void *new_vectorlEpairlEdoublecOdoublegRsPgR(void *p = 0);
   static void *newArray_vectorlEpairlEdoublecOdoublegRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEdoublecOdoublegRsPgR(void *p);
   static void deleteArray_vectorlEpairlEdoublecOdoublegRsPgR(void *p);
   static void destruct_vectorlEpairlEdoublecOdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<double,double> >*)
   {
      vector<pair<double,double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<double,double> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<double,double> >", -2, "prec_stl/vector", 49,
                  typeid(vector<pair<double,double> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEpairlEdoublecOdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<pair<double,double> >) );
      instance.SetNew(&new_vectorlEpairlEdoublecOdoublegRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEdoublecOdoublegRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEdoublecOdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEdoublecOdoublegRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEdoublecOdoublegRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pair<double,double> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pair<double,double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEpairlEdoublecOdoublegRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<pair<double,double> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpairlEdoublecOdoublegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<double,double> > : new vector<pair<double,double> >;
   }
   static void *newArray_vectorlEpairlEdoublecOdoublegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<double,double> >[nElements] : new vector<pair<double,double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEdoublecOdoublegRsPgR(void *p) {
      delete ((vector<pair<double,double> >*)p);
   }
   static void deleteArray_vectorlEpairlEdoublecOdoublegRsPgR(void *p) {
      delete [] ((vector<pair<double,double> >*)p);
   }
   static void destruct_vectorlEpairlEdoublecOdoublegRsPgR(void *p) {
      typedef vector<pair<double,double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pair<double,double> >

namespace ROOT {
   void vectorlEunsignedsPintgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEunsignedsPintgR_Dictionary();
   static void *new_vectorlEunsignedsPintgR(void *p = 0);
   static void *newArray_vectorlEunsignedsPintgR(Long_t size, void *p);
   static void delete_vectorlEunsignedsPintgR(void *p);
   static void deleteArray_vectorlEunsignedsPintgR(void *p);
   static void destruct_vectorlEunsignedsPintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<unsigned int>*)
   {
      vector<unsigned int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<unsigned int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<unsigned int>", -2, "prec_stl/vector", 49,
                  typeid(vector<unsigned int>), DefineBehavior(ptr, ptr),
                  0, &vectorlEunsignedsPintgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<unsigned int>) );
      instance.SetNew(&new_vectorlEunsignedsPintgR);
      instance.SetNewArray(&newArray_vectorlEunsignedsPintgR);
      instance.SetDelete(&delete_vectorlEunsignedsPintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEunsignedsPintgR);
      instance.SetDestructor(&destruct_vectorlEunsignedsPintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<unsigned int> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<unsigned int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEunsignedsPintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<unsigned int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEunsignedsPintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<unsigned int> : new vector<unsigned int>;
   }
   static void *newArray_vectorlEunsignedsPintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<unsigned int>[nElements] : new vector<unsigned int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEunsignedsPintgR(void *p) {
      delete ((vector<unsigned int>*)p);
   }
   static void deleteArray_vectorlEunsignedsPintgR(void *p) {
      delete [] ((vector<unsigned int>*)p);
   }
   static void destruct_vectorlEunsignedsPintgR(void *p) {
      typedef vector<unsigned int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<unsigned int>

namespace ROOT {
   void vectorlEvectorlEdoublegRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEdoublegRsPgR_Dictionary();
   static void *new_vectorlEvectorlEdoublegRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEdoublegRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEdoublegRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEdoublegRsPgR(void *p);
   static void destruct_vectorlEvectorlEdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<double> >*)
   {
      vector<vector<double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<double> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<double> >", -2, "prec_stl/vector", 49,
                  typeid(vector<vector<double> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<double> >) );
      instance.SetNew(&new_vectorlEvectorlEdoublegRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEdoublegRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEdoublegRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEdoublegRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<double> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEdoublegRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<vector<double> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEdoublegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<double> > : new vector<vector<double> >;
   }
   static void *newArray_vectorlEvectorlEdoublegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<double> >[nElements] : new vector<vector<double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEdoublegRsPgR(void *p) {
      delete ((vector<vector<double> >*)p);
   }
   static void deleteArray_vectorlEvectorlEdoublegRsPgR(void *p) {
      delete [] ((vector<vector<double> >*)p);
   }
   static void destruct_vectorlEvectorlEdoublegRsPgR(void *p) {
      typedef vector<vector<double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<double> >

namespace ROOT {
   void vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR_Dictionary();
   static void *new_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR(void *p);
   static void destruct_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<pair<bool,bool> > >*)
   {
      vector<vector<pair<bool,bool> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<pair<bool,bool> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<pair<bool,bool> > >", -2, "prec_stl/vector", 49,
                  typeid(vector<vector<pair<bool,bool> > >), DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<pair<bool,bool> > >) );
      instance.SetNew(&new_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<pair<bool,bool> > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<pair<bool,bool> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<vector<pair<bool,bool> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<pair<bool,bool> > > : new vector<vector<pair<bool,bool> > >;
   }
   static void *newArray_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<pair<bool,bool> > >[nElements] : new vector<vector<pair<bool,bool> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR(void *p) {
      delete ((vector<vector<pair<bool,bool> > >*)p);
   }
   static void deleteArray_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR(void *p) {
      delete [] ((vector<vector<pair<bool,bool> > >*)p);
   }
   static void destruct_vectorlEvectorlEpairlEboolcOboolgRsPgRsPgR(void *p) {
      typedef vector<vector<pair<bool,bool> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<pair<bool,bool> > >

/********************************************************
* math/mathcore/src/G__MathCore.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableG__MathCore();

extern "C" void G__set_cpp_environmentG__MathCore() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("TRandom.h");
  G__add_compiledheader("TRandom1.h");
  G__add_compiledheader("TRandom2.h");
  G__add_compiledheader("TRandom3.h");
  G__add_compiledheader("TVirtualFitter.h");
  G__add_compiledheader("TKDTree.h");
  G__add_compiledheader("TKDTreeBinning.h");
  G__add_compiledheader("Math/IParamFunction.h");
  G__add_compiledheader("Math/IFunction.h");
  G__add_compiledheader("Math/ParamFunctor.h");
  G__add_compiledheader("Math/Functor.h");
  G__add_compiledheader("Math/Minimizer.h");
  G__add_compiledheader("Math/MinimizerOptions.h");
  G__add_compiledheader("Math/IntegratorOptions.h");
  G__add_compiledheader("Math/IOptions.h");
  G__add_compiledheader("Math/Integrator.h");
  G__add_compiledheader("Math/VirtualIntegrator.h");
  G__add_compiledheader("Math/AllIntegrationTypes.h");
  G__add_compiledheader("Math/AdaptiveIntegratorMultiDim.h");
  G__add_compiledheader("Math/IntegratorMultiDim.h");
  G__add_compiledheader("Math/Factory.h");
  G__add_compiledheader("Math/FitMethodFunction.h");
  G__add_compiledheader("Math/GaussIntegrator.h");
  G__add_compiledheader("Math/GaussLegendreIntegrator.h");
  G__add_compiledheader("Math/RootFinder.h");
  G__add_compiledheader("Math/IRootFinderMethod.h");
  G__add_compiledheader("Math/RichardsonDerivator.h");
  G__add_compiledheader("Math/BrentMethods.h");
  G__add_compiledheader("Math/BrentMinimizer1D.h");
  G__add_compiledheader("Math/BrentRootFinder.h");
  G__add_compiledheader("Math/DistSampler.h");
  G__add_compiledheader("Math/DistSamplerOptions.h");
  G__add_compiledheader("Math/GoFTest.h");
  G__add_compiledheader("Math/SpecFuncMathCore.h");
  G__add_compiledheader("Math/DistFuncMathCore.h");
  G__cpp_reset_tagtableG__MathCore();
}
#include <new>
extern "C" int G__cpp_dllrevG__MathCore() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* ROOT */
static int G__G__MathCore_19_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::CreateClass(
(const char*) G__int(libp->para[0]), (Version_t) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref, (TVirtualIsAProxy*) G__int(libp->para[3])
, (ShowMembersFunc_t) G__int(libp->para[4]), (const char*) G__int(libp->para[5])
, (const char*) G__int(libp->para[6]), (Int_t) G__int(libp->para[7])
, (Int_t) G__int(libp->para[8])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_19_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::AddClass((const char*) G__int(libp->para[0]), (Version_t) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref, (VoidFuncPtr_t) G__int(libp->para[3])
, (Int_t) G__int(libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_19_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::RemoveClass((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_19_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::ResetClassVersion((TClass*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Short_t) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_19_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::RegisterClassTemplate((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_19_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::DefineBehavior((void*) G__int(libp->para[0]), (void*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}


/* TRandom */
static int G__G__MathCore_110_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRandom((UInt_t) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TRandom((UInt_t) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TRandom[n];
       } else {
         p = new((void*) gvp) TRandom[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TRandom;
       } else {
         p = new((void*) gvp) TRandom;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TRandom*) G__getstructoffset())->Binomial((Int_t) G__int(libp->para[0]), (Double_t) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->BreitWigner((Double_t) G__double(libp->para[0]), (Double_t) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->BreitWigner((Double_t) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->BreitWigner());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->Circle(*(Double_t*) G__Doubleref(&libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1])
, (Double_t) G__double(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Exp((Double_t) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Gaus((Double_t) G__double(libp->para[0]), (Double_t) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Gaus((Double_t) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Gaus());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const TRandom*) G__getstructoffset())->GetSeed());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((TRandom*) G__getstructoffset())->Integer((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Landau((Double_t) G__double(libp->para[0]), (Double_t) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Landau((Double_t) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Landau());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TRandom*) G__getstructoffset())->Poisson((Double_t) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->PoissonD((Double_t) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->Rannor(*(Float_t*) G__Floatref(&libp->para[0]), *(Float_t*) G__Floatref(&libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->Rannor(*(Double_t*) G__Doubleref(&libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->ReadRandom((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TRandom*) G__getstructoffset())->SetSeed((UInt_t) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ((TRandom*) G__getstructoffset())->SetSeed();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Rndm((Int_t) G__int(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Rndm());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->RndmArray((Int_t) G__int(libp->para[0]), (Float_t*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->RndmArray((Int_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->Sphere(*(Double_t*) G__Doubleref(&libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1])
, *(Double_t*) G__Doubleref(&libp->para[2]), (Double_t) G__double(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Uniform((Double_t) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Uniform());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Uniform((Double_t) G__double(libp->para[0]), (Double_t) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->WriteRandom((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TRandom::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TRandom::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TRandom::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_110_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_110_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TRandom* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TRandom(*(TRandom*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TRandom G__TTRandom;
static int G__G__MathCore_110_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TRandom*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TRandom*) (soff+(sizeof(TRandom)*i)))->~G__TTRandom();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TRandom*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TRandom*) (soff))->~G__TTRandom();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_110_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom* dest = (TRandom*) G__getstructoffset();
   *dest = *(TRandom*) libp->para[0].ref;
   const TRandom& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TRandom1 */
static int G__G__MathCore_111_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom1* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRandom1[n];
     } else {
       p = new((void*) gvp) TRandom1[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRandom1;
     } else {
       p = new((void*) gvp) TRandom1;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom1* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRandom1((UInt_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) TRandom1((UInt_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRandom1((UInt_t) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TRandom1((UInt_t) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom1* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TRandom1(
(Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2]));
   } else {
     p = new((void*) gvp) TRandom1(
(Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TRandom1*) G__getstructoffset())->GetLuxury());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 72, (long) ((const TRandom1*) G__getstructoffset())->GetTheSeeds());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TRandom1::GetTableSeeds((UInt_t*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TRandom1*) G__getstructoffset())->SetSeed2((UInt_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((TRandom1*) G__getstructoffset())->SetSeed2((UInt_t) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TRandom1*) G__getstructoffset())->SetSeeds((const UInt_t*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((TRandom1*) G__getstructoffset())->SetSeeds((const UInt_t*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TRandom1::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom1::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TRandom1::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TRandom1::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom1*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom1::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom1::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom1::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_111_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom1::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_111_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TRandom1* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TRandom1(*(TRandom1*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TRandom1 G__TTRandom1;
static int G__G__MathCore_111_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TRandom1*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TRandom1*) (soff+(sizeof(TRandom1)*i)))->~G__TTRandom1();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TRandom1*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TRandom1*) (soff))->~G__TTRandom1();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TRandom2 */
static int G__G__MathCore_112_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom2* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRandom2((UInt_t) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TRandom2((UInt_t) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TRandom2[n];
       } else {
         p = new((void*) gvp) TRandom2[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TRandom2;
       } else {
         p = new((void*) gvp) TRandom2;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_112_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TRandom2::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_112_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom2::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_112_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TRandom2::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_112_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TRandom2::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_112_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom2*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_112_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom2::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_112_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom2::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_112_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom2::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_112_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom2::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_112_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TRandom2* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TRandom2(*(TRandom2*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TRandom2 G__TTRandom2;
static int G__G__MathCore_112_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TRandom2*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TRandom2*) (soff+(sizeof(TRandom2)*i)))->~G__TTRandom2();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TRandom2*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TRandom2*) (soff))->~G__TTRandom2();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_112_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom2* dest = (TRandom2*) G__getstructoffset();
   *dest = *(TRandom2*) libp->para[0].ref;
   const TRandom2& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TRandom3 */
static int G__G__MathCore_113_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom3* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRandom3((UInt_t) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TRandom3((UInt_t) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TRandom3[n];
       } else {
         p = new((void*) gvp) TRandom3[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TRandom3;
       } else {
         p = new((void*) gvp) TRandom3;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_113_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TRandom3::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_113_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom3::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_113_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TRandom3::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_113_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TRandom3::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_113_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom3*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_113_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom3::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_113_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom3::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_113_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom3::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_113_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom3::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_113_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TRandom3* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TRandom3(*(TRandom3*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TRandom3 G__TTRandom3;
static int G__G__MathCore_113_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TRandom3*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TRandom3*) (soff+(sizeof(TRandom3)*i)))->~G__TTRandom3();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TRandom3*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TRandom3*) (soff))->~G__TTRandom3();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_113_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom3* dest = (TRandom3*) G__getstructoffset();
   *dest = *(TRandom3*) libp->para[0].ref;
   const TRandom3& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TVirtualFitter */
static int G__G__MathCore_121_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TVirtualFitter*) G__getstructoffset())->Chisquare((Int_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TVirtualFitter*) G__getstructoffset())->ExecuteCommand((const char*) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->FixParameter((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      ((TVirtualFitter*) G__getstructoffset())->GetConfidenceIntervals((Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (Double_t*) G__int(libp->para[2]), (Double_t*) G__int(libp->para[3])
, (Double_t) G__double(libp->para[4]));
      G__setnull(result7);
      break;
   case 4:
      ((TVirtualFitter*) G__getstructoffset())->GetConfidenceIntervals((Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (Double_t*) G__int(libp->para[2]), (Double_t*) G__int(libp->para[3]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TVirtualFitter*) G__getstructoffset())->GetConfidenceIntervals((TObject*) G__int(libp->para[0]), (Double_t) G__double(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((TVirtualFitter*) G__getstructoffset())->GetConfidenceIntervals((TObject*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const TVirtualFitter*) G__getstructoffset())->GetCovarianceMatrix());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TVirtualFitter*) G__getstructoffset())->GetCovarianceMatrixElement((Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetErrors((Int_t) G__int(libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1])
, *(Double_t*) G__Doubleref(&libp->para[2]), *(Double_t*) G__Doubleref(&libp->para[3])
, *(Double_t*) G__Doubleref(&libp->para[4])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((TVirtualFitter*) G__getstructoffset())->GetFCN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Foption_t* pobj;
         const Foption_t xobj = ((const TVirtualFitter*) G__getstructoffset())->GetFitOption();
         pobj = new Foption_t(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TVirtualFitter*) G__getstructoffset())->GetMethodCall());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetNumberTotalParameters());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetNumberFreeParameters());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TVirtualFitter*) G__getstructoffset())->GetObjectFit());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TVirtualFitter*) G__getstructoffset())->GetParError((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TVirtualFitter*) G__getstructoffset())->GetParameter((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetParameter((Int_t) G__int(libp->para[0]), (char*) G__int(libp->para[1])
, *(Double_t*) G__Doubleref(&libp->para[2]), *(Double_t*) G__Doubleref(&libp->para[3])
, *(Double_t*) G__Doubleref(&libp->para[4]), *(Double_t*) G__Doubleref(&libp->para[5])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TVirtualFitter*) G__getstructoffset())->GetParName((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetStats(*(Double_t*) G__Doubleref(&libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1])
, *(Double_t*) G__Doubleref(&libp->para[2]), *(Int_t*) G__Intref(&libp->para[3])
, *(Int_t*) G__Intref(&libp->para[4])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TVirtualFitter*) G__getstructoffset())->GetSumLog((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TVirtualFitter*) G__getstructoffset())->GetUserFunc());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetXfirst());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetXlast());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetYfirst());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetYlast());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetZfirst());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetZlast());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TVirtualFitter*) G__getstructoffset())->IsFixed((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TVirtualFitter*) G__getstructoffset())->PrintResults((Int_t) G__int(libp->para[0]), (Double_t) G__double(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->ReleaseParameter((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((TVirtualFitter*) G__getstructoffset())->SetCache((Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetFCN((void*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetFCN((void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t)) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetFitMethod((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetFitOption(*((Foption_t*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetObjectFit((TObject*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TVirtualFitter*) G__getstructoffset())->SetParameter((Int_t) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Double_t) G__double(libp->para[2]), (Double_t) G__double(libp->para[3])
, (Double_t) G__double(libp->para[4]), (Double_t) G__double(libp->para[5])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetUserFunc((TObject*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetXfirst((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetXlast((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetYfirst((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetYlast((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetZfirst((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetZlast((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TVirtualFitter::GetFitter());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 85, (long) TVirtualFitter::Fitter((TObject*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 85, (long) TVirtualFitter::Fitter((TObject*) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualFitter::GetDefaultFitter());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualFitter::GetMaxIterations());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_53(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) TVirtualFitter::GetErrorDef());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) TVirtualFitter::GetPrecision());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      TVirtualFitter::SetDefaultFitter((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      TVirtualFitter::SetDefaultFitter();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_56(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      TVirtualFitter::SetFitter((TVirtualFitter*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      TVirtualFitter::SetFitter((TVirtualFitter*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_57(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      TVirtualFitter::SetMaxIterations((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      TVirtualFitter::SetMaxIterations();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_58(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      TVirtualFitter::SetErrorDef((Double_t) G__double(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      TVirtualFitter::SetErrorDef();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_59(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      TVirtualFitter::SetPrecision((Double_t) G__double(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      TVirtualFitter::SetPrecision();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_60(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TVirtualFitter::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_61(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualFitter::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_62(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TVirtualFitter::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_63(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TVirtualFitter::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_67(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_68(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualFitter::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_69(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualFitter::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_70(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualFitter::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_121_0_71(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualFitter::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TVirtualFitter G__TTVirtualFitter;
static int G__G__MathCore_121_0_72(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TVirtualFitter*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TVirtualFitter*) (soff+(sizeof(TVirtualFitter)*i)))->~G__TTVirtualFitter();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TVirtualFitter*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TVirtualFitter*) (soff))->~G__TTVirtualFitter();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TKDTree<int,double> */
static int G__G__MathCore_122_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TKDTree<int,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TKDTree<int,double>[n];
     } else {
       p = new((void*) gvp) TKDTree<int,double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TKDTree<int,double>;
     } else {
       p = new((void*) gvp) TKDTree<int,double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TKDTree<int,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TKDTree<int,double>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]));
   } else {
     p = new((void*) gvp) TKDTree<int,double>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TKDTree<int,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 4
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TKDTree<int,double>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (double**) G__int(libp->para[3]));
   } else {
     p = new((void*) gvp) TKDTree<int,double>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (double**) G__int(libp->para[3]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->Build();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ((const TKDTree<int,double>*) G__getstructoffset())->Distance((double*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ((const TKDTree<int,double>*) G__getstructoffset())->Distance((double*) G__int(libp->para[0]), (int) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      ((TKDTree<int,double>*) G__getstructoffset())->DistanceToNode((double*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, (Int_t) G__int(libp->para[4]));
      G__setnull(result7);
      break;
   case 4:
      ((TKDTree<int,double>*) G__getstructoffset())->DistanceToNode((double*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), *(double*) G__Doubleref(&libp->para[3]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetLeft((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetRight((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetParent((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 73, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetPointsIndexes((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TKDTree<int,double>*) G__getstructoffset())->GetNodePointsIndexes((Int_t) G__int(libp->para[0]), *(Int_t*) G__Intref(&libp->para[1])
, *(Int_t*) G__Intref(&libp->para[2]), *(Int_t*) G__Intref(&libp->para[3])
, *(Int_t*) G__Intref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 98, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetNodeAxis((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TKDTree<int,double>*) G__getstructoffset())->GetNodeValue((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetNNodes());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetTotalNodes());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetBoundaries());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetBoundariesExact());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetBoundary((const Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetBoundaryExact((const Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetNPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetNDim());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetNPointsNode((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetRowT0());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetCrossNode());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetOffset());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 73, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetIndPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetBucketSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->FindNearestNeighbors((double*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (int*) G__int(libp->para[2]), (double*) G__int(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,double>*) G__getstructoffset())->FindNode((double*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->FindPoint((double*) G__int(libp->para[0]), *(int*) G__Intref(&libp->para[1])
, *(Int_t*) G__Intref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->FindInRange((double*) G__int(libp->para[0]), (double) G__double(libp->para[1])
, *(vector<int>*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->FindBNodeA((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, *(Int_t*) G__Intref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TKDTree<int,double>*) G__getstructoffset())->IsTerminal((int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->IsOwner());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TKDTree<int,double>*) G__getstructoffset())->KOrdStat((int) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (int) G__int(libp->para[2]), (int*) G__int(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TKDTree<int,double>*) G__getstructoffset())->MakeBoundaries((double*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ((TKDTree<int,double>*) G__getstructoffset())->MakeBoundaries();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->MakeBoundariesExact();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->SetData((int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (double**) G__int(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->SetData((int) G__int(libp->para[0]), (double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->SetOwner((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TKDTree<int,double>*) G__getstructoffset())->Spread((int) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (int*) G__int(libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, *(double*) G__Doubleref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TKDTree<int,double>::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTree<int,double>::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TKDTree<int,double>::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TKDTree<int,double>::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTree<int,double>::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_56(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TKDTree<int,double>::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_57(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTree<int,double>::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_122_0_58(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TKDTree<int,double>::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TKDTree<int,double> G__TTKDTreelEintcOdoublegR;
static int G__G__MathCore_122_0_59(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TKDTree<int,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TKDTree<int,double>*) (soff+(sizeof(TKDTree<int,double>)*i)))->~G__TTKDTreelEintcOdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TKDTree<int,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TKDTree<int,double>*) (soff))->~G__TTKDTreelEintcOdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TKDTree<int,float> */
static int G__G__MathCore_127_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TKDTree<int,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TKDTree<int,float>[n];
     } else {
       p = new((void*) gvp) TKDTree<int,float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TKDTree<int,float>;
     } else {
       p = new((void*) gvp) TKDTree<int,float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TKDTree<int,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TKDTree<int,float>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]));
   } else {
     p = new((void*) gvp) TKDTree<int,float>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TKDTree<int,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 4
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TKDTree<int,float>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (float**) G__int(libp->para[3]));
   } else {
     p = new((void*) gvp) TKDTree<int,float>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (float**) G__int(libp->para[3]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->Build();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ((const TKDTree<int,float>*) G__getstructoffset())->Distance((float*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ((const TKDTree<int,float>*) G__getstructoffset())->Distance((float*) G__int(libp->para[0]), (int) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      ((TKDTree<int,float>*) G__getstructoffset())->DistanceToNode((float*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, *(float*) G__Floatref(&libp->para[2]), *(float*) G__Floatref(&libp->para[3])
, (Int_t) G__int(libp->para[4]));
      G__setnull(result7);
      break;
   case 4:
      ((TKDTree<int,float>*) G__getstructoffset())->DistanceToNode((float*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, *(float*) G__Floatref(&libp->para[2]), *(float*) G__Floatref(&libp->para[3]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetLeft((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetRight((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetParent((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 73, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetPointsIndexes((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TKDTree<int,float>*) G__getstructoffset())->GetNodePointsIndexes((Int_t) G__int(libp->para[0]), *(Int_t*) G__Intref(&libp->para[1])
, *(Int_t*) G__Intref(&libp->para[2]), *(Int_t*) G__Intref(&libp->para[3])
, *(Int_t*) G__Intref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 98, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetNodeAxis((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const TKDTree<int,float>*) G__getstructoffset())->GetNodeValue((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetNNodes());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetTotalNodes());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 70, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetBoundaries());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 70, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetBoundariesExact());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 70, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetBoundary((const Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 70, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetBoundaryExact((const Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetNPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetNDim());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetNPointsNode((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetRowT0());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetCrossNode());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetOffset());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 73, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetIndPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetBucketSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->FindNearestNeighbors((float*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (int*) G__int(libp->para[2]), (float*) G__int(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,float>*) G__getstructoffset())->FindNode((float*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->FindPoint((float*) G__int(libp->para[0]), *(int*) G__Intref(&libp->para[1])
, *(Int_t*) G__Intref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->FindInRange((float*) G__int(libp->para[0]), (float) G__double(libp->para[1])
, *(vector<int>*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->FindBNodeA((float*) G__int(libp->para[0]), (float*) G__int(libp->para[1])
, *(Int_t*) G__Intref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TKDTree<int,float>*) G__getstructoffset())->IsTerminal((int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->IsOwner());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const TKDTree<int,float>*) G__getstructoffset())->KOrdStat((int) G__int(libp->para[0]), (float*) G__int(libp->para[1])
, (int) G__int(libp->para[2]), (int*) G__int(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TKDTree<int,float>*) G__getstructoffset())->MakeBoundaries((float*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ((TKDTree<int,float>*) G__getstructoffset())->MakeBoundaries();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->MakeBoundariesExact();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->SetData((int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (float**) G__int(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->SetData((int) G__int(libp->para[0]), (float*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->SetOwner((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TKDTree<int,float>*) G__getstructoffset())->Spread((int) G__int(libp->para[0]), (float*) G__int(libp->para[1])
, (int*) G__int(libp->para[2]), *(float*) G__Floatref(&libp->para[3])
, *(float*) G__Floatref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TKDTree<int,float>::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTree<int,float>::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TKDTree<int,float>::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TKDTree<int,float>::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTree<int,float>::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_56(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TKDTree<int,float>::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_57(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTree<int,float>::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_58(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TKDTree<int,float>::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TKDTree<int,float> G__TTKDTreelEintcOfloatgR;
static int G__G__MathCore_127_0_59(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TKDTree<int,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TKDTree<int,float>*) (soff+(sizeof(TKDTree<int,float>)*i)))->~G__TTKDTreelEintcOfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TKDTree<int,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TKDTree<int,float>*) (soff))->~G__TTKDTreelEintcOfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TKDTreeBinning */
static int G__G__MathCore_130_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TKDTreeBinning* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TKDTreeBinning(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (Double_t*) G__int(libp->para[2]), (UInt_t) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) TKDTreeBinning(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (Double_t*) G__int(libp->para[2]), (UInt_t) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TKDTreeBinning(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (Double_t*) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) TKDTreeBinning(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (Double_t*) G__int(libp->para[2]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreeBinning));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTreeBinning*) G__getstructoffset())->SetNBins((UInt_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TKDTreeBinning*) G__getstructoffset())->SortBinsByDensity((Bool_t) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ((TKDTreeBinning*) G__getstructoffset())->SortBinsByDensity();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const TKDTreeBinning*) G__getstructoffset())->GetBinsMinEdges());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const TKDTreeBinning*) G__getstructoffset())->GetBinsMaxEdges());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const pair<const Double_t*,const Double_t*>* pobj;
         const pair<const Double_t*,const Double_t*> xobj = ((const TKDTreeBinning*) G__getstructoffset())->GetBinsEdges();
         pobj = new pair<const Double_t*,const Double_t*>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const pair<const Double_t*,const Double_t*>* pobj;
         const pair<const Double_t*,const Double_t*> xobj = ((const TKDTreeBinning*) G__getstructoffset())->GetBinEdges((UInt_t) G__int(libp->para[0]));
         pobj = new pair<const Double_t*,const Double_t*>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const TKDTreeBinning*) G__getstructoffset())->GetBinMinEdges((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const TKDTreeBinning*) G__getstructoffset())->GetBinMaxEdges((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const TKDTreeBinning*) G__getstructoffset())->GetNBins());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const TKDTreeBinning*) G__getstructoffset())->GetDim());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const TKDTreeBinning*) G__getstructoffset())->GetBinContent((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TKDTreeBinning*) G__getstructoffset())->GetTree());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const TKDTreeBinning*) G__getstructoffset())->GetDimData((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TKDTreeBinning*) G__getstructoffset())->GetDataMin((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TKDTreeBinning*) G__getstructoffset())->GetDataMax((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TKDTreeBinning*) G__getstructoffset())->GetBinDensity((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TKDTreeBinning*) G__getstructoffset())->GetBinVolume((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const TKDTreeBinning*) G__getstructoffset())->GetOneDimBinEdges());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const TKDTreeBinning*) G__getstructoffset())->GetBinCenter((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const TKDTreeBinning*) G__getstructoffset())->GetBinWidth((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const TKDTreeBinning*) G__getstructoffset())->GetBinMaxDensity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const TKDTreeBinning*) G__getstructoffset())->GetBinMinDensity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TKDTreeBinning*) G__getstructoffset())->FillBinData(*(ROOT::Fit::BinData*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TKDTreeBinning::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTreeBinning::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TKDTreeBinning::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TKDTreeBinning::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTreeBinning*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTreeBinning::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TKDTreeBinning::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTreeBinning::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TKDTreeBinning::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TKDTreeBinning G__TTKDTreeBinning;
static int G__G__MathCore_130_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TKDTreeBinning*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TKDTreeBinning*) (soff+(sizeof(TKDTreeBinning)*i)))->~G__TTKDTreeBinning();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TKDTreeBinning*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TKDTreeBinning*) (soff))->~G__TTKDTreeBinning();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<double,allocator<double> > */
static int G__G__MathCore_132_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const double& obj = ((vector<double,allocator<double> >*) G__getstructoffset())->at((vector<double,allocator<double> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::iterator* pobj;
         vector<double,allocator<double> >::iterator xobj = ((vector<double,allocator<double> >*) G__getstructoffset())->begin();
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::iterator* pobj;
         vector<double,allocator<double> >::iterator xobj = ((vector<double,allocator<double> >*) G__getstructoffset())->end();
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::reverse_iterator* pobj;
         vector<double,allocator<double> >::reverse_iterator xobj = ((vector<double,allocator<double> >*) G__getstructoffset())->rbegin();
         pobj = new vector<double,allocator<double> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::reverse_iterator* pobj;
         vector<double,allocator<double> >::reverse_iterator xobj = ((vector<double,allocator<double> >*) G__getstructoffset())->rend();
         pobj = new vector<double,allocator<double> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<double,allocator<double> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<double,allocator<double> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->resize((vector<double,allocator<double> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->resize((vector<double,allocator<double> >::size_type) G__int(libp->para[0]), (double) G__double(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<double,allocator<double> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<double,allocator<double> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const double& obj = ((vector<double,allocator<double> >*) G__getstructoffset())->operator[]((vector<double,allocator<double> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<double,allocator<double> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<double,allocator<double> >[n];
     } else {
       p = new((void*) gvp) vector<double,allocator<double> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<double,allocator<double> >;
     } else {
       p = new((void*) gvp) vector<double,allocator<double> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<double,allocator<double> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<double,allocator<double> >((vector<double,allocator<double> >::size_type) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
     } else {
       p = new((void*) gvp) vector<double,allocator<double> >((vector<double,allocator<double> >::size_type) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<double,allocator<double> >((vector<double,allocator<double> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<double,allocator<double> >((vector<double,allocator<double> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<double,allocator<double> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<double,allocator<double> >(*(vector<double,allocator<double> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<double,allocator<double> >(*(vector<double,allocator<double> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<double,allocator<double> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<double,allocator<double> >(*((vector<double,allocator<double> >::const_iterator*) G__int(libp->para[0])), *((vector<double,allocator<double> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<double,allocator<double> >(*((vector<double,allocator<double> >::const_iterator*) G__int(libp->para[0])), *((vector<double,allocator<double> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >& obj = ((vector<double,allocator<double> >*) G__getstructoffset())->operator=(*(vector<double,allocator<double> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->reserve((vector<double,allocator<double> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const double& obj = ((vector<double,allocator<double> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const double& obj = ((vector<double,allocator<double> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->push_back(*(double*) G__Doubleref(&libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->swap(*(vector<double,allocator<double> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::iterator* pobj;
         vector<double,allocator<double> >::iterator xobj = ((vector<double,allocator<double> >*) G__getstructoffset())->insert(*((vector<double,allocator<double> >::iterator*) G__int(libp->para[0])), *(double*) G__Doubleref(&libp->para[1]));
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->insert(*((vector<double,allocator<double> >::iterator*) G__int(libp->para[0])), *((vector<double,allocator<double> >::const_iterator*) G__int(libp->para[1]))
, *((vector<double,allocator<double> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->insert(*((vector<double,allocator<double> >::iterator*) G__int(libp->para[0])), (vector<double,allocator<double> >::size_type) G__int(libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->erase(*((vector<double,allocator<double> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->erase(*((vector<double,allocator<double> >::iterator*) G__int(libp->para[0])), *((vector<double,allocator<double> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<double,allocator<double> > G__TvectorlEdoublecOallocatorlEdoublegRsPgR;
static int G__G__MathCore_132_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<double,allocator<double> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<double,allocator<double> >*) (soff+(sizeof(vector<double,allocator<double> >)*i)))->~G__TvectorlEdoublecOallocatorlEdoublegRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<double,allocator<double> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<double,allocator<double> >*) (soff))->~G__TvectorlEdoublecOallocatorlEdoublegRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<double,allocator<double> >::iterator */
static int G__G__MathCore_133_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<double,allocator<double> >::iterator* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<double,allocator<double> >::iterator[n];
     } else {
       p = new((void*) gvp) vector<double,allocator<double> >::iterator[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<double,allocator<double> >::iterator;
     } else {
       p = new((void*) gvp) vector<double,allocator<double> >::iterator;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_133_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<double,allocator<double> >::iterator* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<double,allocator<double> >::iterator(libp->para[0].ref ? *(const vector<double,allocator<double> >::iterator::pointer*) libp->para[0].ref : *(const vector<double,allocator<double> >::iterator::pointer*) (void*) (&G__Mlong(libp->para[0])));
   } else {
     p = new((void*) gvp) vector<double,allocator<double> >::iterator(libp->para[0].ref ? *(const vector<double,allocator<double> >::iterator::pointer*) libp->para[0].ref : *(const vector<double,allocator<double> >::iterator::pointer*) (void*) (&G__Mlong(libp->para[0])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_133_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator::reference obj = ((const vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator*();
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_133_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_133_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator& obj = ((vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator++();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_133_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::iterator* pobj;
         vector<double,allocator<double> >::iterator xobj = ((vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator++((int) G__int(libp->para[0]));
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_133_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator& obj = ((vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator--();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_133_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::iterator* pobj;
         vector<double,allocator<double> >::iterator xobj = ((vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator--((int) G__int(libp->para[0]));
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_133_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator::reference obj = ((const vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator[](*(vector<double,allocator<double> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_133_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator& obj = ((vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator+=(*(vector<double,allocator<double> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_133_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator* pobj;
         const vector<double,allocator<double> >::iterator xobj = ((const vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator+(*(vector<double,allocator<double> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_133_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator& obj = ((vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator-=(*(vector<double,allocator<double> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_133_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator* pobj;
         const vector<double,allocator<double> >::iterator xobj = ((const vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator-(*(vector<double,allocator<double> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_133_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator::pointer& obj = ((const vector<double,allocator<double> >::iterator*) G__getstructoffset())->base();
         result7->ref = (long) (&obj);
         G__letint(result7, 'D', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_133_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::iterator* pobj;
         vector<double,allocator<double> >::iterator xobj = ((vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator=(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref);
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_133_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   vector<double,allocator<double> >::iterator* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new vector<double,allocator<double> >::iterator(*(vector<double,allocator<double> >::iterator*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<double,allocator<double> >::iterator G__TvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator;
static int G__G__MathCore_133_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<double,allocator<double> >::iterator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<double,allocator<double> >::iterator*) (soff+(sizeof(vector<double,allocator<double> >::iterator)*i)))->~G__TvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<double,allocator<double> >::iterator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<double,allocator<double> >::iterator*) (soff))->~G__TvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* reverse_iterator<vector<double,allocator<double> >::iterator> */
static int G__G__MathCore_134_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   reverse_iterator<vector<double,allocator<double> >::iterator>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new reverse_iterator<vector<double,allocator<double> >::iterator>[n];
     } else {
       p = new((void*) gvp) reverse_iterator<vector<double,allocator<double> >::iterator>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new reverse_iterator<vector<double,allocator<double> >::iterator>;
     } else {
       p = new((void*) gvp) reverse_iterator<vector<double,allocator<double> >::iterator>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator* pobj;
         const vector<double,allocator<double> >::iterator xobj = ((const reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->base();
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>::reference obj = ((const reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator*();
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>& obj = ((reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator++();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         reverse_iterator<vector<double,allocator<double> >::iterator>* pobj;
         reverse_iterator<vector<double,allocator<double> >::iterator> xobj = ((reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator++((int) G__int(libp->para[0]));
         pobj = new reverse_iterator<vector<double,allocator<double> >::iterator>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>& obj = ((reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator--();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         reverse_iterator<vector<double,allocator<double> >::iterator>* pobj;
         reverse_iterator<vector<double,allocator<double> >::iterator> xobj = ((reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator--((int) G__int(libp->para[0]));
         pobj = new reverse_iterator<vector<double,allocator<double> >::iterator>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>* pobj;
         const reverse_iterator<vector<double,allocator<double> >::iterator> xobj = ((const reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator+((reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type) G__int(libp->para[0]));
         pobj = new reverse_iterator<vector<double,allocator<double> >::iterator>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>& obj = ((reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator+=((reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>* pobj;
         const reverse_iterator<vector<double,allocator<double> >::iterator> xobj = ((const reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator-((reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type) G__int(libp->para[0]));
         pobj = new reverse_iterator<vector<double,allocator<double> >::iterator>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>& obj = ((reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator-=((reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>::reference obj = ((const reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator[]((reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_134_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   reverse_iterator<vector<double,allocator<double> >::iterator>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new reverse_iterator<vector<double,allocator<double> >::iterator>(*(reverse_iterator<vector<double,allocator<double> >::iterator>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef reverse_iterator<vector<double,allocator<double> >::iterator> G__Treverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR;
static int G__G__MathCore_134_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (reverse_iterator<vector<double,allocator<double> >::iterator>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((reverse_iterator<vector<double,allocator<double> >::iterator>*) (soff+(sizeof(reverse_iterator<vector<double,allocator<double> >::iterator>)*i)))->~G__Treverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (reverse_iterator<vector<double,allocator<double> >::iterator>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((reverse_iterator<vector<double,allocator<double> >::iterator>*) (soff))->~G__Treverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_134_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   reverse_iterator<vector<double,allocator<double> >::iterator>* dest = (reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset();
   const reverse_iterator<vector<double,allocator<double> >::iterator>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math */
static int G__G__MathCore_170_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::erf((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::erfc((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::tgamma((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::lgamma((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::inc_gamma((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::inc_gamma_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::beta((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::inc_beta((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::sinint((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::cosint((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::beta_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::binomial_pdf((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (unsigned int) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::negative_binomial_pdf((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_pdf((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_pdf((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_pdf((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_pdf((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::poisson_pdf((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::tdistribution_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::tdistribution_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::beta_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::beta_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_cdf((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_cdf_c((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_cdf_c((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_cdf_c((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_cdf((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_cdf((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::tdistribution_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::tdistribution_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::tdistribution_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::tdistribution_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_53(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::poisson_cdf_c((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::poisson_cdf((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::binomial_cdf_c((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (unsigned int) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_56(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::binomial_cdf((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (unsigned int) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_57(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::negative_binomial_cdf_c((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_58(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::negative_binomial_cdf((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_59(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_xm1((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_xm1((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_xm1((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_60(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_xm2((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_xm2((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_xm2((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_61(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::beta_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_62(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::beta_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_63(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_64(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_65(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_66(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_67(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_68(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_69(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_70(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_71(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_72(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_73(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_74(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_75(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_76(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_77(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_78(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_79(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::normal_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_80(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::normal_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_81(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_82(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_83(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_quantile((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_84(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_quantile_c((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IBaseFunctionOneDim */
static int G__G__MathCore_171_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const ROOT::Math::IBaseFunctionOneDim*) G__getstructoffset())->Clone());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_171_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IBaseFunctionOneDim*) G__getstructoffset())->operator()((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_171_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IBaseFunctionOneDim*) G__getstructoffset())->operator()((double*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IBaseFunctionOneDim G__TROOTcLcLMathcLcLIBaseFunctionOneDim;
static int G__G__MathCore_171_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IBaseFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IBaseFunctionOneDim*) (soff+(sizeof(ROOT::Math::IBaseFunctionOneDim)*i)))->~G__TROOTcLcLMathcLcLIBaseFunctionOneDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IBaseFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IBaseFunctionOneDim*) (soff))->~G__TROOTcLcLMathcLcLIBaseFunctionOneDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_171_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IBaseFunctionOneDim* dest = (ROOT::Math::IBaseFunctionOneDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IBaseFunctionOneDim*) libp->para[0].ref;
   const ROOT::Math::IBaseFunctionOneDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IGradientFunctionOneDim */
// automatic destructor
typedef ROOT::Math::IGradientFunctionOneDim G__TROOTcLcLMathcLcLIGradientFunctionOneDim;
static int G__G__MathCore_172_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IGradientFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IGradientFunctionOneDim*) (soff+(sizeof(ROOT::Math::IGradientFunctionOneDim)*i)))->~G__TROOTcLcLMathcLcLIGradientFunctionOneDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IGradientFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IGradientFunctionOneDim*) (soff))->~G__TROOTcLcLMathcLcLIGradientFunctionOneDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_172_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IGradientFunctionOneDim* dest = (ROOT::Math::IGradientFunctionOneDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IGradientFunctionOneDim*) libp->para[0].ref;
   const ROOT::Math::IGradientFunctionOneDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IBaseFunctionMultiDim */
static int G__G__MathCore_173_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const ROOT::Math::IBaseFunctionMultiDim*) G__getstructoffset())->Clone());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_173_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::IBaseFunctionMultiDim*) G__getstructoffset())->NDim());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_173_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IBaseFunctionMultiDim*) G__getstructoffset())->operator()((double*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IBaseFunctionMultiDim G__TROOTcLcLMathcLcLIBaseFunctionMultiDim;
static int G__G__MathCore_173_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IBaseFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IBaseFunctionMultiDim*) (soff+(sizeof(ROOT::Math::IBaseFunctionMultiDim)*i)))->~G__TROOTcLcLMathcLcLIBaseFunctionMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IBaseFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IBaseFunctionMultiDim*) (soff))->~G__TROOTcLcLMathcLcLIBaseFunctionMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_173_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IBaseFunctionMultiDim* dest = (ROOT::Math::IBaseFunctionMultiDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IBaseFunctionMultiDim*) libp->para[0].ref;
   const ROOT::Math::IBaseFunctionMultiDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IGradientFunctionMultiDim */
// automatic destructor
typedef ROOT::Math::IGradientFunctionMultiDim G__TROOTcLcLMathcLcLIGradientFunctionMultiDim;
static int G__G__MathCore_174_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IGradientFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IGradientFunctionMultiDim*) (soff+(sizeof(ROOT::Math::IGradientFunctionMultiDim)*i)))->~G__TROOTcLcLMathcLcLIGradientFunctionMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IGradientFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IGradientFunctionMultiDim*) (soff))->~G__TROOTcLcLMathcLcLIGradientFunctionMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_174_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IGradientFunctionMultiDim* dest = (ROOT::Math::IGradientFunctionMultiDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IGradientFunctionMultiDim*) libp->para[0].ref;
   const ROOT::Math::IGradientFunctionMultiDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IGradientMultiDim */
static int G__G__MathCore_175_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IGradientMultiDim*) G__getstructoffset())->Gradient((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_175_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IGradientMultiDim*) G__getstructoffset())->Derivative((double*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IGradientMultiDim*) G__getstructoffset())->Derivative((double*) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_175_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IGradientMultiDim*) G__getstructoffset())->FdF((double*) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, (double*) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IGradientMultiDim G__TROOTcLcLMathcLcLIGradientMultiDim;
static int G__G__MathCore_175_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IGradientMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IGradientMultiDim*) (soff+(sizeof(ROOT::Math::IGradientMultiDim)*i)))->~G__TROOTcLcLMathcLcLIGradientMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IGradientMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IGradientMultiDim*) (soff))->~G__TROOTcLcLMathcLcLIGradientMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_175_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IGradientMultiDim* dest = (ROOT::Math::IGradientMultiDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IGradientMultiDim*) libp->para[0].ref;
   const ROOT::Math::IGradientMultiDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IGradientOneDim */
static int G__G__MathCore_176_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IGradientOneDim*) G__getstructoffset())->Derivative((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_176_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IGradientOneDim*) G__getstructoffset())->FdF((double) G__double(libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_176_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IGradientOneDim*) G__getstructoffset())->Derivative((double*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_176_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IGradientOneDim*) G__getstructoffset())->Gradient((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_176_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IGradientOneDim*) G__getstructoffset())->FdF((double*) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, (double*) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IGradientOneDim G__TROOTcLcLMathcLcLIGradientOneDim;
static int G__G__MathCore_176_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IGradientOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IGradientOneDim*) (soff+(sizeof(ROOT::Math::IGradientOneDim)*i)))->~G__TROOTcLcLMathcLcLIGradientOneDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IGradientOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IGradientOneDim*) (soff))->~G__TROOTcLcLMathcLcLIGradientOneDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_176_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IGradientOneDim* dest = (ROOT::Math::IGradientOneDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IGradientOneDim*) libp->para[0].ref;
   const ROOT::Math::IGradientOneDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IParametricFunctionOneDim */
static int G__G__MathCore_177_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricFunctionOneDim*) G__getstructoffset())->operator()((double) G__double(libp->para[0]), (double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_177_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricFunctionOneDim*) G__getstructoffset())->operator()((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IParametricFunctionOneDim G__TROOTcLcLMathcLcLIParametricFunctionOneDim;
static int G__G__MathCore_177_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IParametricFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IParametricFunctionOneDim*) (soff+(sizeof(ROOT::Math::IParametricFunctionOneDim)*i)))->~G__TROOTcLcLMathcLcLIParametricFunctionOneDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IParametricFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IParametricFunctionOneDim*) (soff))->~G__TROOTcLcLMathcLcLIParametricFunctionOneDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_177_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IParametricFunctionOneDim* dest = (ROOT::Math::IParametricFunctionOneDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IParametricFunctionOneDim*) libp->para[0].ref;
   const ROOT::Math::IParametricFunctionOneDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IParametricGradFunctionOneDim */
static int G__G__MathCore_178_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterGradient((double) G__double(libp->para[0]), (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_178_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterGradient((double) G__double(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_178_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterGradient((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_178_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterGradient((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_178_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((double) G__double(libp->para[0]), (double*) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((double) G__double(libp->para[0]), (double*) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_178_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((double) G__double(libp->para[0]), (unsigned int) G__int(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_178_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_178_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((double*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((double*) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IParametricGradFunctionOneDim G__TROOTcLcLMathcLcLIParametricGradFunctionOneDim;
static int G__G__MathCore_178_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IParametricGradFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IParametricGradFunctionOneDim*) (soff+(sizeof(ROOT::Math::IParametricGradFunctionOneDim)*i)))->~G__TROOTcLcLMathcLcLIParametricGradFunctionOneDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IParametricGradFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IParametricGradFunctionOneDim*) (soff))->~G__TROOTcLcLMathcLcLIParametricGradFunctionOneDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_178_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IParametricGradFunctionOneDim* dest = (ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IParametricGradFunctionOneDim*) libp->para[0].ref;
   const ROOT::Math::IParametricGradFunctionOneDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IParametricFunctionMultiDim */
static int G__G__MathCore_179_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricFunctionMultiDim*) G__getstructoffset())->operator()((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IParametricFunctionMultiDim G__TROOTcLcLMathcLcLIParametricFunctionMultiDim;
static int G__G__MathCore_179_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IParametricFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IParametricFunctionMultiDim*) (soff+(sizeof(ROOT::Math::IParametricFunctionMultiDim)*i)))->~G__TROOTcLcLMathcLcLIParametricFunctionMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IParametricFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IParametricFunctionMultiDim*) (soff))->~G__TROOTcLcLMathcLcLIParametricFunctionMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_179_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IParametricFunctionMultiDim* dest = (ROOT::Math::IParametricFunctionMultiDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IParametricFunctionMultiDim*) libp->para[0].ref;
   const ROOT::Math::IParametricFunctionMultiDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IParametricGradFunctionMultiDim */
static int G__G__MathCore_180_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IParametricGradFunctionMultiDim*) G__getstructoffset())->ParameterGradient((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_180_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionMultiDim*) G__getstructoffset())->ParameterDerivative((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionMultiDim*) G__getstructoffset())->ParameterDerivative((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_180_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IParametricGradFunctionMultiDim*) G__getstructoffset())->ParameterGradient((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_180_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionMultiDim*) G__getstructoffset())->ParameterDerivative((double*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionMultiDim*) G__getstructoffset())->ParameterDerivative((double*) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IParametricGradFunctionMultiDim G__TROOTcLcLMathcLcLIParametricGradFunctionMultiDim;
static int G__G__MathCore_180_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IParametricGradFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IParametricGradFunctionMultiDim*) (soff+(sizeof(ROOT::Math::IParametricGradFunctionMultiDim)*i)))->~G__TROOTcLcLMathcLcLIParametricGradFunctionMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IParametricGradFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IParametricGradFunctionMultiDim*) (soff))->~G__TROOTcLcLMathcLcLIParametricGradFunctionMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_180_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IParametricGradFunctionMultiDim* dest = (ROOT::Math::IParametricGradFunctionMultiDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IParametricGradFunctionMultiDim*) libp->para[0].ref;
   const ROOT::Math::IParametricGradFunctionMultiDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IBaseParam */
static int G__G__MathCore_182_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const ROOT::Math::IBaseParam*) G__getstructoffset())->Parameters());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_182_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IBaseParam*) G__getstructoffset())->SetParameters((double*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_182_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::IBaseParam*) G__getstructoffset())->NPar());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_182_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::IBaseParam*) G__getstructoffset())->ParameterName((unsigned int) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IBaseParam G__TROOTcLcLMathcLcLIBaseParam;
static int G__G__MathCore_182_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IBaseParam*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IBaseParam*) (soff+(sizeof(ROOT::Math::IBaseParam)*i)))->~G__TROOTcLcLMathcLcLIBaseParam();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IBaseParam*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IBaseParam*) (soff))->~G__TROOTcLcLMathcLcLIBaseParam();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_182_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IBaseParam* dest = (ROOT::Math::IBaseParam*) G__getstructoffset();
   *dest = *(ROOT::Math::IBaseParam*) libp->para[0].ref;
   const ROOT::Math::IBaseParam& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::ParamFunctor */
static int G__G__MathCore_184_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::ParamFunctor* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::ParamFunctor[n];
     } else {
       p = new((void*) gvp) ROOT::Math::ParamFunctor[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::ParamFunctor;
     } else {
       p = new((void*) gvp) ROOT::Math::ParamFunctor;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_184_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::ParamFunctor* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::ParamFunctor((ROOT::Math::ParamFunctor::FreeFunc) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::ParamFunctor((ROOT::Math::ParamFunctor::FreeFunc) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_184_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::ParamFunctor* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::ParamFunctor(*(ROOT::Math::ParamFunctor*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::ParamFunctor(*(ROOT::Math::ParamFunctor*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_184_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::ParamFunctor& obj = ((ROOT::Math::ParamFunctor*) G__getstructoffset())->operator=(*(ROOT::Math::ParamFunctor*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_184_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((ROOT::Math::ParamFunctor*) G__getstructoffset())->GetImpl());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_184_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::ParamFunctor*) G__getstructoffset())->operator()((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_184_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::ParamFunctor*) G__getstructoffset())->Empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_184_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::ParamFunctor*) G__getstructoffset())->SetFunction((ROOT::Math::ParamFunctor::Impl*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::ParamFunctor G__TROOTcLcLMathcLcLParamFunctor;
static int G__G__MathCore_184_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::ParamFunctor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::ParamFunctor*) (soff+(sizeof(ROOT::Math::ParamFunctor)*i)))->~G__TROOTcLcLMathcLcLParamFunctor();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::ParamFunctor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::ParamFunctor*) (soff))->~G__TROOTcLcLMathcLcLParamFunctor();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Functor */
static int G__G__MathCore_185_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Functor* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Functor[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor;
     } else {
       p = new((void*) gvp) ROOT::Math::Functor;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_185_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Functor* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor(
(void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::Functor(
(void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor(
(void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::Functor(
(void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor((void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::Functor((void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_185_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::Functor& obj = ((ROOT::Math::Functor*) G__getstructoffset())->operator=(*(ROOT::Math::Functor*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_185_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Functor* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Functor(*(ROOT::Math::Functor*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Functor G__TROOTcLcLMathcLcLFunctor;
static int G__G__MathCore_185_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Functor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Functor*) (soff+(sizeof(ROOT::Math::Functor)*i)))->~G__TROOTcLcLMathcLcLFunctor();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Functor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Functor*) (soff))->~G__TROOTcLcLMathcLcLFunctor();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Functor1D */
static int G__G__MathCore_187_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Functor1D* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor1D[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Functor1D[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor1D;
     } else {
       p = new((void*) gvp) ROOT::Math::Functor1D;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_187_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Functor1D* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor1D(
(void*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::Functor1D(
(void*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor1D((void*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::Functor1D((void*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor1D((void*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::Functor1D((void*) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_187_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::Functor1D& obj = ((ROOT::Math::Functor1D*) G__getstructoffset())->operator=(*(ROOT::Math::Functor1D*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_187_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Functor1D* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Functor1D(*(ROOT::Math::Functor1D*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Functor1D G__TROOTcLcLMathcLcLFunctor1D;
static int G__G__MathCore_187_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Functor1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Functor1D*) (soff+(sizeof(ROOT::Math::Functor1D)*i)))->~G__TROOTcLcLMathcLcLFunctor1D();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Functor1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Functor1D*) (soff))->~G__TROOTcLcLMathcLcLFunctor1D();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GradFunctor */
static int G__G__MathCore_189_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GradFunctor* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GradFunctor[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GradFunctor[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GradFunctor;
     } else {
       p = new((void*) gvp) ROOT::Math::GradFunctor;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_189_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GradFunctor* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 5
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GradFunctor(
(void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]));
   } else {
     p = new((void*) gvp) ROOT::Math::GradFunctor(
(void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_189_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GradFunctor* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GradFunctor(
(void*) G__int(libp->para[0]), (void*) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2]));
   } else {
     p = new((void*) gvp) ROOT::Math::GradFunctor(
(void*) G__int(libp->para[0]), (void*) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_189_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::GradFunctor& obj = ((ROOT::Math::GradFunctor*) G__getstructoffset())->operator=(*(ROOT::Math::GradFunctor*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_189_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GradFunctor* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GradFunctor(*(ROOT::Math::GradFunctor*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GradFunctor G__TROOTcLcLMathcLcLGradFunctor;
static int G__G__MathCore_189_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GradFunctor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GradFunctor*) (soff+(sizeof(ROOT::Math::GradFunctor)*i)))->~G__TROOTcLcLMathcLcLGradFunctor();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GradFunctor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GradFunctor*) (soff))->~G__TROOTcLcLMathcLcLGradFunctor();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GradFunctor1D */
static int G__G__MathCore_191_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GradFunctor1D* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GradFunctor1D[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GradFunctor1D[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GradFunctor1D;
     } else {
       p = new((void*) gvp) ROOT::Math::GradFunctor1D;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_191_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GradFunctor1D* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 4
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GradFunctor1D(
(void*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3]));
   } else {
     p = new((void*) gvp) ROOT::Math::GradFunctor1D(
(void*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_191_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GradFunctor1D* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GradFunctor1D((void*) G__int(libp->para[0]), (void*) G__int(libp->para[1]));
   } else {
     p = new((void*) gvp) ROOT::Math::GradFunctor1D((void*) G__int(libp->para[0]), (void*) G__int(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_191_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::GradFunctor1D& obj = ((ROOT::Math::GradFunctor1D*) G__getstructoffset())->operator=(*(ROOT::Math::GradFunctor1D*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_191_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GradFunctor1D* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GradFunctor1D(*(ROOT::Math::GradFunctor1D*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GradFunctor1D G__TROOTcLcLMathcLcLGradFunctor1D;
static int G__G__MathCore_191_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GradFunctor1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GradFunctor1D*) (soff+(sizeof(ROOT::Math::GradFunctor1D)*i)))->~G__TROOTcLcLMathcLcLGradFunctor1D();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GradFunctor1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GradFunctor1D*) (soff))->~G__TROOTcLcLMathcLcLGradFunctor1D();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IOptions */
static int G__G__MathCore_193_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const ROOT::Math::IOptions*) G__getstructoffset())->Clone());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_193_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IOptions*) G__getstructoffset())->SetValue((const char*) G__int(libp->para[0]), (double) G__double(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_193_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IOptions*) G__getstructoffset())->SetValue((const char*) G__int(libp->para[0]), (int) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_193_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IOptions*) G__getstructoffset())->SetValue((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_193_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IOptions*) G__getstructoffset())->RValue((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_193_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::IOptions*) G__getstructoffset())->IValue((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_193_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::IOptions*) G__getstructoffset())->NamedValue((const char*) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_193_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::IOptions*) G__getstructoffset())->GetRealValue((const char*) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_193_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::IOptions*) G__getstructoffset())->GetIntValue((const char*) G__int(libp->para[0]), *(int*) G__Intref(&libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_193_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::IOptions*) G__getstructoffset())->GetNamedValue((const char*) G__int(libp->para[0]), *(string*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_193_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IOptions*) G__getstructoffset())->SetRealValue((const char*) G__int(libp->para[0]), (double) G__double(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_193_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IOptions*) G__getstructoffset())->SetIntValue((const char*) G__int(libp->para[0]), (int) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_193_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IOptions*) G__getstructoffset())->SetNamedValue((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_193_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((const ROOT::Math::IOptions*) G__getstructoffset())->Print(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((const ROOT::Math::IOptions*) G__getstructoffset())->Print();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IOptions G__TROOTcLcLMathcLcLIOptions;
static int G__G__MathCore_193_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IOptions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IOptions*) (soff+(sizeof(ROOT::Math::IOptions)*i)))->~G__TROOTcLcLMathcLcLIOptions();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IOptions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IOptions*) (soff))->~G__TROOTcLcLMathcLcLIOptions();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_193_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IOptions* dest = (ROOT::Math::IOptions*) G__getstructoffset();
   *dest = *(ROOT::Math::IOptions*) libp->para[0].ref;
   const ROOT::Math::IOptions& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::MinimizerOptions */
static int G__G__MathCore_194_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ROOT::Math::MinimizerOptions::SetDefaultMinimizer((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ROOT::Math::MinimizerOptions::SetDefaultMinimizer((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::MinimizerOptions::SetDefaultErrorDef((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::MinimizerOptions::SetDefaultTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::MinimizerOptions::SetDefaultPrecision((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::MinimizerOptions::SetDefaultMaxIterations((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::MinimizerOptions::SetDefaultStrategy((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::MinimizerOptions::SetDefaultPrintLevel((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = ROOT::Math::MinimizerOptions::DefaultMinimizerType();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::MinimizerOptions::DefaultErrorDef());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::MinimizerOptions::DefaultTolerance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::MinimizerOptions::DefaultPrecision());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ROOT::Math::MinimizerOptions::DefaultMaxFunctionCalls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ROOT::Math::MinimizerOptions::DefaultMaxIterations());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ROOT::Math::MinimizerOptions::DefaultStrategy());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ROOT::Math::MinimizerOptions::DefaultPrintLevel());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::IOptions& obj = ROOT::Math::MinimizerOptions::Default((const char*) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::Math::MinimizerOptions::FindDefault((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ROOT::Math::MinimizerOptions::PrintDefault((const char*) G__int(libp->para[0]), *(ostream*) libp->para[1].ref);
      G__setnull(result7);
      break;
   case 1:
      ROOT::Math::MinimizerOptions::PrintDefault((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ROOT::Math::MinimizerOptions::PrintDefault();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::MinimizerOptions* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::MinimizerOptions((ROOT::Math::IOptions*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::MinimizerOptions((ROOT::Math::IOptions*) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::MinimizerOptions[n];
       } else {
         p = new((void*) gvp) ROOT::Math::MinimizerOptions[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::MinimizerOptions;
       } else {
         p = new((void*) gvp) ROOT::Math::MinimizerOptions;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::MinimizerOptions* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::MinimizerOptions(*(ROOT::Math::MinimizerOptions*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::MinimizerOptions(*(ROOT::Math::MinimizerOptions*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::MinimizerOptions& obj = ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->operator=(*(ROOT::Math::MinimizerOptions*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->PrintLevel());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->MaxFunctionCalls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->MaxIterations());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->Strategy());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->Tolerance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->Precision());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->ErrorDef());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->ExtraOptions());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->MinimizerType();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->MinimizerAlgorithm();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->Print(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->Print();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetPrintLevel((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetMaxFunctionCalls((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetMaxIterations((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetPrecision((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetStrategy((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetErrorDef((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetMinimizerType((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetMinimizerAlgorithm((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_194_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetExtraOptions(*(ROOT::Math::IOptions*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::MinimizerOptions G__TROOTcLcLMathcLcLMinimizerOptions;
static int G__G__MathCore_194_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::MinimizerOptions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::MinimizerOptions*) (soff+(sizeof(ROOT::Math::MinimizerOptions)*i)))->~G__TROOTcLcLMathcLcLMinimizerOptions();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::MinimizerOptions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::MinimizerOptions*) (soff))->~G__TROOTcLcLMathcLcLMinimizerOptions();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Minimizer */
static int G__G__MathCore_195_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->Clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetFunction(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetFunction(*(ROOT::Math::IMultiGradFunction*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->SetVariable((unsigned int) G__int(libp->para[0]), *(string*) libp->para[1].ref
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->SetLowerLimitedVariable((unsigned int) G__int(libp->para[0]), *(string*) libp->para[1].ref
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->SetUpperLimitedVariable((unsigned int) G__int(libp->para[0]), *(string*) libp->para[1].ref
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->SetLimitedVariable((unsigned int) G__int(libp->para[0]), *(string*) libp->para[1].ref
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->SetFixedVariable((unsigned int) G__int(libp->para[0]), *(string*) libp->para[1].ref
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->SetVariableValue((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->SetVariableValues((double*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->Minimize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->MinValue());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->Edm());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->X());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->MinGradient());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->NCalls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->NDim());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->NFree());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->ProvidesError());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->Errors());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->CovMatrix((unsigned int) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->CovMatrixStatus());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->Correlation((unsigned int) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->GlobalCC((unsigned int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->GetMinosError((unsigned int) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), (int) G__int(libp->para[3])));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->GetMinosError((unsigned int) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->Hesse());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 6:
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->Scan((unsigned int) G__int(libp->para[0]), *(unsigned int*) G__UIntref(&libp->para[1])
, (double*) G__int(libp->para[2]), (double*) G__int(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])));
      break;
   case 5:
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->Scan((unsigned int) G__int(libp->para[0]), *(unsigned int*) G__UIntref(&libp->para[1])
, (double*) G__int(libp->para[2]), (double*) G__int(libp->para[3])
, (double) G__double(libp->para[4])));
      break;
   case 4:
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->Scan((unsigned int) G__int(libp->para[0]), *(unsigned int*) G__UIntref(&libp->para[1])
, (double*) G__int(libp->para[2]), (double*) G__int(libp->para[3])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->Contour((unsigned int) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, *(unsigned int*) G__UIntref(&libp->para[2]), (double*) G__int(libp->para[3])
, (double*) G__int(libp->para[4])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->PrintResults();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::Minimizer*) G__getstructoffset())->VariableName((unsigned int) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->VariableIndex(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->PrintLevel());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->MaxFunctionCalls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->MaxIterations());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->Tolerance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->Precision());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->Strategy());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->Status());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->ErrorDef());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->IsValidError());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::MinimizerOptions* pobj;
         const ROOT::Math::MinimizerOptions xobj = ((const ROOT::Math::Minimizer*) G__getstructoffset())->Options();
         pobj = new ROOT::Math::MinimizerOptions(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetPrintLevel((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetMaxFunctionCalls((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetMaxIterations((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetPrecision((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetStrategy((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetErrorDef((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetValidError((bool) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_53(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetOptions(*(ROOT::Math::MinimizerOptions*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_195_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetDefaultOptions();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Minimizer G__TROOTcLcLMathcLcLMinimizer;
static int G__G__MathCore_195_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Minimizer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Minimizer*) (soff+(sizeof(ROOT::Math::Minimizer)*i)))->~G__TROOTcLcLMathcLcLMinimizer();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Minimizer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Minimizer*) (soff))->~G__TROOTcLcLMathcLcLMinimizer();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IntegrationOneDim */

/* ROOT::Math::IntegrationMultiDim */

/* ROOT::Math::BaseIntegratorOptions */
static int G__G__MathCore_200_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::BaseIntegratorOptions& obj = ((ROOT::Math::BaseIntegratorOptions*) G__getstructoffset())->operator=(*(ROOT::Math::BaseIntegratorOptions*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_200_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::BaseIntegratorOptions*) G__getstructoffset())->Integrator();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_200_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::BaseIntegratorOptions*) G__getstructoffset())->AbsTolerance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_200_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::BaseIntegratorOptions*) G__getstructoffset())->RelTolerance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_200_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::BaseIntegratorOptions*) G__getstructoffset())->WKSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_200_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const ROOT::Math::BaseIntegratorOptions*) G__getstructoffset())->ExtraOptions());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_200_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::BaseIntegratorOptions*) G__getstructoffset())->SetAbsTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_200_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::BaseIntegratorOptions*) G__getstructoffset())->SetRelTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_200_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::BaseIntegratorOptions*) G__getstructoffset())->SetWKSize((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_200_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::BaseIntegratorOptions*) G__getstructoffset())->SetExtraOptions(*(ROOT::Math::IOptions*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::BaseIntegratorOptions G__TROOTcLcLMathcLcLBaseIntegratorOptions;
static int G__G__MathCore_200_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::BaseIntegratorOptions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::BaseIntegratorOptions*) (soff+(sizeof(ROOT::Math::BaseIntegratorOptions)*i)))->~G__TROOTcLcLMathcLcLBaseIntegratorOptions();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::BaseIntegratorOptions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::BaseIntegratorOptions*) (soff))->~G__TROOTcLcLMathcLcLBaseIntegratorOptions();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IntegratorOneDimOptions */
static int G__G__MathCore_201_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IntegratorOneDimOptions* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDimOptions((ROOT::Math::IOptions*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDimOptions((ROOT::Math::IOptions*) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::IntegratorOneDimOptions[n];
       } else {
         p = new((void*) gvp) ROOT::Math::IntegratorOneDimOptions[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::IntegratorOneDimOptions;
       } else {
         p = new((void*) gvp) ROOT::Math::IntegratorOneDimOptions;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IntegratorOneDimOptions* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::IntegratorOneDimOptions(*(ROOT::Math::IntegratorOneDimOptions*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::IntegratorOneDimOptions(*(ROOT::Math::IntegratorOneDimOptions*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::IntegratorOneDimOptions& obj = ((ROOT::Math::IntegratorOneDimOptions*) G__getstructoffset())->operator=(*(ROOT::Math::IntegratorOneDimOptions*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorOneDimOptions*) G__getstructoffset())->SetNPoints((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::IntegratorOneDimOptions*) G__getstructoffset())->NPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::IntegratorOneDimOptions*) G__getstructoffset())->IntegratorType());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorOneDimOptions*) G__getstructoffset())->SetIntegrator((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((const ROOT::Math::IntegratorOneDimOptions*) G__getstructoffset())->Print(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((const ROOT::Math::IntegratorOneDimOptions*) G__getstructoffset())->Print();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::IntegratorOneDimOptions::SetDefaultWKSize((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::IntegratorOneDimOptions::SetDefaultNPoints((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ROOT::Math::IntegratorOneDimOptions::DefaultWKSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ROOT::Math::IntegratorOneDimOptions::DefaultNPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::IOptions& obj = ROOT::Math::IntegratorOneDimOptions::Default((const char*) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::Math::IntegratorOneDimOptions::FindDefault((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_201_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ROOT::Math::IntegratorOneDimOptions::PrintDefault((const char*) G__int(libp->para[0]), *(ostream*) libp->para[1].ref);
      G__setnull(result7);
      break;
   case 1:
      ROOT::Math::IntegratorOneDimOptions::PrintDefault((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ROOT::Math::IntegratorOneDimOptions::PrintDefault();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IntegratorOneDimOptions G__TROOTcLcLMathcLcLIntegratorOneDimOptions;
static int G__G__MathCore_201_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IntegratorOneDimOptions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IntegratorOneDimOptions*) (soff+(sizeof(ROOT::Math::IntegratorOneDimOptions)*i)))->~G__TROOTcLcLMathcLcLIntegratorOneDimOptions();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IntegratorOneDimOptions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IntegratorOneDimOptions*) (soff))->~G__TROOTcLcLMathcLcLIntegratorOneDimOptions();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IntegratorMultiDimOptions */
static int G__G__MathCore_202_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IntegratorMultiDimOptions* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDimOptions((ROOT::Math::IOptions*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDimOptions((ROOT::Math::IOptions*) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::IntegratorMultiDimOptions[n];
       } else {
         p = new((void*) gvp) ROOT::Math::IntegratorMultiDimOptions[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::IntegratorMultiDimOptions;
       } else {
         p = new((void*) gvp) ROOT::Math::IntegratorMultiDimOptions;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IntegratorMultiDimOptions* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::IntegratorMultiDimOptions(*(ROOT::Math::IntegratorMultiDimOptions*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::IntegratorMultiDimOptions(*(ROOT::Math::IntegratorMultiDimOptions*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::IntegratorMultiDimOptions& obj = ((ROOT::Math::IntegratorMultiDimOptions*) G__getstructoffset())->operator=(*(ROOT::Math::IntegratorMultiDimOptions*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorMultiDimOptions*) G__getstructoffset())->SetNCalls((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::IntegratorMultiDimOptions*) G__getstructoffset())->NCalls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::IntegratorMultiDimOptions*) G__getstructoffset())->IntegratorType());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorMultiDimOptions*) G__getstructoffset())->SetIntegrator((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((const ROOT::Math::IntegratorMultiDimOptions*) G__getstructoffset())->Print(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((const ROOT::Math::IntegratorMultiDimOptions*) G__getstructoffset())->Print();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::IntegratorMultiDimOptions::SetDefaultAbsTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::IntegratorMultiDimOptions::SetDefaultRelTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::IntegratorMultiDimOptions::SetDefaultWKSize((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::IntegratorMultiDimOptions::SetDefaultNCalls((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = ROOT::Math::IntegratorMultiDimOptions::DefaultIntegrator();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ROOT::Math::IntegratorMultiDimOptions::DefaultWKSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::IOptions& obj = ROOT::Math::IntegratorMultiDimOptions::Default((const char*) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::Math::IntegratorMultiDimOptions::FindDefault((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_202_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ROOT::Math::IntegratorMultiDimOptions::PrintDefault((const char*) G__int(libp->para[0]), *(ostream*) libp->para[1].ref);
      G__setnull(result7);
      break;
   case 1:
      ROOT::Math::IntegratorMultiDimOptions::PrintDefault((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ROOT::Math::IntegratorMultiDimOptions::PrintDefault();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IntegratorMultiDimOptions G__TROOTcLcLMathcLcLIntegratorMultiDimOptions;
static int G__G__MathCore_202_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IntegratorMultiDimOptions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IntegratorMultiDimOptions*) (soff+(sizeof(ROOT::Math::IntegratorMultiDimOptions)*i)))->~G__TROOTcLcLMathcLcLIntegratorMultiDimOptions();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IntegratorMultiDimOptions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IntegratorMultiDimOptions*) (soff))->~G__TROOTcLcLMathcLcLIntegratorMultiDimOptions();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::VirtualIntegrator */
static int G__G__MathCore_203_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::VirtualIntegrator*) G__getstructoffset())->SetRelTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_203_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::VirtualIntegrator*) G__getstructoffset())->SetAbsTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_203_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::VirtualIntegrator*) G__getstructoffset())->Result());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_203_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::VirtualIntegrator*) G__getstructoffset())->Error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_203_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::VirtualIntegrator*) G__getstructoffset())->Status());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_203_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::VirtualIntegrator*) G__getstructoffset())->NEval());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::VirtualIntegrator G__TROOTcLcLMathcLcLVirtualIntegrator;
static int G__G__MathCore_203_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::VirtualIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::VirtualIntegrator*) (soff+(sizeof(ROOT::Math::VirtualIntegrator)*i)))->~G__TROOTcLcLMathcLcLVirtualIntegrator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::VirtualIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::VirtualIntegrator*) (soff))->~G__TROOTcLcLMathcLcLVirtualIntegrator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_203_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VirtualIntegrator* dest = (ROOT::Math::VirtualIntegrator*) G__getstructoffset();
   *dest = *(ROOT::Math::VirtualIntegrator*) libp->para[0].ref;
   const ROOT::Math::VirtualIntegrator& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::VirtualIntegratorOneDim */
static int G__G__MathCore_204_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->Integral((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_204_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_204_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->Integral());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_204_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->IntegralUp((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_204_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->IntegralLow((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_204_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->Integral(*(vector<double>*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_204_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->IntegralCauchy((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_204_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::IntegratorOneDimOptions* pobj;
         const ROOT::Math::IntegratorOneDimOptions xobj = ((const ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->Options();
         pobj = new ROOT::Math::IntegratorOneDimOptions(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_204_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->Type());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_204_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->SetOptions(*(ROOT::Math::IntegratorOneDimOptions*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::VirtualIntegratorOneDim G__TROOTcLcLMathcLcLVirtualIntegratorOneDim;
static int G__G__MathCore_204_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::VirtualIntegratorOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::VirtualIntegratorOneDim*) (soff+(sizeof(ROOT::Math::VirtualIntegratorOneDim)*i)))->~G__TROOTcLcLMathcLcLVirtualIntegratorOneDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::VirtualIntegratorOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::VirtualIntegratorOneDim*) (soff))->~G__TROOTcLcLMathcLcLVirtualIntegratorOneDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_204_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VirtualIntegratorOneDim* dest = (ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset();
   *dest = *(ROOT::Math::VirtualIntegratorOneDim*) libp->para[0].ref;
   const ROOT::Math::VirtualIntegratorOneDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::VirtualIntegratorMultiDim */
static int G__G__MathCore_205_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::VirtualIntegratorMultiDim*) G__getstructoffset())->Integral((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_205_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::VirtualIntegratorMultiDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_205_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::IntegratorMultiDimOptions* pobj;
         const ROOT::Math::IntegratorMultiDimOptions xobj = ((const ROOT::Math::VirtualIntegratorMultiDim*) G__getstructoffset())->Options();
         pobj = new ROOT::Math::IntegratorMultiDimOptions(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_205_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::VirtualIntegratorMultiDim*) G__getstructoffset())->Type());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_205_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::VirtualIntegratorMultiDim*) G__getstructoffset())->SetOptions(*(ROOT::Math::IntegratorMultiDimOptions*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::VirtualIntegratorMultiDim G__TROOTcLcLMathcLcLVirtualIntegratorMultiDim;
static int G__G__MathCore_205_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::VirtualIntegratorMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::VirtualIntegratorMultiDim*) (soff+(sizeof(ROOT::Math::VirtualIntegratorMultiDim)*i)))->~G__TROOTcLcLMathcLcLVirtualIntegratorMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::VirtualIntegratorMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::VirtualIntegratorMultiDim*) (soff))->~G__TROOTcLcLMathcLcLVirtualIntegratorMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_205_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VirtualIntegratorMultiDim* dest = (ROOT::Math::VirtualIntegratorMultiDim*) G__getstructoffset();
   *dest = *(ROOT::Math::VirtualIntegratorMultiDim*) libp->para[0].ref;
   const ROOT::Math::VirtualIntegratorMultiDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IntegratorOneDim */
static int G__G__MathCore_206_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IntegratorOneDim* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(
(ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3])
, (unsigned int) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(
(ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3])
, (unsigned int) G__int(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(
(ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(
(ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(
(ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(
(ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim((ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim((ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim((ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim((ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::IntegratorOneDim[n];
       } else {
         p = new((void*) gvp) ROOT::Math::IntegratorOneDim[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::IntegratorOneDim;
       } else {
         p = new((void*) gvp) ROOT::Math::IntegratorOneDim;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IntegratorOneDim* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 6:
     //m: 6
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (unsigned int) G__int(libp->para[4]), (int) G__int(libp->para[5]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (unsigned int) G__int(libp->para[4]), (int) G__int(libp->para[5]));
     }
     break;
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (unsigned int) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (unsigned int) G__int(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (bool) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (unsigned int) G__int(libp->para[1])
, (double*) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Integral(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Integral(*(ROOT::Math::IGenFunction*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->IntegralUp(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->IntegralLow(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Integral(*(ROOT::Math::IGenFunction*) libp->para[0].ref, *(vector<double>*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->IntegralCauchy(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Integral((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Integral());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->IntegralUp((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->IntegralLow((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->operator()((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Integral(*(vector<double>*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->IntegralCauchy((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Result());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Status());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::IntegratorOneDim*) G__getstructoffset())->NEval());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->SetRelTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->SetAbsTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->GetIntegrator());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->SetOptions(*(ROOT::Math::IntegratorOneDimOptions*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::IntegratorOneDimOptions* pobj;
         const ROOT::Math::IntegratorOneDimOptions xobj = ((const ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Options();
         pobj = new ROOT::Math::IntegratorOneDimOptions(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Name();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ROOT::Math::IntegratorOneDim::GetType((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_206_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = ROOT::Math::IntegratorOneDim::GetName((ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IntegratorOneDim G__TROOTcLcLMathcLcLIntegratorOneDim;
static int G__G__MathCore_206_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IntegratorOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IntegratorOneDim*) (soff+(sizeof(ROOT::Math::IntegratorOneDim)*i)))->~G__TROOTcLcLMathcLcLIntegratorOneDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IntegratorOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IntegratorOneDim*) (soff))->~G__TROOTcLcLMathcLcLIntegratorOneDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::AdaptiveIntegratorMultiDim */
static int G__G__MathCore_207_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::AdaptiveIntegratorMultiDim* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (unsigned int) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (unsigned int) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (unsigned int) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (unsigned int) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim((double) G__double(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim((double) G__double(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::AdaptiveIntegratorMultiDim[n];
       } else {
         p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::AdaptiveIntegratorMultiDim;
       } else {
         p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_207_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::AdaptiveIntegratorMultiDim* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3])
, (unsigned int) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3])
, (unsigned int) G__int(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_207_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::AdaptiveIntegratorMultiDim*) G__getstructoffset())->Integral(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_207_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::AdaptiveIntegratorMultiDim*) G__getstructoffset())->RelError());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_207_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::AdaptiveIntegratorMultiDim*) G__getstructoffset())->SetSize((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_207_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::AdaptiveIntegratorMultiDim*) G__getstructoffset())->SetMinPts((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_207_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::AdaptiveIntegratorMultiDim*) G__getstructoffset())->SetMaxPts((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_207_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::AdaptiveIntegratorMultiDim* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::AdaptiveIntegratorMultiDim(*(ROOT::Math::AdaptiveIntegratorMultiDim*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::AdaptiveIntegratorMultiDim G__TROOTcLcLMathcLcLAdaptiveIntegratorMultiDim;
static int G__G__MathCore_207_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::AdaptiveIntegratorMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::AdaptiveIntegratorMultiDim*) (soff+(sizeof(ROOT::Math::AdaptiveIntegratorMultiDim)*i)))->~G__TROOTcLcLMathcLcLAdaptiveIntegratorMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::AdaptiveIntegratorMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::AdaptiveIntegratorMultiDim*) (soff))->~G__TROOTcLcLMathcLcLAdaptiveIntegratorMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IntegratorMultiDim */
static int G__G__MathCore_208_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IntegratorMultiDim* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim(
(ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim(
(ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim(
(ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim(
(ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim((ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim((ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim((ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim((ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::IntegratorMultiDim[n];
       } else {
         p = new((void*) gvp) ROOT::Math::IntegratorMultiDim[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::IntegratorMultiDim;
       } else {
         p = new((void*) gvp) ROOT::Math::IntegratorMultiDim;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IntegratorMultiDim* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (unsigned int) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (unsigned int) G__int(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->Integral((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->Integral(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->Result());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->Error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->Status());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->SetRelTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->SetAbsTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->SetOptions(*(ROOT::Math::IntegratorMultiDimOptions*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::IntegratorMultiDimOptions* pobj;
         const ROOT::Math::IntegratorMultiDimOptions xobj = ((const ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->Options();
         pobj = new ROOT::Math::IntegratorMultiDimOptions(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->GetIntegrator());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->Name();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ROOT::Math::IntegratorMultiDim::GetType((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_208_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = ROOT::Math::IntegratorMultiDim::GetName((ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IntegratorMultiDim G__TROOTcLcLMathcLcLIntegratorMultiDim;
static int G__G__MathCore_208_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IntegratorMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IntegratorMultiDim*) (soff+(sizeof(ROOT::Math::IntegratorMultiDim)*i)))->~G__TROOTcLcLMathcLcLIntegratorMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IntegratorMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IntegratorMultiDim*) (soff))->~G__TROOTcLcLMathcLcLIntegratorMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::DistSampler */
static int G__G__MathCore_209_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::DistSampler*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::DistSampler*) G__getstructoffset())->SetFunction(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::DistSampler*) G__getstructoffset())->NDim());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 103, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->Init((const char*) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 103, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->Init());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->Init(*(ROOT::Math::DistSamplerOptions*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::DistSampler*) G__getstructoffset())->SetRandom((TRandom*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::DistSampler*) G__getstructoffset())->SetSeed((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->GetRandom());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((ROOT::Math::DistSampler*) G__getstructoffset())->SetRange((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (int) G__int(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::DistSampler*) G__getstructoffset())->SetRange((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::DistSampler*) G__getstructoffset())->SetRange((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::DistSampler*) G__getstructoffset())->SetRange(*(ROOT::Fit::DataRange*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::DistSampler*) G__getstructoffset())->SetMode((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::DistSampler*) G__getstructoffset())->SetArea((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::IMultiGenFunction& obj = ((const ROOT::Math::DistSampler*) G__getstructoffset())->ParentPdf();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::DistSampler*) G__getstructoffset())->Sample1D());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->Sample());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->Sample((double*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->SampleBin((double) G__double(libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, (double*) G__int(libp->para[2])));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->SampleBin((double) G__double(libp->para[0]), *(double*) G__Doubleref(&libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->SampleBins((unsigned int) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]), (double*) G__int(libp->para[3])));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->SampleBins((unsigned int) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->Generate((unsigned int) G__int(libp->para[0]), *(ROOT::Fit::UnBinData*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->Generate((unsigned int) G__int(libp->para[0]), (const int*) G__int(libp->para[1])
, *(ROOT::Fit::BinData*) libp->para[2].ref, (bool) G__int(libp->para[3])));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->Generate((unsigned int) G__int(libp->para[0]), (const int*) G__int(libp->para[1])
, *(ROOT::Fit::BinData*) libp->para[2].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_209_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 6:
      G__letint(result7, 103, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->Generate((unsigned int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, *(ROOT::Fit::BinData*) libp->para[4].ref, (bool) G__int(libp->para[5])));
      break;
   case 5:
      G__letint(result7, 103, (long) ((ROOT::Math::DistSampler*) G__getstructoffset())->Generate((unsigned int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, *(ROOT::Fit::BinData*) libp->para[4].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::DistSampler G__TROOTcLcLMathcLcLDistSampler;
static int G__G__MathCore_209_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::DistSampler*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::DistSampler*) (soff+(sizeof(ROOT::Math::DistSampler)*i)))->~G__TROOTcLcLMathcLcLDistSampler();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::DistSampler*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::DistSampler*) (soff))->~G__TROOTcLcLMathcLcLDistSampler();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Factory */
static int G__G__MathCore_210_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 85, (long) ROOT::Math::Factory::CreateMinimizer(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   case 1:
      G__letint(result7, 85, (long) ROOT::Math::Factory::CreateMinimizer(*(string*) libp->para[0].ref));
      break;
   case 0:
      G__letint(result7, 85, (long) ROOT::Math::Factory::CreateMinimizer());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_210_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 85, (long) ROOT::Math::Factory::CreateDistSampler(*(string*) libp->para[0].ref));
      break;
   case 0:
      G__letint(result7, 85, (long) ROOT::Math::Factory::CreateDistSampler());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__G__MathCore_210_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Factory *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Factory[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Factory[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Factory;
     } else {
       p = new((void*) gvp) ROOT::Math::Factory;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_210_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Factory* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Factory(*(ROOT::Math::Factory*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Factory G__TROOTcLcLMathcLcLFactory;
static int G__G__MathCore_210_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Factory*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Factory*) (soff+(sizeof(ROOT::Math::Factory)*i)))->~G__TROOTcLcLMathcLcLFactory();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Factory*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Factory*) (soff))->~G__TROOTcLcLMathcLcLFactory();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_210_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Factory* dest = (ROOT::Math::Factory*) G__getstructoffset();
   const ROOT::Math::Factory& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> */
static int G__G__MathCore_211_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset())->DataElement((double*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (double*) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset())->DataElement((double*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_211_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset())->NPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_211_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset())->Type());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_211_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset())->NCalls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_211_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset())->UpdateNCalls();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_211_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset())->ResetNCalls();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> G__TROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR;
static int G__G__MathCore_211_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) (soff+(sizeof(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>)*i)))->~G__TROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) (soff))->~G__TROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_211_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>* dest = (ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset();
   *dest = *(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) libp->para[0].ref;
   const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> */
static int G__G__MathCore_213_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset())->DataElement((double*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (double*) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset())->DataElement((double*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_213_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset())->NPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_213_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset())->Type());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_213_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset())->NCalls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_213_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset())->UpdateNCalls();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_213_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset())->ResetNCalls();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> G__TROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR;
static int G__G__MathCore_213_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) (soff+(sizeof(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>)*i)))->~G__TROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) (soff))->~G__TROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_213_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>* dest = (ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset();
   *dest = *(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) libp->para[0].ref;
   const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GaussIntegrator */
static int G__G__MathCore_215_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GaussIntegrator* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GaussIntegrator((double) G__double(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::GaussIntegrator((double) G__double(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GaussIntegrator[n];
       } else {
         p = new((void*) gvp) ROOT::Math::GaussIntegrator[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GaussIntegrator;
       } else {
         p = new((void*) gvp) ROOT::Math::GaussIntegrator;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_215_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GaussIntegrator*) G__getstructoffset())->AbsValue((bool) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_215_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GaussIntegrator* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GaussIntegrator(*(ROOT::Math::GaussIntegrator*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GaussIntegrator G__TROOTcLcLMathcLcLGaussIntegrator;
static int G__G__MathCore_215_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GaussIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GaussIntegrator*) (soff+(sizeof(ROOT::Math::GaussIntegrator)*i)))->~G__TROOTcLcLMathcLcLGaussIntegrator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GaussIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GaussIntegrator*) (soff))->~G__TROOTcLcLMathcLcLGaussIntegrator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GaussLegendreIntegrator */
static int G__G__MathCore_218_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GaussLegendreIntegrator* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GaussLegendreIntegrator((int) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::GaussLegendreIntegrator((int) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GaussLegendreIntegrator((int) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::GaussLegendreIntegrator((int) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GaussLegendreIntegrator[n];
       } else {
         p = new((void*) gvp) ROOT::Math::GaussLegendreIntegrator[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GaussLegendreIntegrator;
       } else {
         p = new((void*) gvp) ROOT::Math::GaussLegendreIntegrator;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_218_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GaussLegendreIntegrator*) G__getstructoffset())->SetNumberPoints((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_218_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::GaussLegendreIntegrator*) G__getstructoffset())->GetWeightVectors((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_218_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::GaussLegendreIntegrator*) G__getstructoffset())->GetNumberPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_218_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GaussLegendreIntegrator* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GaussLegendreIntegrator(*(ROOT::Math::GaussLegendreIntegrator*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GaussLegendreIntegrator G__TROOTcLcLMathcLcLGaussLegendreIntegrator;
static int G__G__MathCore_218_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GaussLegendreIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GaussLegendreIntegrator*) (soff+(sizeof(ROOT::Math::GaussLegendreIntegrator)*i)))->~G__TROOTcLcLMathcLcLGaussLegendreIntegrator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GaussLegendreIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GaussLegendreIntegrator*) (soff))->~G__TROOTcLcLMathcLcLGaussLegendreIntegrator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IRootFinderMethod */
static int G__G__MathCore_219_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::IRootFinderMethod*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGradFunction*) libp->para[0].ref, (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_219_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::IRootFinderMethod*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_219_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Root());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_219_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Status());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_219_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Solve((int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Solve((int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 103, (long) ((ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Solve((int) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 103, (long) ((ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Solve());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_219_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_219_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Iterate());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_219_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Iterations());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IRootFinderMethod G__TROOTcLcLMathcLcLIRootFinderMethod;
static int G__G__MathCore_219_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IRootFinderMethod*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IRootFinderMethod*) (soff+(sizeof(ROOT::Math::IRootFinderMethod)*i)))->~G__TROOTcLcLMathcLcLIRootFinderMethod();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IRootFinderMethod*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IRootFinderMethod*) (soff))->~G__TROOTcLcLMathcLcLIRootFinderMethod();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_219_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IRootFinderMethod* dest = (ROOT::Math::IRootFinderMethod*) G__getstructoffset();
   *dest = *(ROOT::Math::IRootFinderMethod*) libp->para[0].ref;
   const ROOT::Math::IRootFinderMethod& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::RootFinder */
static int G__G__MathCore_220_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::RootFinder* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::RootFinder((ROOT::Math::RootFinder::EType) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::RootFinder((ROOT::Math::RootFinder::EType) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::RootFinder[n];
       } else {
         p = new((void*) gvp) ROOT::Math::RootFinder[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::RootFinder;
       } else {
         p = new((void*) gvp) ROOT::Math::RootFinder;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_220_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 103, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->SetMethod((ROOT::Math::RootFinder::EType) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 103, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->SetMethod());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_220_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_220_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGradFunction*) libp->para[0].ref, (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_220_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->Solve((int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->Solve((int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 103, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->Solve((int) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 103, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->Solve());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_220_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::RootFinder*) G__getstructoffset())->Iterations());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_220_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->Iterate());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_220_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::RootFinder*) G__getstructoffset())->Root());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_220_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::RootFinder*) G__getstructoffset())->Status());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_220_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const ROOT::Math::RootFinder*) G__getstructoffset())->Name());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::RootFinder G__TROOTcLcLMathcLcLRootFinder;
static int G__G__MathCore_220_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::RootFinder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::RootFinder*) (soff+(sizeof(ROOT::Math::RootFinder)*i)))->~G__TROOTcLcLMathcLcLRootFinder();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::RootFinder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::RootFinder*) (soff))->~G__TROOTcLcLMathcLcLRootFinder();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::RichardsonDerivator */
static int G__G__MathCore_224_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::RichardsonDerivator* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::RichardsonDerivator((double) G__double(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::RichardsonDerivator((double) G__double(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::RichardsonDerivator[n];
       } else {
         p = new((void*) gvp) ROOT::Math::RichardsonDerivator[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::RichardsonDerivator;
       } else {
         p = new((void*) gvp) ROOT::Math::RichardsonDerivator;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_224_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::RichardsonDerivator* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::RichardsonDerivator(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (bool) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::RichardsonDerivator(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (bool) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::RichardsonDerivator(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::RichardsonDerivator(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::RichardsonDerivator(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) ROOT::Math::RichardsonDerivator(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_224_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::RichardsonDerivator* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::RichardsonDerivator(*(ROOT::Math::RichardsonDerivator*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::RichardsonDerivator(*(ROOT::Math::RichardsonDerivator*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_224_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::RichardsonDerivator& obj = ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->operator=(*(ROOT::Math::RichardsonDerivator*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_224_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::RichardsonDerivator*) G__getstructoffset())->Error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_224_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->Derivative1((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_224_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->operator()((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_224_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->Derivative1(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_224_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->Derivative2((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_224_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->Derivative2(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_224_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->Derivative3((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_224_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->Derivative3(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_224_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_224_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->SetStepSize((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::RichardsonDerivator G__TROOTcLcLMathcLcLRichardsonDerivator;
static int G__G__MathCore_224_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::RichardsonDerivator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::RichardsonDerivator*) (soff+(sizeof(ROOT::Math::RichardsonDerivator)*i)))->~G__TROOTcLcLMathcLcLRichardsonDerivator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::RichardsonDerivator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::RichardsonDerivator*) (soff))->~G__TROOTcLcLMathcLcLRichardsonDerivator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IMinimizer1D */
static int G__G__MathCore_226_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IMinimizer1D*) G__getstructoffset())->XMinimum());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_226_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IMinimizer1D*) G__getstructoffset())->XLower());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_226_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IMinimizer1D*) G__getstructoffset())->XUpper());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_226_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IMinimizer1D*) G__getstructoffset())->FValMinimum());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_226_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IMinimizer1D*) G__getstructoffset())->FValLower());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_226_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IMinimizer1D*) G__getstructoffset())->FValUpper());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_226_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::IMinimizer1D*) G__getstructoffset())->Minimize((int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_226_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::IMinimizer1D*) G__getstructoffset())->Iterations());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_226_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const ROOT::Math::IMinimizer1D*) G__getstructoffset())->Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_226_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::IMinimizer1D*) G__getstructoffset())->Status());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IMinimizer1D G__TROOTcLcLMathcLcLIMinimizer1D;
static int G__G__MathCore_226_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IMinimizer1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IMinimizer1D*) (soff+(sizeof(ROOT::Math::IMinimizer1D)*i)))->~G__TROOTcLcLMathcLcLIMinimizer1D();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IMinimizer1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IMinimizer1D*) (soff))->~G__TROOTcLcLMathcLcLIMinimizer1D();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_226_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IMinimizer1D* dest = (ROOT::Math::IMinimizer1D*) G__getstructoffset();
   *dest = *(ROOT::Math::IMinimizer1D*) libp->para[0].ref;
   const ROOT::Math::IMinimizer1D& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::BrentMinimizer1D */
static int G__G__MathCore_227_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::BrentMinimizer1D* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::BrentMinimizer1D[n];
     } else {
       p = new((void*) gvp) ROOT::Math::BrentMinimizer1D[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::BrentMinimizer1D;
     } else {
       p = new((void*) gvp) ROOT::Math::BrentMinimizer1D;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_227_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ROOT::Math::BrentMinimizer1D*) G__getstructoffset())->Minimize((int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ROOT::Math::BrentMinimizer1D*) G__getstructoffset())->Minimize((int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 103, (long) ((ROOT::Math::BrentMinimizer1D*) G__getstructoffset())->Minimize((int) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_227_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::BrentMinimizer1D*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_227_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::BrentMinimizer1D*) G__getstructoffset())->SetNpx((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_227_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::BrentMinimizer1D*) G__getstructoffset())->SetLogScan((bool) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_227_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::BrentMinimizer1D::SetDefaultNpx((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_227_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::BrentMinimizer1D::SetDefaultNSearch((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_227_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::BrentMinimizer1D* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::BrentMinimizer1D(*(ROOT::Math::BrentMinimizer1D*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::BrentMinimizer1D G__TROOTcLcLMathcLcLBrentMinimizer1D;
static int G__G__MathCore_227_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::BrentMinimizer1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::BrentMinimizer1D*) (soff+(sizeof(ROOT::Math::BrentMinimizer1D)*i)))->~G__TROOTcLcLMathcLcLBrentMinimizer1D();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::BrentMinimizer1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::BrentMinimizer1D*) (soff))->~G__TROOTcLcLMathcLcLBrentMinimizer1D();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::BrentRootFinder */
static int G__G__MathCore_228_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::BrentRootFinder* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::BrentRootFinder[n];
     } else {
       p = new((void*) gvp) ROOT::Math::BrentRootFinder[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::BrentRootFinder;
     } else {
       p = new((void*) gvp) ROOT::Math::BrentRootFinder;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_228_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::BrentRootFinder*) G__getstructoffset())->SetNpx((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_228_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::BrentRootFinder*) G__getstructoffset())->SetLogScan((bool) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_228_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::BrentRootFinder::SetDefaultNpx((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_228_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::BrentRootFinder::SetDefaultNSearch((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_228_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::BrentRootFinder* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::BrentRootFinder(*(ROOT::Math::BrentRootFinder*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::BrentRootFinder G__TROOTcLcLMathcLcLBrentRootFinder;
static int G__G__MathCore_228_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::BrentRootFinder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::BrentRootFinder*) (soff+(sizeof(ROOT::Math::BrentRootFinder)*i)))->~G__TROOTcLcLMathcLcLBrentRootFinder();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::BrentRootFinder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::BrentRootFinder*) (soff))->~G__TROOTcLcLMathcLcLBrentRootFinder();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::DistSamplerOptions */
static int G__G__MathCore_231_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::DistSamplerOptions::SetDefaultSampler((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::DistSamplerOptions::SetDefaultAlgorithm1D((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::DistSamplerOptions::SetDefaultAlgorithmND((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::DistSamplerOptions::SetDefaultPrintLevel((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = ROOT::Math::DistSamplerOptions::DefaultSampler();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = ROOT::Math::DistSamplerOptions::DefaultAlgorithm1D();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = ROOT::Math::DistSamplerOptions::DefaultAlgorithmND();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ROOT::Math::DistSamplerOptions::DefaultPrintLevel());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::IOptions& obj = ROOT::Math::DistSamplerOptions::Default((const char*) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::Math::DistSamplerOptions::FindDefault((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ROOT::Math::DistSamplerOptions::PrintDefault((const char*) G__int(libp->para[0]), *(ostream*) libp->para[1].ref);
      G__setnull(result7);
      break;
   case 1:
      ROOT::Math::DistSamplerOptions::PrintDefault((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ROOT::Math::DistSamplerOptions::PrintDefault();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::DistSamplerOptions* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::DistSamplerOptions((int) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::DistSamplerOptions((int) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::DistSamplerOptions[n];
       } else {
         p = new((void*) gvp) ROOT::Math::DistSamplerOptions[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::DistSamplerOptions;
       } else {
         p = new((void*) gvp) ROOT::Math::DistSamplerOptions;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLDistSamplerOptions));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::DistSamplerOptions* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::DistSamplerOptions(*(ROOT::Math::DistSamplerOptions*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::DistSamplerOptions(*(ROOT::Math::DistSamplerOptions*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLDistSamplerOptions));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::DistSamplerOptions& obj = ((ROOT::Math::DistSamplerOptions*) G__getstructoffset())->operator=(*(ROOT::Math::DistSamplerOptions*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::DistSamplerOptions*) G__getstructoffset())->PrintLevel());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const ROOT::Math::DistSamplerOptions*) G__getstructoffset())->ExtraOptions());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = ((const ROOT::Math::DistSamplerOptions*) G__getstructoffset())->Sampler();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = ((const ROOT::Math::DistSamplerOptions*) G__getstructoffset())->Algorithm();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((const ROOT::Math::DistSamplerOptions*) G__getstructoffset())->Print(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((const ROOT::Math::DistSamplerOptions*) G__getstructoffset())->Print();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::DistSamplerOptions*) G__getstructoffset())->SetPrintLevel((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::DistSamplerOptions*) G__getstructoffset())->SetSampler((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::DistSamplerOptions*) G__getstructoffset())->SetAlgorithm((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_231_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::DistSamplerOptions*) G__getstructoffset())->SetExtraOptions(*(ROOT::Math::IOptions*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::DistSamplerOptions G__TROOTcLcLMathcLcLDistSamplerOptions;
static int G__G__MathCore_231_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::DistSamplerOptions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::DistSamplerOptions*) (soff+(sizeof(ROOT::Math::DistSamplerOptions)*i)))->~G__TROOTcLcLMathcLcLDistSamplerOptions();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::DistSamplerOptions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::DistSamplerOptions*) (soff))->~G__TROOTcLcLMathcLcLDistSamplerOptions();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GoFTest */
static int G__G__MathCore_232_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GoFTest* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 4
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GoFTest(
(UInt_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (Double_t*) G__int(libp->para[3]));
   } else {
     p = new((void*) gvp) ROOT::Math::GoFTest(
(UInt_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (Double_t*) G__int(libp->para[3]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GoFTest* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GoFTest(
(UInt_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])
, (ROOT::Math::GoFTest::EDistribution) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::GoFTest(
(UInt_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])
, (ROOT::Math::GoFTest::EDistribution) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GoFTest((UInt_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::GoFTest((UInt_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GoFTest* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 6:
     //m: 6
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GoFTest(
(UInt_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])
, *(ROOT::Math::IGenFunction*) libp->para[2].ref, (ROOT::Math::GoFTest::EUserDistribution) G__int(libp->para[3])
, (Double_t) G__double(libp->para[4]), (Double_t) G__double(libp->para[5]));
     } else {
       p = new((void*) gvp) ROOT::Math::GoFTest(
(UInt_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])
, *(ROOT::Math::IGenFunction*) libp->para[2].ref, (ROOT::Math::GoFTest::EUserDistribution) G__int(libp->para[3])
, (Double_t) G__double(libp->para[4]), (Double_t) G__double(libp->para[5]));
     }
     break;
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GoFTest(
(UInt_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])
, *(ROOT::Math::IGenFunction*) libp->para[2].ref, (ROOT::Math::GoFTest::EUserDistribution) G__int(libp->para[3])
, (Double_t) G__double(libp->para[4]));
     } else {
       p = new((void*) gvp) ROOT::Math::GoFTest(
(UInt_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])
, *(ROOT::Math::IGenFunction*) libp->para[2].ref, (ROOT::Math::GoFTest::EUserDistribution) G__int(libp->para[3])
, (Double_t) G__double(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GoFTest(
(UInt_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])
, *(ROOT::Math::IGenFunction*) libp->para[2].ref, (ROOT::Math::GoFTest::EUserDistribution) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::GoFTest(
(UInt_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])
, *(ROOT::Math::IGenFunction*) libp->para[2].ref, (ROOT::Math::GoFTest::EUserDistribution) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GoFTest(
(UInt_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])
, *(ROOT::Math::IGenFunction*) libp->para[2].ref);
     } else {
       p = new((void*) gvp) ROOT::Math::GoFTest(
(UInt_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])
, *(ROOT::Math::IGenFunction*) libp->para[2].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      ((ROOT::Math::GoFTest*) G__getstructoffset())->SetUserDistribution(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::GoFTest::EUserDistribution) G__int(libp->para[1])
, (Double_t) G__double(libp->para[2]), (Double_t) G__double(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((ROOT::Math::GoFTest*) G__getstructoffset())->SetUserDistribution(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::GoFTest::EUserDistribution) G__int(libp->para[1])
, (Double_t) G__double(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::GoFTest*) G__getstructoffset())->SetUserDistribution(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::GoFTest::EUserDistribution) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((ROOT::Math::GoFTest*) G__getstructoffset())->SetUserDistribution(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((ROOT::Math::GoFTest*) G__getstructoffset())->SetUserPDF(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (Double_t) G__double(libp->para[1])
, (Double_t) G__double(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::GoFTest*) G__getstructoffset())->SetUserPDF(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (Double_t) G__double(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((ROOT::Math::GoFTest*) G__getstructoffset())->SetUserPDF(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((ROOT::Math::GoFTest*) G__getstructoffset())->SetUserCDF(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (Double_t) G__double(libp->para[1])
, (Double_t) G__double(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::GoFTest*) G__getstructoffset())->SetUserCDF(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (Double_t) G__double(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((ROOT::Math::GoFTest*) G__getstructoffset())->SetUserCDF(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GoFTest*) G__getstructoffset())->SetDistribution((ROOT::Math::GoFTest::EDistribution) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::GoFTest*) G__getstructoffset())->AndersonDarling2SamplesTest(*(Double_t*) G__Doubleref(&libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GoFTest*) G__getstructoffset())->AndersonDarling2SamplesTest((const Char_t*) G__int(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GoFTest*) G__getstructoffset())->AndersonDarling2SamplesTest());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::GoFTest*) G__getstructoffset())->AndersonDarlingTest(*(Double_t*) G__Doubleref(&libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GoFTest*) G__getstructoffset())->AndersonDarlingTest((const Char_t*) G__int(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GoFTest*) G__getstructoffset())->AndersonDarlingTest());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::GoFTest*) G__getstructoffset())->KolmogorovSmirnov2SamplesTest(*(Double_t*) G__Doubleref(&libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GoFTest*) G__getstructoffset())->KolmogorovSmirnov2SamplesTest((const Char_t*) G__int(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GoFTest*) G__getstructoffset())->KolmogorovSmirnov2SamplesTest());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::GoFTest*) G__getstructoffset())->KolmogorovSmirnovTest(*(Double_t*) G__Doubleref(&libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GoFTest*) G__getstructoffset())->KolmogorovSmirnovTest((const Char_t*) G__int(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GoFTest*) G__getstructoffset())->KolmogorovSmirnovTest());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::GoFTest*) G__getstructoffset())->operator()((ROOT::Math::GoFTest::ETestType) G__int(libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1])
, *(Double_t*) G__Doubleref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_232_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GoFTest*) G__getstructoffset())->operator()((ROOT::Math::GoFTest::ETestType) G__int(libp->para[0]), (const Char_t*) G__int(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GoFTest*) G__getstructoffset())->operator()((ROOT::Math::GoFTest::ETestType) G__int(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GoFTest*) G__getstructoffset())->operator()());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GoFTest G__TROOTcLcLMathcLcLGoFTest;
static int G__G__MathCore_232_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GoFTest*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GoFTest*) (soff+(sizeof(ROOT::Math::GoFTest)*i)))->~G__TROOTcLcLMathcLcLGoFTest();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GoFTest*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GoFTest*) (soff))->~G__TROOTcLcLMathcLcLGoFTest();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */
static int G__G__MathCore__0_440(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator==(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_441(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator!=(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_442(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator<(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_443(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator>(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_444(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator<=(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_445(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator>=(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_446(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) operator-(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_447(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator* pobj;
         const vector<double,allocator<double> >::iterator xobj = operator+((const vector<double,allocator<double> >::iterator::difference_type) G__int(libp->para[0]), *(vector<double,allocator<double> >::iterator*) libp->para[1].ref);
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_448(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator==(*(vector<double,allocator<double> >::reverse_iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::reverse_iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_449(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator!=(*(vector<double,allocator<double> >::reverse_iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::reverse_iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_450(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator==(*(vector<double,allocator<double> >*) libp->para[0].ref, *(vector<double,allocator<double> >*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_451(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator<(*(vector<double,allocator<double> >*) libp->para[0].ref, *(vector<double,allocator<double> >*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_452(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator!=(*(vector<double,allocator<double> >*) libp->para[0].ref, *(vector<double,allocator<double> >*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_453(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator>(*(vector<double,allocator<double> >*) libp->para[0].ref, *(vector<double,allocator<double> >*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_454(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator>=(*(vector<double,allocator<double> >*) libp->para[0].ref, *(vector<double,allocator<double> >*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_455(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator<=(*(vector<double,allocator<double> >*) libp->para[0].ref, *(vector<double,allocator<double> >*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}


/*********************************************************
* Member function Stub
*********************************************************/

/* ROOT */

/* TRandom */

/* TRandom1 */

/* TRandom2 */

/* TRandom3 */

/* TVirtualFitter */

/* TKDTree<int,double> */

/* TKDTree<int,float> */

/* TKDTreeBinning */

/* vector<double,allocator<double> > */

/* vector<double,allocator<double> >::iterator */

/* reverse_iterator<vector<double,allocator<double> >::iterator> */

/* ROOT::Math */

/* ROOT::Math::IBaseFunctionOneDim */

/* ROOT::Math::IGradientFunctionOneDim */

/* ROOT::Math::IBaseFunctionMultiDim */

/* ROOT::Math::IGradientFunctionMultiDim */

/* ROOT::Math::IGradientMultiDim */

/* ROOT::Math::IGradientOneDim */

/* ROOT::Math::IParametricFunctionOneDim */

/* ROOT::Math::IParametricGradFunctionOneDim */

/* ROOT::Math::IParametricFunctionMultiDim */

/* ROOT::Math::IParametricGradFunctionMultiDim */

/* ROOT::Math::IBaseParam */

/* ROOT::Math::ParamFunctor */

/* ROOT::Math::Functor */

/* ROOT::Math::Functor1D */

/* ROOT::Math::GradFunctor */

/* ROOT::Math::GradFunctor1D */

/* ROOT::Math::IOptions */

/* ROOT::Math::MinimizerOptions */

/* ROOT::Math::Minimizer */

/* ROOT::Math::IntegrationOneDim */

/* ROOT::Math::IntegrationMultiDim */

/* ROOT::Math::BaseIntegratorOptions */

/* ROOT::Math::IntegratorOneDimOptions */

/* ROOT::Math::IntegratorMultiDimOptions */

/* ROOT::Math::VirtualIntegrator */

/* ROOT::Math::VirtualIntegratorOneDim */

/* ROOT::Math::VirtualIntegratorMultiDim */

/* ROOT::Math::IntegratorOneDim */

/* ROOT::Math::AdaptiveIntegratorMultiDim */

/* ROOT::Math::IntegratorMultiDim */

/* ROOT::Math::DistSampler */

/* ROOT::Math::Factory */

/* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> */

/* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> */

/* ROOT::Math::GaussIntegrator */

/* ROOT::Math::GaussLegendreIntegrator */

/* ROOT::Math::IRootFinderMethod */

/* ROOT::Math::RootFinder */

/* ROOT::Math::RichardsonDerivator */

/* ROOT::Math::IMinimizer1D */

/* ROOT::Math::BrentMinimizer1D */

/* ROOT::Math::BrentRootFinder */

/* ROOT::Math::DistSamplerOptions */

/* ROOT::Math::GoFTest */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncG__MathCore {
 public:
  G__Sizep2memfuncG__MathCore(): p(&G__Sizep2memfuncG__MathCore::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncG__MathCore::*p)();
};

size_t G__get_sizep2memfuncG__MathCore()
{
  G__Sizep2memfuncG__MathCore a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */
static long G__2vbo_ROOTcLcLMathcLcLIGradientFunctionOneDim_ROOTcLcLMathcLcLIBaseFunctionOneDim_0(long pobject) {
  ROOT::Math::IGradientFunctionOneDim *G__Lderived=(ROOT::Math::IGradientFunctionOneDim*)pobject;
  ROOT::Math::IBaseFunctionOneDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLIGradientFunctionMultiDim_ROOTcLcLMathcLcLIBaseFunctionMultiDim_0(long pobject) {
  ROOT::Math::IGradientFunctionMultiDim *G__Lderived=(ROOT::Math::IGradientFunctionMultiDim*)pobject;
  ROOT::Math::IBaseFunctionMultiDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLIParametricFunctionOneDim_ROOTcLcLMathcLcLIBaseFunctionOneDim_0(long pobject) {
  ROOT::Math::IParametricFunctionOneDim *G__Lderived=(ROOT::Math::IParametricFunctionOneDim*)pobject;
  ROOT::Math::IBaseFunctionOneDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLIParametricGradFunctionOneDim_ROOTcLcLMathcLcLIBaseFunctionOneDim_1(long pobject) {
  ROOT::Math::IParametricGradFunctionOneDim *G__Lderived=(ROOT::Math::IParametricGradFunctionOneDim*)pobject;
  ROOT::Math::IBaseFunctionOneDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLIParametricFunctionMultiDim_ROOTcLcLMathcLcLIBaseFunctionMultiDim_0(long pobject) {
  ROOT::Math::IParametricFunctionMultiDim *G__Lderived=(ROOT::Math::IParametricFunctionMultiDim*)pobject;
  ROOT::Math::IBaseFunctionMultiDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_ROOTcLcLMathcLcLIBaseFunctionMultiDim_1(long pobject) {
  ROOT::Math::IParametricGradFunctionMultiDim *G__Lderived=(ROOT::Math::IParametricGradFunctionMultiDim*)pobject;
  ROOT::Math::IBaseFunctionMultiDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLGradFunctor_ROOTcLcLMathcLcLIBaseFunctionMultiDim_1(long pobject) {
  ROOT::Math::GradFunctor *G__Lderived=(ROOT::Math::GradFunctor*)pobject;
  ROOT::Math::IBaseFunctionMultiDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLGradFunctor1D_ROOTcLcLMathcLcLIBaseFunctionOneDim_1(long pobject) {
  ROOT::Math::GradFunctor1D *G__Lderived=(ROOT::Math::GradFunctor1D*)pobject;
  ROOT::Math::IBaseFunctionOneDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_ROOTcLcLMathcLcLIBaseFunctionMultiDim_1(long pobject) {
  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> *G__Lderived=(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)pobject;
  ROOT::Math::IBaseFunctionMultiDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}


/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceG__MathCore() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom))) {
     TRandom *G__Lderived;
     G__Lderived=(TRandom*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom),G__get_linked_tagnum(&G__G__MathCoreLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1))) {
     TRandom1 *G__Lderived;
     G__Lderived=(TRandom1*)0x1000;
     {
       TRandom *G__Lpbase=(TRandom*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1),G__get_linked_tagnum(&G__G__MathCoreLN_TRandom),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1),G__get_linked_tagnum(&G__G__MathCoreLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2))) {
     TRandom2 *G__Lderived;
     G__Lderived=(TRandom2*)0x1000;
     {
       TRandom *G__Lpbase=(TRandom*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2),G__get_linked_tagnum(&G__G__MathCoreLN_TRandom),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2),G__get_linked_tagnum(&G__G__MathCoreLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3))) {
     TRandom3 *G__Lderived;
     G__Lderived=(TRandom3*)0x1000;
     {
       TRandom *G__Lpbase=(TRandom*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3),G__get_linked_tagnum(&G__G__MathCoreLN_TRandom),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3),G__get_linked_tagnum(&G__G__MathCoreLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter))) {
     TVirtualFitter *G__Lderived;
     G__Lderived=(TVirtualFitter*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter),G__get_linked_tagnum(&G__G__MathCoreLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR))) {
     TKDTree<int,double> *G__Lderived;
     G__Lderived=(TKDTree<int,double>*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR))) {
     TKDTree<int,float> *G__Lderived;
     G__Lderived=(TKDTree<int,float>*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreeBinning))) {
     TKDTreeBinning *G__Lderived;
     G__Lderived=(TKDTreeBinning*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreeBinning),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim))) {
     ROOT::Math::IGradientFunctionOneDim *G__Lderived;
     G__Lderived=(ROOT::Math::IGradientFunctionOneDim*)0x1000;
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__2vbo_ROOTcLcLMathcLcLIGradientFunctionOneDim_ROOTcLcLMathcLcLIBaseFunctionOneDim_0,1,3);
     }
     {
       ROOT::Math::IGradientOneDim *G__Lpbase=(ROOT::Math::IGradientOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim))) {
     ROOT::Math::IGradientFunctionMultiDim *G__Lderived;
     G__Lderived=(ROOT::Math::IGradientFunctionMultiDim*)0x1000;
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__2vbo_ROOTcLcLMathcLcLIGradientFunctionMultiDim_ROOTcLcLMathcLcLIBaseFunctionMultiDim_0,1,3);
     }
     {
       ROOT::Math::IGradientMultiDim *G__Lpbase=(ROOT::Math::IGradientMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim))) {
     ROOT::Math::IParametricFunctionOneDim *G__Lderived;
     G__Lderived=(ROOT::Math::IParametricFunctionOneDim*)0x1000;
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__2vbo_ROOTcLcLMathcLcLIParametricFunctionOneDim_ROOTcLcLMathcLcLIBaseFunctionOneDim_0,1,3);
     }
     {
       ROOT::Math::IBaseParam *G__Lpbase=(ROOT::Math::IBaseParam*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim))) {
     ROOT::Math::IParametricGradFunctionOneDim *G__Lderived;
     G__Lderived=(ROOT::Math::IParametricGradFunctionOneDim*)0x1000;
     {
       ROOT::Math::IParametricFunctionOneDim *G__Lpbase=(ROOT::Math::IParametricFunctionOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__2vbo_ROOTcLcLMathcLcLIParametricGradFunctionOneDim_ROOTcLcLMathcLcLIBaseFunctionOneDim_1,1,2);
     }
     {
       ROOT::Math::IBaseParam *G__Lpbase=(ROOT::Math::IBaseParam*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim))) {
     ROOT::Math::IParametricFunctionMultiDim *G__Lderived;
     G__Lderived=(ROOT::Math::IParametricFunctionMultiDim*)0x1000;
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__2vbo_ROOTcLcLMathcLcLIParametricFunctionMultiDim_ROOTcLcLMathcLcLIBaseFunctionMultiDim_0,1,3);
     }
     {
       ROOT::Math::IBaseParam *G__Lpbase=(ROOT::Math::IBaseParam*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim))) {
     ROOT::Math::IParametricGradFunctionMultiDim *G__Lderived;
     G__Lderived=(ROOT::Math::IParametricGradFunctionMultiDim*)0x1000;
     {
       ROOT::Math::IParametricFunctionMultiDim *G__Lpbase=(ROOT::Math::IParametricFunctionMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__2vbo_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_ROOTcLcLMathcLcLIBaseFunctionMultiDim_1,1,2);
     }
     {
       ROOT::Math::IBaseParam *G__Lpbase=(ROOT::Math::IBaseParam*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor))) {
     ROOT::Math::Functor *G__Lderived;
     G__Lderived=(ROOT::Math::Functor*)0x1000;
     {
       ROOT::Math::IBaseFunctionMultiDim *G__Lpbase=(ROOT::Math::IBaseFunctionMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D))) {
     ROOT::Math::Functor1D *G__Lderived;
     G__Lderived=(ROOT::Math::Functor1D*)0x1000;
     {
       ROOT::Math::IBaseFunctionOneDim *G__Lpbase=(ROOT::Math::IBaseFunctionOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor))) {
     ROOT::Math::GradFunctor *G__Lderived;
     G__Lderived=(ROOT::Math::GradFunctor*)0x1000;
     {
       ROOT::Math::IGradientFunctionMultiDim *G__Lpbase=(ROOT::Math::IGradientFunctionMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__2vbo_ROOTcLcLMathcLcLGradFunctor_ROOTcLcLMathcLcLIBaseFunctionMultiDim_1,1,2);
     }
     {
       ROOT::Math::IGradientMultiDim *G__Lpbase=(ROOT::Math::IGradientMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D))) {
     ROOT::Math::GradFunctor1D *G__Lderived;
     G__Lderived=(ROOT::Math::GradFunctor1D*)0x1000;
     {
       ROOT::Math::IGradientFunctionOneDim *G__Lpbase=(ROOT::Math::IGradientFunctionOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__2vbo_ROOTcLcLMathcLcLGradFunctor1D_ROOTcLcLMathcLcLIBaseFunctionOneDim_1,1,2);
     }
     {
       ROOT::Math::IGradientOneDim *G__Lpbase=(ROOT::Math::IGradientOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions))) {
     ROOT::Math::IntegratorOneDimOptions *G__Lderived;
     G__Lderived=(ROOT::Math::IntegratorOneDimOptions*)0x1000;
     {
       ROOT::Math::BaseIntegratorOptions *G__Lpbase=(ROOT::Math::BaseIntegratorOptions*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBaseIntegratorOptions),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions))) {
     ROOT::Math::IntegratorMultiDimOptions *G__Lderived;
     G__Lderived=(ROOT::Math::IntegratorMultiDimOptions*)0x1000;
     {
       ROOT::Math::BaseIntegratorOptions *G__Lpbase=(ROOT::Math::BaseIntegratorOptions*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBaseIntegratorOptions),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim))) {
     ROOT::Math::VirtualIntegratorOneDim *G__Lderived;
     G__Lderived=(ROOT::Math::VirtualIntegratorOneDim*)0x1000;
     {
       ROOT::Math::VirtualIntegrator *G__Lpbase=(ROOT::Math::VirtualIntegrator*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim))) {
     ROOT::Math::VirtualIntegratorMultiDim *G__Lderived;
     G__Lderived=(ROOT::Math::VirtualIntegratorMultiDim*)0x1000;
     {
       ROOT::Math::VirtualIntegrator *G__Lpbase=(ROOT::Math::VirtualIntegrator*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim))) {
     ROOT::Math::AdaptiveIntegratorMultiDim *G__Lderived;
     G__Lderived=(ROOT::Math::AdaptiveIntegratorMultiDim*)0x1000;
     {
       ROOT::Math::VirtualIntegratorMultiDim *G__Lpbase=(ROOT::Math::VirtualIntegratorMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::VirtualIntegrator *G__Lpbase=(ROOT::Math::VirtualIntegrator*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR))) {
     ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> *G__Lderived;
     G__Lderived=(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)0x1000;
     {
       ROOT::Math::IBaseFunctionMultiDim *G__Lpbase=(ROOT::Math::IBaseFunctionMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR))) {
     ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> *G__Lderived;
     G__Lderived=(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)0x1000;
     {
       ROOT::Math::IGradientFunctionMultiDim *G__Lpbase=(ROOT::Math::IGradientFunctionMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__2vbo_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_ROOTcLcLMathcLcLIBaseFunctionMultiDim_1,1,2);
     }
     {
       ROOT::Math::IGradientMultiDim *G__Lpbase=(ROOT::Math::IGradientMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator))) {
     ROOT::Math::GaussIntegrator *G__Lderived;
     G__Lderived=(ROOT::Math::GaussIntegrator*)0x1000;
     {
       ROOT::Math::VirtualIntegratorOneDim *G__Lpbase=(ROOT::Math::VirtualIntegratorOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::VirtualIntegrator *G__Lpbase=(ROOT::Math::VirtualIntegrator*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator))) {
     ROOT::Math::GaussLegendreIntegrator *G__Lderived;
     G__Lderived=(ROOT::Math::GaussLegendreIntegrator*)0x1000;
     {
       ROOT::Math::GaussIntegrator *G__Lpbase=(ROOT::Math::GaussIntegrator*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::VirtualIntegratorOneDim *G__Lpbase=(ROOT::Math::VirtualIntegratorOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       ROOT::Math::VirtualIntegrator *G__Lpbase=(ROOT::Math::VirtualIntegrator*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D))) {
     ROOT::Math::BrentMinimizer1D *G__Lderived;
     G__Lderived=(ROOT::Math::BrentMinimizer1D*)0x1000;
     {
       ROOT::Math::IMinimizer1D *G__Lpbase=(ROOT::Math::IMinimizer1D*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIMinimizer1D),(long)G__Lpbase-(long)G__Lderived,4,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder))) {
     ROOT::Math::BrentRootFinder *G__Lderived;
     G__Lderived=(ROOT::Math::BrentRootFinder*)0x1000;
     {
       ROOT::Math::IRootFinderMethod *G__Lpbase=(ROOT::Math::IRootFinderMethod*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableG__MathCore() {

   /* Setting up typedef entry */
   G__search_typename2("Char_t",99,-1,0,-1);
   G__setnewtype(-1,"Signed Character 1 byte (char)",0);
   G__search_typename2("UChar_t",98,-1,0,-1);
   G__setnewtype(-1,"Unsigned Character 1 byte (unsigned char)",0);
   G__search_typename2("Short_t",115,-1,0,-1);
   G__setnewtype(-1,"Signed Short integer 2 bytes (short)",0);
   G__search_typename2("Int_t",105,-1,0,-1);
   G__setnewtype(-1,"Signed integer 4 bytes (int)",0);
   G__search_typename2("UInt_t",104,-1,0,-1);
   G__setnewtype(-1,"Unsigned integer 4 bytes (unsigned int)",0);
   G__search_typename2("Float_t",102,-1,0,-1);
   G__setnewtype(-1,"Float 4 bytes (float)",0);
   G__search_typename2("Double_t",100,-1,0,-1);
   G__setnewtype(-1,"Double 8 bytes",0);
   G__search_typename2("Bool_t",103,-1,0,-1);
   G__setnewtype(-1,"Boolean (0=false, 1=true) (bool)",0);
   G__search_typename2("Version_t",115,-1,0,-1);
   G__setnewtype(-1,"Class version identifier (short)",0);
   G__search_typename2("VoidFuncPtr_t",89,-1,0,-1);
   G__setnewtype(-1,"pointer to void function",0);
   G__search_typename2("ShowMembersFunc_t",89,-1,0,-1);
   G__setnewtype(-1,"void (*ShowMembersFunc_t)(void *obj, TMemberInspector &R__insp);",0);
   G__search_typename2("NewFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   G__setnewtype(-1,"void *(*NewFunc_t)(void *);",0);
   G__search_typename2("NewArrFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   G__setnewtype(-1,"void *(*NewArrFunc_t)(Long_t size, void *arena);",0);
   G__search_typename2("DelFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   G__setnewtype(-1,"void  (*DelFunc_t)(void *);",0);
   G__search_typename2("DelArrFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   G__setnewtype(-1,"void  (*DelArrFunc_t)(void *);",0);
   G__search_typename2("DesFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   G__setnewtype(-1,"void  (*DesFunc_t)(void *);",0);
   G__search_typename2("DirAutoAdd_t",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   G__setnewtype(-1,"void  (*DirAutoAdd_t)(void *, TDirectory*);",0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("FCNFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter));
   G__setnewtype(-1,"void   (* FCNFunc_t )(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);",0);
   G__search_typename2("void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t)",49,-1,0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TKDTree<Int_t,Double_t>",117,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<int>",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEintcOallocatorlEintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TKDTreeID",117,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TKDTree<Int_t,Float_t>",117,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TKDTreeIF",117,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Double_t>",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",100,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",68,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",68,-1,256,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",100,-1,1,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",100,-1,257,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",68,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",68,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",100,-1,1,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",100,-1,1,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",68,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",100,-1,1,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<double>",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pair<Double_t,Double_t>",117,G__get_linked_tagnum(&G__G__MathCoreLN_pairlEdoublecOdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::pair<Double_t,Double_t> >",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<pair<double,double> >",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pair<Bool_t,Bool_t>",117,G__get_linked_tagnum(&G__G__MathCoreLN_pairlEboolcOboolgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::pair<Bool_t,Bool_t> >",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<pair<bool,bool> >",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::vector<std::pair<Bool_t,Bool_t> > >",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcOallocatorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcOallocatorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcOallocatorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcOallocatorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcOallocatorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<pair<bool,bool>,allocator<pair<bool,bool> > > >",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcOallocatorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<UInt_t>",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<unsigned int>",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<Double_t,std::vector<UInt_t> >",117,G__get_linked_tagnum(&G__G__MathCoreLN_maplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<double,vector<unsigned int,allocator<unsigned int> > >",117,G__get_linked_tagnum(&G__G__MathCoreLN_maplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<double,vector<unsigned int,allocator<unsigned int> >,less<double> >",117,G__get_linked_tagnum(&G__G__MathCoreLN_maplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::map<Double_t,std::vector<UInt_t> > >",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRcOallocatorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRcOallocatorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRcOallocatorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRcOallocatorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRcOallocatorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<map<double,vector<unsigned int,allocator<unsigned int> >,less<double>,allocator<pair<const double,vector<unsigned int,allocator<unsigned int> > > > > >",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRcOallocatorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pair<const Double_t*,const Double_t*>",117,G__get_linked_tagnum(&G__G__MathCoreLN_pairlEconstsPdoublemUcOconstsPdoublemUgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IGenFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IMultiGenFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IGradFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IMultiGradFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseGrad",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseGrad",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IParamFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IParamMultiFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IParamGradFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IParamMultiGradFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseParamFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseGradFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseParamFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseGradFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Impl",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctionBase),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("FreeFunc",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor));
   G__setnewtype(-1,"double (* FreeFunc ) (double * , double *);",0);
   G__search_typename2("Impl",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("ImplBase",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("auto_ptr<Impl>",117,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Impl",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("ImplBase",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("auto_ptr<Impl>",117,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionOneDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Impl",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("ImplBase",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("auto_ptr<Impl>",117,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Impl",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("ImplBase",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("auto_ptr<Impl>",117,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionOneDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Type",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim));
   G__setnewtype(-1,"for the enumerations defining the types ",0);
   G__search_typename2("auto_ptr<IGenFunction>",117,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionOneDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Integrator",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Type",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim));
   G__setnewtype(-1,"for the enumerations defining the types ",0);
   G__search_typename2("auto_ptr<IMultiGenFunction>",117,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BasicFitMethodFunction<ROOT::Math::IMultiGenFunction>",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("FitMethodFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BasicFitMethodFunction<ROOT::Math::IMultiGradFunction>",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("FitMethodGradFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("typedef",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLtypedef),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("auto_ptr<IGenFunction>",117,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionOneDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::vector<Double_t> >",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<double,allocator<double> > >",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<const Double_t*>",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEconstsPdoublemUcOallocatorlEconstsPdoublemUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEconstsPdoublemUcOallocatorlEconstsPdoublemUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEconstsPdoublemUcOallocatorlEconstsPdoublemUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEconstsPdoublemUcOallocatorlEconstsPdoublemUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEconstsPdoublemUcOallocatorlEconstsPdoublemUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<const double*>",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEconstsPdoublemUcOallocatorlEconstsPdoublemUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* ROOT */
static void G__setup_memvarROOT(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   {
   }
   G__tag_memvar_reset();
}


   /* TRandom */
static void G__setup_memvarTRandom(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom));
   { TRandom *p; p=(TRandom*)0x1000; if (p) { }
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,2,"fSeed=",0,"Random number generator seed");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TRandom1 */
static void G__setup_memvarTRandom1(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1));
   { TRandom1 *p; p=(TRandom1*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fNskip=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fLuxury=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fIlag=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fJlag=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fCount24=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,G__defined_typename("Float_t"),-1,2,"fFloatSeedTable[24]=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,G__defined_typename("Float_t"),-1,2,"fCarry=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,1,-1,G__defined_typename("Int_t"),-1,2,"fIntModulus=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-2,2,"fgNumEngines=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-2,2,"fgMaxIndex=",0,(char*)NULL);
   G__memvar_setup((void*)0,72,0,1,-1,G__defined_typename("UInt_t"),-1,2,"fTheSeeds=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,1,-1,G__defined_typename("Double_t"),-1,2,"fMantissaBit24=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,1,-1,G__defined_typename("Double_t"),-1,2,"fMantissaBit12=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TRandom2 */
static void G__setup_memvarTRandom2(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2));
   { TRandom2 *p; p=(TRandom2*)0x1000; if (p) { }
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,2,"fSeed1=",0,"Random number generator seed 1");
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,2,"fSeed2=",0,"Random number generator seed 2");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TRandom3 */
static void G__setup_memvarTRandom3(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3));
   { TRandom3 *p; p=(TRandom3*)0x1000; if (p) { }
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,4,"fMt[624]=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"fCount624=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TVirtualFitter */
static void G__setup_memvarTVirtualFitter(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter));
   { TVirtualFitter *p; p=(TVirtualFitter*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_Foption_t),-1,-1,2,"fOption=",0,"struct with the fit options");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fXfirst=",0,"first bin on X axis");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fXlast=",0,"last  bin on X axis");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fYfirst=",0,"first bin on Y axis");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fYlast=",0,"last  bin on Y axis");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fZfirst=",0,"first bin on Z axis");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fZlast=",0,"last  bin on Z axis");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fNpoints=",0,"Number of points to fit");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fPointSize=",0,"Number of words per point in the cache");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fCacheSize=",0,"Size of the fCache array");
   G__memvar_setup((void*)0,68,0,0,-1,G__defined_typename("Double_t"),-1,2,"fCache=",0,"[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words)");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TObject),-1,-1,2,"fObjectFit=",0,"pointer to object being fitted");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TObject),-1,-1,2,"fUserFunc=",0,"pointer to user theoretical function (a TF1*)");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TMethodCall),-1,-1,2,"fMethodCall=",0,"Pointer to MethodCall in case of interpreted function");
   G__memvar_setup((void*)0,49,0,0,-1,G__defined_typename("void (*)(Int_t&npar, Double_t*gin, Double_t&f, Double_t*u, Int_t flag)"),-1,2,"fFCN=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter),-1,-2,2,"fgFitter=",0,"Current fitter (default TFitter)");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-2,2,"fgMaxpar=",0,"Maximum number of fit parameters for current fitter");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-2,2,"fgMaxiter=",0,"Maximum number of iterations");
   G__memvar_setup((void*)0,100,0,0,-1,G__defined_typename("Double_t"),-2,2,"fgErrorDef=",0,"Error definition (default=1)");
   G__memvar_setup((void*)0,100,0,0,-1,G__defined_typename("Double_t"),-2,2,"fgPrecision=",0,"maximum precision");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TString),-1,-2,2,"fgDefault=",0,"name of the default fitter (\"Minuit\",\"Fumili\",etc)");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TKDTree<int,double> */
static void G__setup_memvarTKDTreelEintcOdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR));
   { TKDTree<int,double> *p; p=(TKDTree<int,double>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fDataOwner=",0,"! 0 - not owner, 2 - owner of the pointer array, 1 - owner of the whole 2-d array");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fNNodes=",0,"size of node array");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fTotalNodes=",0,"total number of nodes (fNNodes + terminal nodes)");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNDim=",0,"number of dimensions");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNDimm=",0,"dummy 2*fNDim");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNPoints=",0,"number of multidimensional points");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fBucketSize=",0,"size of the terminal nodes");
   G__memvar_setup((void*)0,66,0,0,-1,G__defined_typename("UChar_t"),-1,2,"fAxis=",0,"[fNNodes] nodes cutting axis");
   G__memvar_setup((void*)0,68,0,0,-1,-1,-1,2,"fValue=",0,"[fNNodes] nodes cutting value");
   G__memvar_setup((void*)0,68,0,0,-1,-1,-1,2,"fRange=",0,"[fNDimm] range of data for each dimension");
   G__memvar_setup((void*)0,68,2,0,-1,-1,-1,2,"fData=",0,"! data points");
   G__memvar_setup((void*)0,68,0,0,-1,-1,-1,2,"fBoundaries=",0,"! nodes boundaries");
   G__memvar_setup((void*)0,73,0,0,-1,-1,-1,2,"fIndPoints=",0,"! array of points indexes");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fRowT0=",0,"! smallest terminal row - first row that contains terminal nodes");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fCrossNode=",0,"! cross node - node that begins the last row (with terminal nodes only)");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fOffset=",0,"! offset in fIndPoints - if there are 2 rows, that contain terminal nodes");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TKDTree<int,float> */
static void G__setup_memvarTKDTreelEintcOfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR));
   { TKDTree<int,float> *p; p=(TKDTree<int,float>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fDataOwner=",0,"! 0 - not owner, 2 - owner of the pointer array, 1 - owner of the whole 2-d array");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fNNodes=",0,"size of node array");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fTotalNodes=",0,"total number of nodes (fNNodes + terminal nodes)");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNDim=",0,"number of dimensions");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNDimm=",0,"dummy 2*fNDim");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNPoints=",0,"number of multidimensional points");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fBucketSize=",0,"size of the terminal nodes");
   G__memvar_setup((void*)0,66,0,0,-1,G__defined_typename("UChar_t"),-1,2,"fAxis=",0,"[fNNodes] nodes cutting axis");
   G__memvar_setup((void*)0,70,0,0,-1,-1,-1,2,"fValue=",0,"[fNNodes] nodes cutting value");
   G__memvar_setup((void*)0,70,0,0,-1,-1,-1,2,"fRange=",0,"[fNDimm] range of data for each dimension");
   G__memvar_setup((void*)0,70,2,0,-1,-1,-1,2,"fData=",0,"! data points");
   G__memvar_setup((void*)0,70,0,0,-1,-1,-1,2,"fBoundaries=",0,"! nodes boundaries");
   G__memvar_setup((void*)0,73,0,0,-1,-1,-1,2,"fIndPoints=",0,"! array of points indexes");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fRowT0=",0,"! smallest terminal row - first row that contains terminal nodes");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fCrossNode=",0,"! cross node - node that begins the last row (with terminal nodes only)");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fOffset=",0,"! offset in fIndPoints - if there are 2 rows, that contain terminal nodes");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TKDTreeBinning */
static void G__setup_memvarTKDTreeBinning(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreeBinning));
   { TKDTreeBinning *p; p=(TKDTreeBinning*)0x1000; if (p) { }
   G__memvar_setup((void*)0,68,2,0,-1,G__defined_typename("Double_t"),-1,4,"fData=",0,"The data from which a KDTree partition is computed for binning");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,4,"fBinMinEdges=",0,"The minimum values for the bins' edges for each dimension");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,4,"fBinMaxEdges=",0,"The maximum values for the bins' edges for each dimension");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR),G__defined_typename("TKDTreeID"),-1,4,"fDataBins=",0,"The binning inner structure.");
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,4,"fNBins=",0,"The number of bins");
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,4,"fDim=",0,"The data dimension");
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,4,"fDataSize=",0,"The data size");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR),G__defined_typename("vector<std::pair<Double_t,Double_t> >"),-1,4,"fDataThresholds=",0,"Minimum and maximum data values.");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcOallocatorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRsPgRsPgR),G__defined_typename("vector<std::vector<std::pair<Bool_t,Bool_t> > >"),-1,4,"fCheckedBinEdges=",0,"Auxiliary structure for readjusting the bin edges. Flags if the bin edge was processed in  the algorithm");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRcOallocatorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRsPgRsPgR),G__defined_typename("vector<std::map<Double_t,std::vector<UInt_t> > >"),-1,4,"fCommonBinEdges=",0,"Auxiliary structure for readjusting the bin edges. Keeps the common bin boundaries");
   G__memvar_setup((void*)0,103,0,0,-1,G__defined_typename("Bool_t"),-1,4,"fIsSorted=",0,"Flags if the bin edges are sorted densitywise");
   G__memvar_setup((void*)0,103,0,0,-1,G__defined_typename("Bool_t"),-1,4,"fIsSortedAsc=",0,"Flags if the bin edges are sorted densitywise in ascending order");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),G__defined_typename("vector<UInt_t>"),-1,4,"fBinsContent=",0,"Holds the contents of the bins");
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreeBinningcLcLdA),-1,-2,1,G__FastAllocString(2048).Format("kAdjustBinEdges=%lldLL",(long long)TKDTreeBinning::kAdjustBinEdges).data(),0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* vector<double,allocator<double> > */
static void G__setup_memvarvectorlEdoublecOallocatorlEdoublegRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   { vector<double,allocator<double> > *p; p=(vector<double,allocator<double> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* vector<double,allocator<double> >::iterator */
static void G__setup_memvarvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   { vector<double,allocator<double> >::iterator *p; p=(vector<double,allocator<double> >::iterator*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* reverse_iterator<vector<double,allocator<double> >::iterator> */
static void G__setup_memvarreverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR));
   { reverse_iterator<vector<double,allocator<double> >::iterator> *p; p=(reverse_iterator<vector<double,allocator<double> >::iterator>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math */
static void G__setup_memvarROOTcLcLMath(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   {
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IBaseFunctionOneDim */
static void G__setup_memvarROOTcLcLMathcLcLIBaseFunctionOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim));
   { ROOT::Math::IBaseFunctionOneDim *p; p=(ROOT::Math::IBaseFunctionOneDim*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IGradientFunctionOneDim */
static void G__setup_memvarROOTcLcLMathcLcLIGradientFunctionOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim));
   { ROOT::Math::IGradientFunctionOneDim *p; p=(ROOT::Math::IGradientFunctionOneDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IBaseFunctionMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLIBaseFunctionMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim));
   { ROOT::Math::IBaseFunctionMultiDim *p; p=(ROOT::Math::IBaseFunctionMultiDim*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IGradientFunctionMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLIGradientFunctionMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim));
   { ROOT::Math::IGradientFunctionMultiDim *p; p=(ROOT::Math::IGradientFunctionMultiDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IGradientMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLIGradientMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim));
   { ROOT::Math::IGradientMultiDim *p; p=(ROOT::Math::IGradientMultiDim*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IGradientOneDim */
static void G__setup_memvarROOTcLcLMathcLcLIGradientOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim));
   { ROOT::Math::IGradientOneDim *p; p=(ROOT::Math::IGradientOneDim*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IParametricFunctionOneDim */
static void G__setup_memvarROOTcLcLMathcLcLIParametricFunctionOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim));
   { ROOT::Math::IParametricFunctionOneDim *p; p=(ROOT::Math::IParametricFunctionOneDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IParametricGradFunctionOneDim */
static void G__setup_memvarROOTcLcLMathcLcLIParametricGradFunctionOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim));
   { ROOT::Math::IParametricGradFunctionOneDim *p; p=(ROOT::Math::IParametricGradFunctionOneDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IParametricFunctionMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLIParametricFunctionMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim));
   { ROOT::Math::IParametricFunctionMultiDim *p; p=(ROOT::Math::IParametricFunctionMultiDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IParametricGradFunctionMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim));
   { ROOT::Math::IParametricGradFunctionMultiDim *p; p=(ROOT::Math::IParametricGradFunctionMultiDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IBaseParam */
static void G__setup_memvarROOTcLcLMathcLcLIBaseParam(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam));
   { ROOT::Math::IBaseParam *p; p=(ROOT::Math::IBaseParam*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::ParamFunctor */
static void G__setup_memvarROOTcLcLMathcLcLParamFunctor(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor));
   { ROOT::Math::ParamFunctor *p; p=(ROOT::Math::ParamFunctor*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctionBase),G__defined_typename("Impl"),-1,4,"fImpl=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Functor */
static void G__setup_memvarROOTcLcLMathcLcLFunctor(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   { ROOT::Math::Functor *p; p=(ROOT::Math::Functor*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),-1,-1,4,"fImpl=",0,"pointer to base functor handler");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Functor1D */
static void G__setup_memvarROOTcLcLMathcLcLFunctor1D(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   { ROOT::Math::Functor1D *p; p=(ROOT::Math::Functor1D*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionOneDimgR),-1,-1,4,"fImpl=",0,"pointer to base functor handler");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GradFunctor */
static void G__setup_memvarROOTcLcLMathcLcLGradFunctor(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   { ROOT::Math::GradFunctor *p; p=(ROOT::Math::GradFunctor*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),-1,-1,4,"fImpl=",0,"pointer to base grad functor handler");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GradFunctor1D */
static void G__setup_memvarROOTcLcLMathcLcLGradFunctor1D(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   { ROOT::Math::GradFunctor1D *p; p=(ROOT::Math::GradFunctor1D*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionOneDimgR),-1,-1,4,"fImpl=",0,"pointer to base gradient functor handler");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IOptions */
static void G__setup_memvarROOTcLcLMathcLcLIOptions(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions));
   { ROOT::Math::IOptions *p; p=(ROOT::Math::IOptions*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::MinimizerOptions */
static void G__setup_memvarROOTcLcLMathcLcLMinimizerOptions(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions));
   { ROOT::Math::MinimizerOptions *p; p=(ROOT::Math::MinimizerOptions*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fLevel=",0,"debug print level ");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fMaxCalls=",0,"maximum number of function calls");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fMaxIter=",0,"maximum number of iterations");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fStrategy=",0,"minimizer strategy (used by Minuit)");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fErrorDef=",0,"error definition (=1. for getting 1 sigma error for chi2 fits)");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fTolerance=",0,"minimize tolerance to reach solution");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fPrecision=",0,"precision of the objective function evaluation (value <=0 means left to default)");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_string),-1,-1,4,"fMinimType=",0,"Minimizer type (Minuit, Minuit2, etc..");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_string),-1,-1,4,"fAlgoType=",0,"Minimizer algorithmic specification (Migrad, Minimize, ...)");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions),-1,-1,4,"fExtraOptions=",0,"extra options ");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Minimizer */
static void G__setup_memvarROOTcLcLMathcLcLMinimizer(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizer));
   { ROOT::Math::Minimizer *p; p=(ROOT::Math::Minimizer*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"fValidError=",0,"flag to control if errors have been validated (Hesse has been run in case of Minuit)");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fDebug=",0,"print level");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fStrategy=",0,"minimizer strategy");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fStatus=",0,"status of minimizer    ");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,2,"fMaxCalls=",0,"max number of function calls ");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,2,"fMaxIter=",0,"max number or iterations used to find the minimum");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fTol=",0,"tolerance (absolute)");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fPrec=",0,"precision");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fUp=",0,"error scale ");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IntegrationOneDim */
static void G__setup_memvarROOTcLcLMathcLcLIntegrationOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDim));
   {
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType),-1,-2,1,G__FastAllocString(2048).Format("kDEFAULT=%lldLL",(long long)ROOT::Math::IntegrationOneDim::kDEFAULT).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType),-1,-2,1,G__FastAllocString(2048).Format("kGAUSS=%lldLL",(long long)ROOT::Math::IntegrationOneDim::kGAUSS).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType),-1,-2,1,G__FastAllocString(2048).Format("kLEGENDRE=%lldLL",(long long)ROOT::Math::IntegrationOneDim::kLEGENDRE).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType),-1,-2,1,G__FastAllocString(2048).Format("kADAPTIVE=%lldLL",(long long)ROOT::Math::IntegrationOneDim::kADAPTIVE).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType),-1,-2,1,G__FastAllocString(2048).Format("kADAPTIVESINGULAR=%lldLL",(long long)ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType),-1,-2,1,G__FastAllocString(2048).Format("kNONADAPTIVE=%lldLL",(long long)ROOT::Math::IntegrationOneDim::kNONADAPTIVE).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IntegrationMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLIntegrationMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDim));
   {
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType),-1,-2,1,G__FastAllocString(2048).Format("kDEFAULT=%lldLL",(long long)ROOT::Math::IntegrationMultiDim::kDEFAULT).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType),-1,-2,1,G__FastAllocString(2048).Format("kADAPTIVE=%lldLL",(long long)ROOT::Math::IntegrationMultiDim::kADAPTIVE).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType),-1,-2,1,G__FastAllocString(2048).Format("kVEGAS=%lldLL",(long long)ROOT::Math::IntegrationMultiDim::kVEGAS).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType),-1,-2,1,G__FastAllocString(2048).Format("kMISER=%lldLL",(long long)ROOT::Math::IntegrationMultiDim::kMISER).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType),-1,-2,1,G__FastAllocString(2048).Format("kPLAIN=%lldLL",(long long)ROOT::Math::IntegrationMultiDim::kPLAIN).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::BaseIntegratorOptions */
static void G__setup_memvarROOTcLcLMathcLcLBaseIntegratorOptions(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBaseIntegratorOptions));
   { ROOT::Math::BaseIntegratorOptions *p; p=(ROOT::Math::BaseIntegratorOptions*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fIntegType=",0,"Integrator type (value converted from enum)");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,2,"fWKSize=",0,"workspace size");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,2,"fNCalls=",0,"(max) funxtion calls");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fAbsTolerance=",0,"absolute tolerance ");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fRelTolerance=",0,"relative tolerance ");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions),-1,-1,2,"fExtraOptions=",0,"extra options ");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IntegratorOneDimOptions */
static void G__setup_memvarROOTcLcLMathcLcLIntegratorOneDimOptions(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions));
   { ROOT::Math::IntegratorOneDimOptions *p; p=(ROOT::Math::IntegratorOneDimOptions*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IntegratorMultiDimOptions */
static void G__setup_memvarROOTcLcLMathcLcLIntegratorMultiDimOptions(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions));
   { ROOT::Math::IntegratorMultiDimOptions *p; p=(ROOT::Math::IntegratorMultiDimOptions*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::VirtualIntegrator */
static void G__setup_memvarROOTcLcLMathcLcLVirtualIntegrator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator));
   { ROOT::Math::VirtualIntegrator *p; p=(ROOT::Math::VirtualIntegrator*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::VirtualIntegratorOneDim */
static void G__setup_memvarROOTcLcLMathcLcLVirtualIntegratorOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim));
   { ROOT::Math::VirtualIntegratorOneDim *p; p=(ROOT::Math::VirtualIntegratorOneDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::VirtualIntegratorMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLVirtualIntegratorMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim));
   { ROOT::Math::VirtualIntegratorMultiDim *p; p=(ROOT::Math::VirtualIntegratorMultiDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IntegratorOneDim */
static void G__setup_memvarROOTcLcLMathcLcLIntegratorOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim));
   { ROOT::Math::IntegratorOneDim *p; p=(ROOT::Math::IntegratorOneDim*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim),-1,-1,4,"fIntegrator=",0,"pointer to integrator interface class");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionOneDimgR),-1,-1,4,"fFunc=",0,"pointer to owned function");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::AdaptiveIntegratorMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim));
   { ROOT::Math::AdaptiveIntegratorMultiDim *p; p=(ROOT::Math::AdaptiveIntegratorMultiDim*)0x1000; if (p) { }
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fDim=",0,"dimentionality of integrand");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fMinPts=",0,"minimum number of function evaluation requested ");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fMaxPts=",0,"maximum number of function evaluation requested ");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fSize=",0,"max size of working array (explode with dimension)");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fAbsTol=",0,"absolute tolerance");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fRelTol=",0,"relative tolerance");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fResult=",0,"last integration result ");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fError=",0,"integration error ");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fRelError=",0,"Relative error");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fNEval=",0,"number of function evaluation");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fStatus=",0,"status of algorithm (error if not zero)");
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),G__defined_typename("IMultiGenFunction"),-1,4,"fFun=",0,"pointer to integrand function ");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IntegratorMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLIntegratorMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim));
   { ROOT::Math::IntegratorMultiDim *p; p=(ROOT::Math::IntegratorMultiDim*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim),-1,-1,4,"fIntegrator=",0,"pointer to multi-dimensional integrator base class");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),-1,-1,4,"fFunc=",0,"pointer to owned function");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::DistSampler */
static void G__setup_memvarROOTcLcLMathcLcLDistSampler(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLDistSampler));
   { ROOT::Math::DistSampler *p; p=(ROOT::Math::DistSampler*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"fOwnFunc=",0,"flag to indicate if the function is owned");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,4,"fData=",0,"internal array used to cached the sample data ");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLFitcLcLDataRange),-1,-1,4,"fRange=",0,"data range ");
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),G__defined_typename("IMultiGenFunction"),-1,4,"fFunc=",0,"internal function (ND)");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Factory */
static void G__setup_memvarROOTcLcLMathcLcLFactory(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory));
   { ROOT::Math::Factory *p; p=(ROOT::Math::Factory*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> */
static void G__setup_memvarROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR));
   { ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> *p; p=(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgRcLcLType_t),-1,-2,1,G__FastAllocString(2048).Format("kUndefined=%lldLL",(long long)ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::kUndefined).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgRcLcLType_t),-1,-2,1,G__FastAllocString(2048).Format("kLeastSquare=%lldLL",(long long)ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::kLeastSquare).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgRcLcLType_t),-1,-2,1,G__FastAllocString(2048).Format("kLogLikelihood=%lldLL",(long long)ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::kLogLikelihood).data(),0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNDim=",0,"function dimension ");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNPoints=",0,"size of the data");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNCalls=",0,"number of function calls");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> */
static void G__setup_memvarROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR));
   { ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> *p; p=(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgRcLcLType_t),-1,-2,1,G__FastAllocString(2048).Format("kUndefined=%lldLL",(long long)ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::kUndefined).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgRcLcLType_t),-1,-2,1,G__FastAllocString(2048).Format("kLeastSquare=%lldLL",(long long)ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::kLeastSquare).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgRcLcLType_t),-1,-2,1,G__FastAllocString(2048).Format("kLogLikelihood=%lldLL",(long long)ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::kLogLikelihood).data(),0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNDim=",0,"function dimension ");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNPoints=",0,"size of the data");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNCalls=",0,"number of function calls");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GaussIntegrator */
static void G__setup_memvarROOTcLcLMathcLcLGaussIntegrator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator));
   { ROOT::Math::GaussIntegrator *p; p=(ROOT::Math::GaussIntegrator*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-2,2,"fgAbsValue=",0,"AbsValue used for the calculation of the integral");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fEpsilon=",0,"Relative error.");
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"fUsedOnce=",0,"Bool value to check if the function was at least called once.");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fLastResult=",0,"Result from the last stimation.");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fLastError=",0,"Error from the last stimation.");
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),G__defined_typename("IGenFunction"),-1,2,"fFunction=",0,"Pointer to function used.");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GaussLegendreIntegrator */
static void G__setup_memvarROOTcLcLMathcLcLGaussLegendreIntegrator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator));
   { ROOT::Math::GaussLegendreIntegrator *p; p=(ROOT::Math::GaussLegendreIntegrator*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNum=",0,"Number of points used in the stimation of the integral.");
   G__memvar_setup((void*)0,68,0,0,-1,-1,-1,2,"fX=",0,"Abscisa of the points used.");
   G__memvar_setup((void*)0,68,0,0,-1,-1,-1,2,"fW=",0,"Weights of the points used.");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IRootFinderMethod */
static void G__setup_memvarROOTcLcLMathcLcLIRootFinderMethod(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod));
   { ROOT::Math::IRootFinderMethod *p; p=(ROOT::Math::IRootFinderMethod*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::RootFinder */
static void G__setup_memvarROOTcLcLMathcLcLRootFinder(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder));
   { ROOT::Math::RootFinder *p; p=(ROOT::Math::RootFinder*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType),-1,-2,1,G__FastAllocString(2048).Format("kBRENT=%lldLL",(long long)ROOT::Math::RootFinder::kBRENT).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType),-1,-2,1,G__FastAllocString(2048).Format("kGSL_BISECTION=%lldLL",(long long)ROOT::Math::RootFinder::kGSL_BISECTION).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType),-1,-2,1,G__FastAllocString(2048).Format("kGSL_FALSE_POS=%lldLL",(long long)ROOT::Math::RootFinder::kGSL_FALSE_POS).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType),-1,-2,1,G__FastAllocString(2048).Format("kGSL_BRENT=%lldLL",(long long)ROOT::Math::RootFinder::kGSL_BRENT).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType),-1,-2,1,G__FastAllocString(2048).Format("kGSL_NEWTON=%lldLL",(long long)ROOT::Math::RootFinder::kGSL_NEWTON).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType),-1,-2,1,G__FastAllocString(2048).Format("kGSL_SECANT=%lldLL",(long long)ROOT::Math::RootFinder::kGSL_SECANT).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType),-1,-2,1,G__FastAllocString(2048).Format("kGSL_STEFFENSON=%lldLL",(long long)ROOT::Math::RootFinder::kGSL_STEFFENSON).data(),0,(char*)NULL);
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod),-1,-1,4,"fSolver=",0,"type of algorithm to be used ");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::RichardsonDerivator */
static void G__setup_memvarROOTcLcLMathcLcLRichardsonDerivator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator));
   { ROOT::Math::RichardsonDerivator *p; p=(ROOT::Math::RichardsonDerivator*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"fFunctionCopied=",0,"flag to control if function is copied in the class");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fStepSize=",0,"step size used for derivative calculation");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fLastError=",0,"error estimate of last derivative calculation");
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),G__defined_typename("IGenFunction"),-1,2,"fFunction=",0,"pointer to function");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IMinimizer1D */
static void G__setup_memvarROOTcLcLMathcLcLIMinimizer1D(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIMinimizer1D));
   { ROOT::Math::IMinimizer1D *p; p=(ROOT::Math::IMinimizer1D*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::BrentMinimizer1D */
static void G__setup_memvarROOTcLcLMathcLcLBrentMinimizer1D(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D));
   { ROOT::Math::BrentMinimizer1D *p; p=(ROOT::Math::BrentMinimizer1D*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),G__defined_typename("IGenFunction"),-1,4,"fFunction=",0,"Pointer to the function.");
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"fLogScan=",0,"flag to control usage of a log scan");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fNIter=",0,"Number of iterations needed for the last estimation.");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fNpx=",0,"Number of points to bracket minimum with grid (def is 100)");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fStatus=",0,"Status of code of the last estimate");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fXMin=",0,"Lower bound of the search interval.");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fXMax=",0,"Upper bound of the search interval");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fXMinimum=",0,"Position of the stimated minimum.");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::BrentRootFinder */
static void G__setup_memvarROOTcLcLMathcLcLBrentRootFinder(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder));
   { ROOT::Math::BrentRootFinder *p; p=(ROOT::Math::BrentRootFinder*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),G__defined_typename("IGenFunction"),-1,4,"fFunction=",0,"Pointer to the function.");
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"fLogScan=",0,"flag to control usage of a log scan      ");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fNIter=",0,"Number of iterations needed for the last estimation.");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fNpx=",0,"Number of points to bracket root with initial grid (def is 100)");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fStatus=",0,"Status of code of the last estimate");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fXMin=",0,"Lower bound of the search interval.");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fXMax=",0,"Upper bound of the search interval");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fRoot=",0,"Current stimation of the function root.");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::DistSamplerOptions */
static void G__setup_memvarROOTcLcLMathcLcLDistSamplerOptions(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLDistSamplerOptions));
   { ROOT::Math::DistSamplerOptions *p; p=(ROOT::Math::DistSamplerOptions*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fLevel=",0,"debug print level ");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_string),-1,-1,4,"fSamplerType=",0,"DistSampler type (Unuran, Foam, etc...)xs");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_string),-1,-1,4,"fAlgoType=",0,"DistSampler algorithmic specification (for Unuran only)");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions),-1,-1,4,"fExtraOptions=",0,"extra options ");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GoFTest */
static void G__setup_memvarROOTcLcLMathcLcLGoFTest(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest));
   { ROOT::Math::GoFTest *p; p=(ROOT::Math::GoFTest*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLEDistribution),-1,-2,1,G__FastAllocString(2048).Format("kUndefined=%lldLL",(long long)ROOT::Math::GoFTest::kUndefined).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLEDistribution),-1,-2,1,G__FastAllocString(2048).Format("kUserDefined=%lldLL",(long long)ROOT::Math::GoFTest::kUserDefined).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLEDistribution),-1,-2,1,G__FastAllocString(2048).Format("kGaussian=%lldLL",(long long)ROOT::Math::GoFTest::kGaussian).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLEDistribution),-1,-2,1,G__FastAllocString(2048).Format("kLogNormal=%lldLL",(long long)ROOT::Math::GoFTest::kLogNormal).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLEDistribution),-1,-2,1,G__FastAllocString(2048).Format("kExponential=%lldLL",(long long)ROOT::Math::GoFTest::kExponential).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLEUserDistribution),-1,-2,1,G__FastAllocString(2048).Format("kCDF=%lldLL",(long long)ROOT::Math::GoFTest::kCDF).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLEUserDistribution),-1,-2,1,G__FastAllocString(2048).Format("kPDF=%lldLL",(long long)ROOT::Math::GoFTest::kPDF).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLETestType),-1,-2,1,G__FastAllocString(2048).Format("kAD=%lldLL",(long long)ROOT::Math::GoFTest::kAD).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLETestType),-1,-2,1,G__FastAllocString(2048).Format("kAD2s=%lldLL",(long long)ROOT::Math::GoFTest::kAD2s).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLETestType),-1,-2,1,G__FastAllocString(2048).Format("kKS=%lldLL",(long long)ROOT::Math::GoFTest::kKS).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLETestType),-1,-2,1,G__FastAllocString(2048).Format("kKS2s=%lldLL",(long long)ROOT::Math::GoFTest::kKS2s).data(),0,(char*)NULL);
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionOneDimgR),-1,-1,4,"fCDF=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLEDistribution),-1,-1,4,"fDist=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,G__defined_typename("Double_t"),-1,4,"fMean=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,G__defined_typename("Double_t"),-1,4,"fSigma=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,4,"fCombinedSamples=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR),G__defined_typename("vector<std::vector<Double_t> >"),-1,4,"fSamples=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,G__defined_typename("Bool_t"),-1,4,"fTestSampleFromH0=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarG__MathCore() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncROOT(void) {
   /* ROOT */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   G__memfunc_setup("CreateClass",1098,G__G__MathCore_19_0_1, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 9, 1, 1, 0, 
"C - - 10 - cname s - 'Version_t' 0 - id "
"u 'type_info' - 11 - info U 'TVirtualIsAProxy' - 0 - isa "
"Y - 'ShowMembersFunc_t' 0 - show C - - 10 - dfil "
"C - - 10 - ifil i - 'Int_t' 0 - dl "
"i - 'Int_t' 0 - il", (char*)NULL, (void*) G__func2void( (TClass* (*)(const char*, Version_t, const type_info&, TVirtualIsAProxy*, ShowMembersFunc_t, const char*, const char*, Int_t, Int_t))(&ROOT::CreateClass) ), 0);
   G__memfunc_setup("AddClass",767,G__G__MathCore_19_0_2, 121, -1, -1, 0, 5, 1, 1, 0, 
"C - - 10 - cname s - 'Version_t' 0 - id "
"u 'type_info' - 11 - info Y - 'VoidFuncPtr_t' 0 - dict "
"i - 'Int_t' 0 - pragmabits", (char*)NULL, (void*) G__func2void( (void (*)(const char*, Version_t, const type_info&, VoidFuncPtr_t, Int_t))(&ROOT::AddClass) ), 0);
   G__memfunc_setup("RemoveClass",1124,G__G__MathCore_19_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - cname", (char*)NULL, (void*) G__func2void( (void (*)(const char*))(&ROOT::RemoveClass) ), 0);
   G__memfunc_setup("ResetClassVersion",1759,G__G__MathCore_19_0_4, 121, -1, -1, 0, 3, 1, 1, 0, 
"U 'TClass' - 0 - - C - - 10 - - "
"s - 'Short_t' 0 - -", (char*)NULL, (void*) G__func2void( (void (*)(TClass*, const char*, Short_t))(&ROOT::ResetClassVersion) ), 0);
   G__memfunc_setup("RegisterClassTemplate",2167,G__G__MathCore_19_0_5, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TNamed), -1, 0, 3, 1, 1, 0, 
"C - - 10 - name C - - 10 - file "
"i - 'Int_t' 0 - line", (char*)NULL, (void*) G__func2void( (TNamed* (*)(const char*, const char*, Int_t))(&ROOT::RegisterClassTemplate) ), 0);
   G__memfunc_setup("DefineBehavior",1403,G__G__MathCore_19_0_6, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLTInitBehavior), -1, 0, 2, 1, 1, 1, 
"Y - - 0 - - Y - - 0 - -", (char*)NULL, (void*) G__func2void( (const ROOT::TInitBehavior* (*)(void*, void*))(&ROOT::DefineBehavior) ), 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTRandom(void) {
   /* TRandom */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom));
   G__memfunc_setup("TRandom",693,G__G__MathCore_110_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TRandom), -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 '65539' seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Binomial",811,G__G__MathCore_110_0_2, 105, -1, G__defined_typename("Int_t"), 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - ntot d - 'Double_t' 0 - prob", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("BreitWigner",1122,G__G__MathCore_110_0_3, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 0, 
"d - 'Double_t' 0 '0' mean d - 'Double_t' 0 '1' gamma", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Circle",594,G__G__MathCore_110_0_4, 121, -1, -1, 0, 3, 1, 1, 0, 
"d - 'Double_t' 1 - x d - 'Double_t' 1 - y "
"d - 'Double_t' 0 - r", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Exp",301,G__G__MathCore_110_0_5, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "d - 'Double_t' 0 - tau", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Gaus",400,G__G__MathCore_110_0_6, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 0, 
"d - 'Double_t' 0 '0' mean d - 'Double_t' 0 '1' sigma", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetSeed",673,G__G__MathCore_110_0_7, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integer",718,G__G__MathCore_110_0_8, 104, -1, G__defined_typename("UInt_t"), 0, 1, 1, 1, 0, "h - 'UInt_t' 0 - imax", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Landau",597,G__G__MathCore_110_0_9, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 0, 
"d - 'Double_t' 0 '0' mean d - 'Double_t' 0 '1' sigma", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Poisson",747,G__G__MathCore_110_0_10, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 0, "d - 'Double_t' 0 - mean", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("PoissonD",815,G__G__MathCore_110_0_11, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "d - 'Double_t' 0 - mean", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Rannor",624,G__G__MathCore_110_0_12, 121, -1, -1, 0, 2, 1, 1, 0, 
"f - 'Float_t' 1 - a f - 'Float_t' 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Rannor",624,G__G__MathCore_110_0_13, 121, -1, -1, 0, 2, 1, 1, 0, 
"d - 'Double_t' 1 - a d - 'Double_t' 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ReadRandom",989,G__G__MathCore_110_0_14, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - filename", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSeed",685,G__G__MathCore_110_0_15, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 '0' seed", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Rndm",401,G__G__MathCore_110_0_16, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "i - 'Int_t' 0 '0' i", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,G__G__MathCore_110_0_17, 121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - n F - 'Float_t' 0 - array", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,G__G__MathCore_110_0_18, 121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - n D - 'Double_t' 0 - array", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Sphere",615,G__G__MathCore_110_0_19, 121, -1, -1, 0, 4, 1, 1, 0, 
"d - 'Double_t' 1 - x d - 'Double_t' 1 - y "
"d - 'Double_t' 1 - z d - 'Double_t' 0 - r", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Uniform",736,G__G__MathCore_110_0_20, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "d - 'Double_t' 0 '1' x1", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Uniform",736,G__G__MathCore_110_0_21, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 0, 
"d - 'Double_t' 0 - x1 d - 'Double_t' 0 - x2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("WriteRandom",1132,G__G__MathCore_110_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - filename", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__G__MathCore_110_0_23, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TRandom::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_110_0_24, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_110_0_25, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TRandom::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_110_0_26, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TRandom::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_110_0_30, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_110_0_31, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_110_0_32, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_110_0_33, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_110_0_34, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TRandom", 693, G__G__MathCore_110_0_35, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_TRandom), -1, 0, 1, 1, 1, 0, "u 'TRandom' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRandom", 819, G__G__MathCore_110_0_36, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_110_0_37, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_TRandom), -1, 1, 1, 1, 1, 0, "u 'TRandom' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTRandom1(void) {
   /* TRandom1 */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1));
   G__memfunc_setup("TRandom1",742,G__G__MathCore_111_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TRandom1",742,G__G__MathCore_111_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1), -1, 0, 2, 1, 1, 0, 
"h - 'UInt_t' 0 - seed i - 'Int_t' 0 '3' lux", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TRandom1",742,G__G__MathCore_111_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1), -1, 0, 3, 1, 1, 0, 
"i - 'Int_t' 0 - rowIndex i - 'Int_t' 0 - colIndex "
"i - 'Int_t' 0 - lux", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetLuxury",953,G__G__MathCore_111_0_4, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetTheSeeds",1077,G__G__MathCore_111_0_5, 72, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTableSeeds",1276,G__G__MathCore_111_0_6, 121, -1, -1, 0, 2, 3, 1, 0, 
"H - 'UInt_t' 0 - seeds i - 'Int_t' 0 - index", (char*)NULL, (void*) G__func2void( (void (*)(UInt_t*, Int_t))(&TRandom1::GetTableSeeds) ), 0);
   G__memfunc_setup("Rndm",401,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "i - 'Int_t' 0 '0' i", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - size F - 'Float_t' 0 - vect", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - size D - 'Double_t' 0 - vect", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSeed2",735,G__G__MathCore_111_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"h - 'UInt_t' 0 - seed i - 'Int_t' 0 '3' lux", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSeeds",800,G__G__MathCore_111_0_11, 121, -1, -1, 0, 2, 1, 1, 0, 
"H - 'UInt_t' 10 - seeds i - 'Int_t' 0 '3' lux", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSeed",685,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 - seed", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__G__MathCore_111_0_13, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TRandom1::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_111_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom1::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_111_0_15, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TRandom1::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_111_0_16, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TRandom1::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_111_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_111_0_21, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom1::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_111_0_22, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom1::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_111_0_23, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom1::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_111_0_24, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom1::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TRandom1", 742, G__G__MathCore_111_0_25, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1), -1, 0, 1, 1, 1, 0, "u 'TRandom1' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRandom1", 868, G__G__MathCore_111_0_26, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTRandom2(void) {
   /* TRandom2 */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2));
   G__memfunc_setup("TRandom2",743,G__G__MathCore_112_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2), -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 '1' seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rndm",401,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "i - 'Int_t' 0 '0' i", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - n F - 'Float_t' 0 - array", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - n D - 'Double_t' 0 - array", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSeed",685,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 '0' seed", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__G__MathCore_112_0_6, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TRandom2::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_112_0_7, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom2::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_112_0_8, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TRandom2::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_112_0_9, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TRandom2::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_112_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_112_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom2::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_112_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom2::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_112_0_16, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom2::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_112_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom2::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TRandom2", 743, G__G__MathCore_112_0_18, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2), -1, 0, 1, 1, 1, 0, "u 'TRandom2' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRandom2", 869, G__G__MathCore_112_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_112_0_20, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2), -1, 1, 1, 1, 1, 0, "u 'TRandom2' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTRandom3(void) {
   /* TRandom3 */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3));
   G__memfunc_setup("TRandom3",744,G__G__MathCore_113_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3), -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 '4357' seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rndm",401,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "i - 'Int_t' 0 '0' i", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - n F - 'Float_t' 0 - array", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - n D - 'Double_t' 0 - array", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSeed",685,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 '0' seed", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__G__MathCore_113_0_6, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TRandom3::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_113_0_7, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom3::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_113_0_8, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TRandom3::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_113_0_9, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TRandom3::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_113_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_113_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom3::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_113_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom3::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_113_0_16, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom3::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_113_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom3::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TRandom3", 744, G__G__MathCore_113_0_18, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3), -1, 0, 1, 1, 1, 0, "u 'TRandom3' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRandom3", 870, G__G__MathCore_113_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_113_0_20, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3), -1, 1, 1, 1, 1, 0, "u 'TRandom3' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTVirtualFitter(void) {
   /* TVirtualFitter */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter));
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter), -1, 1, 1, 1, 2, 0, "u 'TVirtualFitter' - 11 - tvf", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Chisquare",933,G__G__MathCore_121_0_4, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 8, 
"i - 'Int_t' 0 - npar D - 'Double_t' 0 - params", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Clear",487,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "C - 'Option_t' 10 '\"\"' option", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("ExecuteCommand",1426,G__G__MathCore_121_0_6, 105, -1, G__defined_typename("Int_t"), 0, 3, 1, 1, 0, 
"C - - 10 - command D - 'Double_t' 0 - args "
"i - 'Int_t' 0 - nargs", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("FixParameter",1224,G__G__MathCore_121_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - ipar", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetConfidenceIntervals",2246,G__G__MathCore_121_0_8, 121, -1, -1, 0, 5, 1, 1, 0, 
"i - 'Int_t' 0 - n i - 'Int_t' 0 - ndim "
"D - 'Double_t' 10 - x D - 'Double_t' 0 - ci "
"d - 'Double_t' 0 '0.95' cl", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetConfidenceIntervals",2246,G__G__MathCore_121_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"U 'TObject' - 0 - obj d - 'Double_t' 0 '0.95' cl", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetCovarianceMatrix",1936,G__G__MathCore_121_0_10, 68, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetCovarianceMatrixElement",2650,G__G__MathCore_121_0_11, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 8, 
"i - 'Int_t' 0 - i i - 'Int_t' 0 - j", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetErrors",925,G__G__MathCore_121_0_12, 105, -1, G__defined_typename("Int_t"), 0, 5, 1, 1, 8, 
"i - 'Int_t' 0 - ipar d - 'Double_t' 1 - eplus "
"d - 'Double_t' 1 - eminus d - 'Double_t' 1 - eparab "
"d - 'Double_t' 1 - globcc", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetFCN",503,G__G__MathCore_121_0_13, 89, -1, G__defined_typename("TVirtualFitter::FCNFunc_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetFitOption",1212,G__G__MathCore_121_0_14, 117, G__get_linked_tagnum(&G__G__MathCoreLN_Foption_t), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetMethodCall",1277,G__G__MathCore_121_0_15, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TMethodCall), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNumberTotalParameters",2465,G__G__MathCore_121_0_16, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetNumberFreeParameters",2335,G__G__MathCore_121_0_17, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetObjectFit",1178,G__G__MathCore_121_0_18, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TObject), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetParError",1101,G__G__MathCore_121_0_19, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - ipar", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetParameter",1217,G__G__MathCore_121_0_20, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - ipar", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetParameter",1217,G__G__MathCore_121_0_21, 105, -1, G__defined_typename("Int_t"), 0, 6, 1, 1, 8, 
"i - 'Int_t' 0 - ipar C - - 0 - name "
"d - 'Double_t' 1 - value d - 'Double_t' 1 - verr "
"d - 'Double_t' 1 - vlow d - 'Double_t' 1 - vhigh", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetParName",964,G__G__MathCore_121_0_22, 67, -1, -1, 0, 1, 1, 1, 9, "i - 'Int_t' 0 - ipar", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetStats",815,G__G__MathCore_121_0_23, 105, -1, G__defined_typename("Int_t"), 0, 5, 1, 1, 8, 
"d - 'Double_t' 1 - amin d - 'Double_t' 1 - edm "
"d - 'Double_t' 1 - errdef i - 'Int_t' 1 - nvpar "
"i - 'Int_t' 1 - nparx", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetSumLog",887,G__G__MathCore_121_0_24, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "i - 'Int_t' 0 - i", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetUserFunc",1099,G__G__MathCore_121_0_25, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TObject), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetXfirst",928,G__G__MathCore_121_0_26, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetXlast",812,G__G__MathCore_121_0_27, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetYfirst",929,G__G__MathCore_121_0_28, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetYlast",813,G__G__MathCore_121_0_29, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetZfirst",930,G__G__MathCore_121_0_30, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetZlast",814,G__G__MathCore_121_0_31, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IsFixed",684,G__G__MathCore_121_0_32, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - ipar", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("PrintResults",1279,G__G__MathCore_121_0_33, 121, -1, -1, 0, 2, 1, 1, 8, 
"i - 'Int_t' 0 - level d - 'Double_t' 0 - amin", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("ReleaseParameter",1634,G__G__MathCore_121_0_34, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - ipar", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetCache",768,G__G__MathCore_121_0_35, 68, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - npoints i - 'Int_t' 0 - psize", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFCN",515,G__G__MathCore_121_0_36, 121, -1, -1, 0, 1, 1, 1, 0, "Y - - 0 - fcn", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFCN",515,G__G__MathCore_121_0_37, 121, -1, -1, 0, 1, 1, 1, 0, "1 - 'void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t)' 0 - fcn", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFitMethod",1200,G__G__MathCore_121_0_38, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - name", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetFitOption",1224,G__G__MathCore_121_0_39, 121, -1, -1, 0, 1, 1, 1, 0, "u 'Foption_t' - 0 - option", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetObjectFit",1190,G__G__MathCore_121_0_40, 121, -1, -1, 0, 1, 1, 1, 0, "U 'TObject' - 0 - obj", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetParameter",1229,G__G__MathCore_121_0_41, 105, -1, G__defined_typename("Int_t"), 0, 6, 1, 1, 0, 
"i - 'Int_t' 0 - ipar C - - 10 - parname "
"d - 'Double_t' 0 - value d - 'Double_t' 0 - verr "
"d - 'Double_t' 0 - vlow d - 'Double_t' 0 - vhigh", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetUserFunc",1111,G__G__MathCore_121_0_42, 121, -1, -1, 0, 1, 1, 1, 0, "U 'TObject' - 0 - userfunc", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetXfirst",940,G__G__MathCore_121_0_43, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - first", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetXlast",824,G__G__MathCore_121_0_44, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - last", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetYfirst",941,G__G__MathCore_121_0_45, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - first", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetYlast",825,G__G__MathCore_121_0_46, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - last", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetZfirst",942,G__G__MathCore_121_0_47, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - first", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetZlast",826,G__G__MathCore_121_0_48, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - last", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetFitter",910,G__G__MathCore_121_0_49, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TVirtualFitter* (*)())(&TVirtualFitter::GetFitter) ), 0);
   G__memfunc_setup("Fitter",622,G__G__MathCore_121_0_50, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter), -1, 0, 2, 3, 1, 0, 
"U 'TObject' - 0 - obj i - 'Int_t' 0 '25' maxpar", (char*)NULL, (void*) G__func2void( (TVirtualFitter* (*)(TObject*, Int_t))(&TVirtualFitter::Fitter) ), 0);
   G__memfunc_setup("GetDefaultFitter",1619,G__G__MathCore_121_0_51, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualFitter::GetDefaultFitter) ), 0);
   G__memfunc_setup("GetMaxIterations",1640,G__G__MathCore_121_0_52, 105, -1, G__defined_typename("Int_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Int_t (*)())(&TVirtualFitter::GetMaxIterations) ), 0);
   G__memfunc_setup("GetErrorDef",1081,G__G__MathCore_121_0_53, 100, -1, G__defined_typename("Double_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Double_t (*)())(&TVirtualFitter::GetErrorDef) ), 0);
   G__memfunc_setup("GetPrecision",1228,G__G__MathCore_121_0_54, 100, -1, G__defined_typename("Double_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Double_t (*)())(&TVirtualFitter::GetPrecision) ), 0);
   G__memfunc_setup("SetDefaultFitter",1631,G__G__MathCore_121_0_55, 121, -1, -1, 0, 1, 3, 1, 0, "C - - 10 '\"\"' name", (char*)NULL, (void*) G__func2void( (void (*)(const char*))(&TVirtualFitter::SetDefaultFitter) ), 0);
   G__memfunc_setup("SetFitter",922,G__G__MathCore_121_0_56, 121, -1, -1, 0, 2, 3, 1, 0, 
"U 'TVirtualFitter' - 0 - fitter i - 'Int_t' 0 '25' maxpar", (char*)NULL, (void*) G__func2void( (void (*)(TVirtualFitter*, Int_t))(&TVirtualFitter::SetFitter) ), 0);
   G__memfunc_setup("SetMaxIterations",1652,G__G__MathCore_121_0_57, 121, -1, -1, 0, 1, 3, 1, 0, "i - 'Int_t' 0 '5000' niter", (char*)NULL, (void*) G__func2void( (void (*)(Int_t))(&TVirtualFitter::SetMaxIterations) ), 0);
   G__memfunc_setup("SetErrorDef",1093,G__G__MathCore_121_0_58, 121, -1, -1, 0, 1, 3, 1, 0, "d - 'Double_t' 0 '1' errdef", (char*)NULL, (void*) G__func2void( (void (*)(Double_t))(&TVirtualFitter::SetErrorDef) ), 0);
   G__memfunc_setup("SetPrecision",1240,G__G__MathCore_121_0_59, 121, -1, -1, 0, 1, 3, 1, 0, "d - 'Double_t' 0 '1e-6' prec", (char*)NULL, (void*) G__func2void( (void (*)(Double_t))(&TVirtualFitter::SetPrecision) ), 0);
   G__memfunc_setup("Class",502,G__G__MathCore_121_0_60, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TVirtualFitter::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_121_0_61, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualFitter::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_121_0_62, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TVirtualFitter::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_121_0_63, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TVirtualFitter::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_121_0_67, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_121_0_68, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualFitter::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_121_0_69, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualFitter::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_121_0_70, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualFitter::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_121_0_71, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualFitter::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TVirtualFitter", 1575, G__G__MathCore_121_0_72, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTKDTreelEintcOdoublegR(void) {
   /* TKDTree<int,double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR));
   G__memfunc_setup("TKDTree<int,double>",1759,G__G__MathCore_122_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TKDTree<int,double>",1759,G__G__MathCore_122_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR), -1, 0, 3, 1, 1, 0, 
"i - - 0 - npoints i - - 0 - ndim "
"h - 'UInt_t' 0 - bsize", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TKDTree<int,double>",1759,G__G__MathCore_122_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR), -1, 0, 4, 1, 1, 0, 
"i - - 0 - npoints i - - 0 - ndim "
"h - 'UInt_t' 0 - bsize D - - 2 - data", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Build",496,G__G__MathCore_122_0_4, 121, -1, -1, 0, 0, 1, 1, 0, "", "build the tree", (void*) NULL, 0);
   G__memfunc_setup("Distance",811,G__G__MathCore_122_0_5, 100, -1, G__defined_typename("Double_t"), 0, 3, 1, 1, 8, 
"D - - 10 - point i - - 0 - ind "
"i - 'Int_t' 0 '2' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DistanceToNode",1396,G__G__MathCore_122_0_6, 121, -1, -1, 0, 5, 1, 1, 0, 
"D - - 10 - point i - - 0 - inode "
"d - - 1 - min d - - 1 - max "
"i - 'Int_t' 0 '2' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetLeft",683,G__G__MathCore_122_0_7, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetRight",798,G__G__MathCore_122_0_8, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetParent",906,G__G__MathCore_122_0_9, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetPointsIndexes",1645,G__G__MathCore_122_0_10, 73, -1, -1, 0, 1, 1, 1, 8, "i - 'Int_t' 0 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNodePointsIndexes",2035,G__G__MathCore_122_0_11, 121, -1, -1, 0, 5, 1, 1, 8, 
"i - 'Int_t' 0 - node i - 'Int_t' 1 - first1 "
"i - 'Int_t' 1 - last1 i - 'Int_t' 1 - first2 "
"i - 'Int_t' 1 - last2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNodeAxis",1083,G__G__MathCore_122_0_12, 98, -1, G__defined_typename("UChar_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - id", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNodeValue",1187,G__G__MathCore_122_0_13, 100, -1, -1, 0, 1, 1, 1, 8, "i - 'Int_t' 0 - id", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNNodes",871,G__G__MathCore_122_0_14, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTotalNodes",1309,G__G__MathCore_122_0_15, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundaries",1324,G__G__MathCore_122_0_16, 68, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundariesExact",1825,G__G__MathCore_122_0_17, 68, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundary",1124,G__G__MathCore_122_0_18, 68, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 10 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundaryExact",1625,G__G__MathCore_122_0_19, 68, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 10 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNPoints",1003,G__G__MathCore_122_0_20, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNDim",648,G__G__MathCore_122_0_21, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNPointsNode",1393,G__G__MathCore_122_0_22, 105, -1, -1, 0, 1, 1, 1, 8, "i - 'Int_t' 0 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetRowT0",732,G__G__MathCore_122_0_23, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", "! smallest terminal row", (void*) NULL, 0);
   G__memfunc_setup("GetCrossNode",1200,G__G__MathCore_122_0_24, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", "! cross node", (void*) NULL, 0);
   G__memfunc_setup("GetOffset",903,G__G__MathCore_122_0_25, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", "! offset in fIndPoints", (void*) NULL, 0);
   G__memfunc_setup("GetIndPoints",1208,G__G__MathCore_122_0_26, 73, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBucketSize",1305,G__G__MathCore_122_0_27, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindNearestNeighbors",2036,G__G__MathCore_122_0_28, 121, -1, -1, 0, 4, 1, 1, 0, 
"D - - 10 - point i - 'Int_t' 0 - k "
"I - - 0 - ind D - - 0 - dist", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindNode",775,G__G__MathCore_122_0_29, 105, -1, -1, 0, 1, 1, 1, 8, "D - - 10 - point", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindPoint",907,G__G__MathCore_122_0_30, 121, -1, -1, 0, 3, 1, 1, 0, 
"D - - 0 - point i - - 1 - index "
"i - 'Int_t' 1 - iter", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindInRange",1061,G__G__MathCore_122_0_31, 121, -1, -1, 0, 3, 1, 1, 0, 
"D - - 0 - point d - - 0 - range "
"u 'vector<int,allocator<int> >' 'vector<int>' 1 - res", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindBNodeA",906,G__G__MathCore_122_0_32, 121, -1, -1, 0, 3, 1, 1, 0, 
"D - - 0 - point D - - 0 - delta "
"i - 'Int_t' 1 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsTerminal",1016,G__G__MathCore_122_0_33, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 8, "i - - 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsOwner",711,G__G__MathCore_122_0_34, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("KOrdStat",780,G__G__MathCore_122_0_35, 100, -1, -1, 0, 4, 1, 1, 8, 
"i - - 0 - ntotal D - - 0 - a "
"i - - 0 - k I - - 0 - index", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MakeBoundaries",1418,G__G__MathCore_122_0_36, 121, -1, -1, 0, 1, 1, 1, 0, "D - - 0 '0x0' range", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MakeBoundariesExact",1919,G__G__MathCore_122_0_37, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetData",678,G__G__MathCore_122_0_38, 121, -1, -1, 0, 4, 1, 1, 0, 
"i - - 0 - npoints i - - 0 - ndim "
"h - 'UInt_t' 0 - bsize D - - 2 - data", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetData",678,G__G__MathCore_122_0_39, 105, -1, G__defined_typename("Int_t"), 0, 2, 1, 1, 0, 
"i - - 0 - idim D - - 0 - data", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetOwner",823,G__G__MathCore_122_0_40, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - owner", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Spread",607,G__G__MathCore_122_0_41, 121, -1, -1, 0, 5, 1, 1, 8, 
"i - - 0 - ntotal D - - 0 - a "
"I - - 0 - index d - - 1 - min "
"d - - 1 - max", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TKDTree<int,double>",1759,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR), -1, 0, 1, 1, 4, 0, "u 'TKDTree<int,double>' - 11 - -", "not implemented", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR), -1, 1, 1, 1, 4, 0, "u 'TKDTree<int,double>' - 11 - -", "not implemented", (void*) NULL, 0);
   G__memfunc_setup("CookBoundaries",1432,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 2, 1, 4, 0, 
"i - 'Int_t' 10 - node g - 'Bool_t' 0 - left", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UpdateNearestNeighbors",2262,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 5, 1, 4, 0, 
"i - - 0 - inode D - - 10 - point "
"i - 'Int_t' 0 - kNN I - - 0 - ind "
"D - - 0 - dist", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UpdateRange",1104,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 4, 1, 4, 0, 
"i - - 0 - inode D - - 0 - point "
"d - - 0 - range u 'vector<int,allocator<int> >' 'vector<int>' 1 - res", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__MathCore_122_0_47, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TKDTree<int,double>::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_122_0_48, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTree<int,double>::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_122_0_49, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TKDTree<int,double>::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_122_0_50, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TKDTree<int,double>::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_122_0_54, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_122_0_55, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTree<int,double>::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_122_0_56, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TKDTree<int,double>::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_122_0_57, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTree<int,double>::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_122_0_58, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TKDTree<int,double>::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TKDTree<int,double>", 1885, G__G__MathCore_122_0_59, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTKDTreelEintcOfloatgR(void) {
   /* TKDTree<int,float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR));
   G__memfunc_setup("TKDTree<int,float>",1658,G__G__MathCore_127_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TKDTree<int,float>",1658,G__G__MathCore_127_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR), -1, 0, 3, 1, 1, 0, 
"i - - 0 - npoints i - - 0 - ndim "
"h - 'UInt_t' 0 - bsize", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TKDTree<int,float>",1658,G__G__MathCore_127_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR), -1, 0, 4, 1, 1, 0, 
"i - - 0 - npoints i - - 0 - ndim "
"h - 'UInt_t' 0 - bsize F - - 2 - data", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Build",496,G__G__MathCore_127_0_4, 121, -1, -1, 0, 0, 1, 1, 0, "", "build the tree", (void*) NULL, 0);
   G__memfunc_setup("Distance",811,G__G__MathCore_127_0_5, 100, -1, G__defined_typename("Double_t"), 0, 3, 1, 1, 8, 
"F - - 10 - point i - - 0 - ind "
"i - 'Int_t' 0 '2' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DistanceToNode",1396,G__G__MathCore_127_0_6, 121, -1, -1, 0, 5, 1, 1, 0, 
"F - - 10 - point i - - 0 - inode "
"f - - 1 - min f - - 1 - max "
"i - 'Int_t' 0 '2' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetLeft",683,G__G__MathCore_127_0_7, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetRight",798,G__G__MathCore_127_0_8, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetParent",906,G__G__MathCore_127_0_9, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetPointsIndexes",1645,G__G__MathCore_127_0_10, 73, -1, -1, 0, 1, 1, 1, 8, "i - 'Int_t' 0 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNodePointsIndexes",2035,G__G__MathCore_127_0_11, 121, -1, -1, 0, 5, 1, 1, 8, 
"i - 'Int_t' 0 - node i - 'Int_t' 1 - first1 "
"i - 'Int_t' 1 - last1 i - 'Int_t' 1 - first2 "
"i - 'Int_t' 1 - last2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNodeAxis",1083,G__G__MathCore_127_0_12, 98, -1, G__defined_typename("UChar_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - id", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNodeValue",1187,G__G__MathCore_127_0_13, 102, -1, -1, 0, 1, 1, 1, 8, "i - 'Int_t' 0 - id", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNNodes",871,G__G__MathCore_127_0_14, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTotalNodes",1309,G__G__MathCore_127_0_15, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundaries",1324,G__G__MathCore_127_0_16, 70, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundariesExact",1825,G__G__MathCore_127_0_17, 70, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundary",1124,G__G__MathCore_127_0_18, 70, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 10 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundaryExact",1625,G__G__MathCore_127_0_19, 70, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 10 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNPoints",1003,G__G__MathCore_127_0_20, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNDim",648,G__G__MathCore_127_0_21, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNPointsNode",1393,G__G__MathCore_127_0_22, 105, -1, -1, 0, 1, 1, 1, 8, "i - 'Int_t' 0 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetRowT0",732,G__G__MathCore_127_0_23, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", "! smallest terminal row", (void*) NULL, 0);
   G__memfunc_setup("GetCrossNode",1200,G__G__MathCore_127_0_24, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", "! cross node", (void*) NULL, 0);
   G__memfunc_setup("GetOffset",903,G__G__MathCore_127_0_25, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", "! offset in fIndPoints", (void*) NULL, 0);
   G__memfunc_setup("GetIndPoints",1208,G__G__MathCore_127_0_26, 73, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBucketSize",1305,G__G__MathCore_127_0_27, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindNearestNeighbors",2036,G__G__MathCore_127_0_28, 121, -1, -1, 0, 4, 1, 1, 0, 
"F - - 10 - point i - 'Int_t' 0 - k "
"I - - 0 - ind F - - 0 - dist", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindNode",775,G__G__MathCore_127_0_29, 105, -1, -1, 0, 1, 1, 1, 8, "F - - 10 - point", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindPoint",907,G__G__MathCore_127_0_30, 121, -1, -1, 0, 3, 1, 1, 0, 
"F - - 0 - point i - - 1 - index "
"i - 'Int_t' 1 - iter", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindInRange",1061,G__G__MathCore_127_0_31, 121, -1, -1, 0, 3, 1, 1, 0, 
"F - - 0 - point f - - 0 - range "
"u 'vector<int,allocator<int> >' 'vector<int>' 1 - res", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindBNodeA",906,G__G__MathCore_127_0_32, 121, -1, -1, 0, 3, 1, 1, 0, 
"F - - 0 - point F - - 0 - delta "
"i - 'Int_t' 1 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsTerminal",1016,G__G__MathCore_127_0_33, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 8, "i - - 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsOwner",711,G__G__MathCore_127_0_34, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("KOrdStat",780,G__G__MathCore_127_0_35, 102, -1, -1, 0, 4, 1, 1, 8, 
"i - - 0 - ntotal F - - 0 - a "
"i - - 0 - k I - - 0 - index", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MakeBoundaries",1418,G__G__MathCore_127_0_36, 121, -1, -1, 0, 1, 1, 1, 0, "F - - 0 '0x0' range", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MakeBoundariesExact",1919,G__G__MathCore_127_0_37, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetData",678,G__G__MathCore_127_0_38, 121, -1, -1, 0, 4, 1, 1, 0, 
"i - - 0 - npoints i - - 0 - ndim "
"h - 'UInt_t' 0 - bsize F - - 2 - data", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetData",678,G__G__MathCore_127_0_39, 105, -1, G__defined_typename("Int_t"), 0, 2, 1, 1, 0, 
"i - - 0 - idim F - - 0 - data", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetOwner",823,G__G__MathCore_127_0_40, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - owner", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Spread",607,G__G__MathCore_127_0_41, 121, -1, -1, 0, 5, 1, 1, 8, 
"i - - 0 - ntotal F - - 0 - a "
"I - - 0 - index f - - 1 - min "
"f - - 1 - max", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TKDTree<int,float>",1658,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR), -1, 0, 1, 1, 4, 0, "u 'TKDTree<int,float>' - 11 - -", "not implemented", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR), -1, 1, 1, 1, 4, 0, "u 'TKDTree<int,float>' - 11 - -", "not implemented", (void*) NULL, 0);
   G__memfunc_setup("CookBoundaries",1432,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 2, 1, 4, 0, 
"i - 'Int_t' 10 - node g - 'Bool_t' 0 - left", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UpdateNearestNeighbors",2262,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 5, 1, 4, 0, 
"i - - 0 - inode F - - 10 - point "
"i - 'Int_t' 0 - kNN I - - 0 - ind "
"F - - 0 - dist", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UpdateRange",1104,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 4, 1, 4, 0, 
"i - - 0 - inode F - - 0 - point "
"f - - 0 - range u 'vector<int,allocator<int> >' 'vector<int>' 1 - res", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__MathCore_127_0_47, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TKDTree<int,float>::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_127_0_48, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTree<int,float>::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_127_0_49, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TKDTree<int,float>::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_127_0_50, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TKDTree<int,float>::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_127_0_54, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_127_0_55, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTree<int,float>::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_127_0_56, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TKDTree<int,float>::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_127_0_57, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTree<int,float>::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_127_0_58, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TKDTree<int,float>::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TKDTree<int,float>", 1784, G__G__MathCore_127_0_59, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTKDTreeBinning(void) {
   /* TKDTreeBinning */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreeBinning));
   G__memfunc_setup("TKDTreeBinning",1336,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreeBinning), -1, 0, 1, 1, 4, 0, "u 'TKDTreeBinning' - 1 - bins", "Disallowed copy constructor", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreeBinning), -1, 0, 1, 1, 4, 0, "u 'TKDTreeBinning' - 1 - bins", "Disallowed assign operator", (void*) NULL, 0);
   G__memfunc_setup("SetData",678,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 4, 0, "D - 'Double_t' 0 - data", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetTreeData",1078,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetBinsEdges",1184,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetBinMinMaxEdges",1655,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 4, 0, "D - 'Double_t' 0 - binEdges", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetCommonBinEdges",1686,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 4, 0, "D - 'Double_t' 0 - binEdges", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetBinsContent",1427,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ReadjustMinBinEdges",1895,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 4, 0, "D - 'Double_t' 0 - binEdges", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ReadjustMaxBinEdges",1897,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 4, 0, "D - 'Double_t' 0 - binEdges", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TKDTreeBinning",1336,G__G__MathCore_130_0_11, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreeBinning), -1, 0, 4, 1, 1, 0, 
"h - 'UInt_t' 0 - dataSize h - 'UInt_t' 0 - dataDim "
"D - 'Double_t' 0 - data h - 'UInt_t' 0 '100' nBins", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetNBins",774,G__G__MathCore_130_0_12, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 - bins", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SortBinsByDensity",1743,G__G__MathCore_130_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "g - 'Bool_t' 0 'kTRUE' sortAsc", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBinsMinEdges",1464,G__G__MathCore_130_0_14, 68, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBinsMaxEdges",1466,G__G__MathCore_130_0_15, 68, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBinsEdges",1172,G__G__MathCore_130_0_16, 117, G__get_linked_tagnum(&G__G__MathCoreLN_pairlEconstsPdoublemUcOconstsPdoublemUgR), G__defined_typename("pair<const Double_t*,const Double_t*>"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBinEdges",1057,G__G__MathCore_130_0_17, 117, G__get_linked_tagnum(&G__G__MathCoreLN_pairlEconstsPdoublemUcOconstsPdoublemUgR), G__defined_typename("pair<const Double_t*,const Double_t*>"), 0, 1, 1, 1, 8, "h - 'UInt_t' 0 - bin", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBinMinEdges",1349,G__G__MathCore_130_0_18, 68, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 9, "h - 'UInt_t' 0 - bin", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBinMaxEdges",1351,G__G__MathCore_130_0_19, 68, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 9, "h - 'UInt_t' 0 - bin", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNBins",762,G__G__MathCore_130_0_20, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetDim",570,G__G__MathCore_130_0_21, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBinContent",1300,G__G__MathCore_130_0_22, 104, -1, G__defined_typename("UInt_t"), 0, 1, 1, 1, 8, "h - 'UInt_t' 0 - bin", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTree",688,G__G__MathCore_130_0_23, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR), G__defined_typename("TKDTreeID"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetDimData",948,G__G__MathCore_130_0_24, 68, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 9, "h - 'UInt_t' 0 - dim", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetDataMin",958,G__G__MathCore_130_0_25, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 8, "h - 'UInt_t' 0 - dim", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetDataMax",960,G__G__MathCore_130_0_26, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 8, "h - 'UInt_t' 0 - dim", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBinDensity",1305,G__G__MathCore_130_0_27, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 8, "h - 'UInt_t' 0 - bin", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBinVolume",1201,G__G__MathCore_130_0_28, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 8, "h - 'UInt_t' 0 - bin", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetOneDimBinEdges",1629,G__G__MathCore_130_0_29, 68, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBinCenter",1178,G__G__MathCore_130_0_30, 68, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 9, "h - 'UInt_t' 0 - bin", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBinWidth",1081,G__G__MathCore_130_0_31, 68, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 9, "h - 'UInt_t' 0 - bin", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBinMaxDensity",1599,G__G__MathCore_130_0_32, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBinMinDensity",1597,G__G__MathCore_130_0_33, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FillBinData",1050,G__G__MathCore_130_0_34, 121, -1, -1, 0, 1, 1, 1, 8, "u 'ROOT::Fit::BinData' - 1 - data", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__MathCore_130_0_35, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TKDTreeBinning::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_130_0_36, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTreeBinning::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_130_0_37, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TKDTreeBinning::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_130_0_38, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TKDTreeBinning::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_130_0_42, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_130_0_43, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTreeBinning::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_130_0_44, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TKDTreeBinning::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_130_0_45, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTreeBinning::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_130_0_46, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TKDTreeBinning::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TKDTreeBinning", 1462, G__G__MathCore_130_0_47, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEdoublecOallocatorlEdoublegRsPgR(void) {
   /* vector<double,allocator<double> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__memfunc_setup("at",213,G__G__MathCore_132_0_1, 100, -1, -1, 1, 1, 1, 1, 0, "k - 'vector<double,allocator<double> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__G__MathCore_132_0_2, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__G__MathCore_132_0_3, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__G__MathCore_132_0_4, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), G__defined_typename("vector<double,allocator<double> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__G__MathCore_132_0_5, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), G__defined_typename("vector<double,allocator<double> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__G__MathCore_132_0_6, 107, -1, G__defined_typename("vector<double,allocator<double> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__G__MathCore_132_0_7, 107, -1, G__defined_typename("vector<double,allocator<double> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__G__MathCore_132_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<double,allocator<double> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__G__MathCore_132_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'vector<double,allocator<double> >::size_type' 0 - sz d - - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__G__MathCore_132_0_10, 107, -1, G__defined_typename("vector<double,allocator<double> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__G__MathCore_132_0_11, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__G__MathCore_132_0_12, 100, -1, -1, 1, 1, 1, 1, 0, "k - 'vector<double,allocator<double> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<double,allocator<double> >",3210,G__G__MathCore_132_0_13, 105, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<double,allocator<double> >",3210,G__G__MathCore_132_0_14, 105, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR), -1, 0, 2, 1, 1, 0, 
"k - 'vector<double,allocator<double> >::size_type' 0 - n d - - 11 'double()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<double,allocator<double> >",3210,G__G__MathCore_132_0_15, 105, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<double,allocator<double> >",3210,G__G__MathCore_132_0_16, 105, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >::iterator' 'vector<double,allocator<double> >::const_iterator' 10 - first u 'vector<double,allocator<double> >::iterator' 'vector<double,allocator<double> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_132_0_17, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<double,allocator<double> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__G__MathCore_132_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<double,allocator<double> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__G__MathCore_132_0_19, 100, -1, -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__G__MathCore_132_0_20, 100, -1, -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__G__MathCore_132_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__G__MathCore_132_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__G__MathCore_132_0_23, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >::iterator' - 0 - position d - - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__G__MathCore_132_0_24, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<double,allocator<double> >::iterator' - 0 - position u 'vector<double,allocator<double> >::iterator' 'vector<double,allocator<double> >::const_iterator' 10 - first "
"u 'vector<double,allocator<double> >::iterator' 'vector<double,allocator<double> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__G__MathCore_132_0_25, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<double,allocator<double> >::iterator' - 0 - position k - 'vector<double,allocator<double> >::size_type' 0 - n "
"d - - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__G__MathCore_132_0_26, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__G__MathCore_132_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__G__MathCore_132_0_28, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >::iterator' - 0 - first u 'vector<double,allocator<double> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__G__MathCore_132_0_29, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<double,allocator<double> >", 3336, G__G__MathCore_132_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void) {
   /* vector<double,allocator<double> >::iterator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   G__memfunc_setup("iterator",874,G__G__MathCore_133_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("iterator",874,G__G__MathCore_133_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 1, 5, 1, 0, "D - 'vector<double,allocator<double> >::iterator::pointer' 11 - __i", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator*",918,G__G__MathCore_133_0_3, 100, -1, G__defined_typename("vector<double,allocator<double> >::iterator::reference"), 1, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__G__MathCore_133_0_4, 68, -1, G__defined_typename("vector<double,allocator<double> >::iterator::pointer"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__G__MathCore_133_0_5, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__G__MathCore_133_0_6, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__G__MathCore_133_0_7, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__G__MathCore_133_0_8, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__G__MathCore_133_0_9, 100, -1, G__defined_typename("vector<double,allocator<double> >::iterator::reference"), 1, 1, 1, 1, 8, "l - 'vector<double,allocator<double> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+=",980,G__G__MathCore_133_0_10, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 1, 1, 1, 1, 0, "l - 'vector<double,allocator<double> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+",919,G__G__MathCore_133_0_11, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 1, 1, 1, 8, "l - 'vector<double,allocator<double> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator-=",982,G__G__MathCore_133_0_12, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 1, 1, 1, 1, 0, "l - 'vector<double,allocator<double> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator-",921,G__G__MathCore_133_0_13, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 1, 1, 1, 8, "l - 'vector<double,allocator<double> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("base",411,G__G__MathCore_133_0_14, 68, -1, G__defined_typename("vector<double,allocator<double> >::iterator::pointer"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_133_0_15, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >::iterator' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("iterator", 874, G__G__MathCore_133_0_16, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >::iterator' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~iterator", 1000, G__G__MathCore_133_0_17, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncreverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void) {
   /* reverse_iterator<vector<double,allocator<double> >::iterator> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR));
   G__memfunc_setup("reverse_iterator<vector<double,allocator<double> >::iterator>",6055,G__G__MathCore_134_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("base",411,G__G__MathCore_134_0_2, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 0, 1, 1, 8, "", "explicit", (void*) NULL, 0);
   G__memfunc_setup("operator*",918,G__G__MathCore_134_0_3, 100, -1, G__defined_typename("reverse_iterator<vector<double,allocator<double> >::iterator>::reference"), 1, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__G__MathCore_134_0_4, 68, -1, G__defined_typename("reverse_iterator<vector<double,allocator<double> >::iterator>::pointer"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__G__MathCore_134_0_5, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__G__MathCore_134_0_6, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 0, 1, 1, 1, 0, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__G__MathCore_134_0_7, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__G__MathCore_134_0_8, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 0, 1, 1, 1, 0, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+",919,G__G__MathCore_134_0_9, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 0, 1, 1, 1, 8, "l - 'reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+=",980,G__G__MathCore_134_0_10, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 1, 1, 1, 1, 0, "l - 'reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator-",921,G__G__MathCore_134_0_11, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 0, 1, 1, 1, 8, "l - 'reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator-=",982,G__G__MathCore_134_0_12, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 1, 1, 1, 1, 0, "l - 'reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__G__MathCore_134_0_13, 100, -1, G__defined_typename("reverse_iterator<vector<double,allocator<double> >::iterator>::reference"), 1, 1, 1, 1, 8, "l - 'reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("reverse_iterator<vector<double,allocator<double> >::iterator>", 6055, G__G__MathCore_134_0_14, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 0, 1, 1, 1, 0, "u 'reverse_iterator<vector<double,allocator<double> >::iterator>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~reverse_iterator<vector<double,allocator<double> >::iterator>", 6181, G__G__MathCore_134_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_134_0_16, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 1, 1, 1, 1, 0, "u 'reverse_iterator<vector<double,allocator<double> >::iterator>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMath(void) {
   /* ROOT::Math */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__memfunc_setup("erf",317,G__G__MathCore_170_0_1, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::erf) ), 0);
   G__memfunc_setup("erfc",416,G__G__MathCore_170_0_2, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::erfc) ), 0);
   G__memfunc_setup("tgamma",631,G__G__MathCore_170_0_3, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::tgamma) ), 0);
   G__memfunc_setup("lgamma",623,G__G__MathCore_170_0_4, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::lgamma) ), 0);
   G__memfunc_setup("inc_gamma",924,G__G__MathCore_170_0_5, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::inc_gamma) ), 0);
   G__memfunc_setup("inc_gamma_c",1118,G__G__MathCore_170_0_6, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::inc_gamma_c) ), 0);
   G__memfunc_setup("beta",412,G__G__MathCore_170_0_7, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - x d - - 0 - y", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::beta) ), 0);
   G__memfunc_setup("inc_beta",821,G__G__MathCore_170_0_8, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::inc_beta) ), 0);
   G__memfunc_setup("sinint",661,G__G__MathCore_170_0_9, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::sinint) ), 0);
   G__memfunc_setup("cosint",656,G__G__MathCore_170_0_10, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::cosint) ), 0);
   G__memfunc_setup("beta_pdf",821,G__G__MathCore_170_0_11, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::beta_pdf) ), 0);
   G__memfunc_setup("binomial_pdf",1252,G__G__MathCore_170_0_12, 100, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - k d - - 0 - p "
"h - - 0 - n", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double, unsigned int))(&ROOT::Math::binomial_pdf) ), 0);
   G__memfunc_setup("negative_binomial_pdf",2198,G__G__MathCore_170_0_13, 100, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - k d - - 0 - p "
"d - - 0 - n", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double, double))(&ROOT::Math::negative_binomial_pdf) ), 0);
   G__memfunc_setup("breitwigner_pdf",1595,G__G__MathCore_170_0_14, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - gamma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::breitwigner_pdf) ), 0);
   G__memfunc_setup("cauchy_pdf",1046,G__G__MathCore_170_0_15, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' b "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::cauchy_pdf) ), 0);
   G__memfunc_setup("chisquared_pdf",1474,G__G__MathCore_170_0_16, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - r "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::chisquared_pdf) ), 0);
   G__memfunc_setup("exponential_pdf",1600,G__G__MathCore_170_0_17, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - lambda "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::exponential_pdf) ), 0);
   G__memfunc_setup("fdistribution_pdf",1823,G__G__MathCore_170_0_18, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - n "
"d - - 0 - m d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::fdistribution_pdf) ), 0);
   G__memfunc_setup("gamma_pdf",924,G__G__MathCore_170_0_19, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - alpha "
"d - - 0 - theta d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::gamma_pdf) ), 0);
   G__memfunc_setup("gaussian_pdf",1268,G__G__MathCore_170_0_20, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' sigma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::gaussian_pdf) ), 0);
   G__memfunc_setup("landau_pdf",1038,G__G__MathCore_170_0_21, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' xi "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::landau_pdf) ), 0);
   G__memfunc_setup("lognormal_pdf",1380,G__G__MathCore_170_0_22, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - m "
"d - - 0 - s d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::lognormal_pdf) ), 0);
   G__memfunc_setup("normal_pdf",1058,G__G__MathCore_170_0_23, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' sigma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::normal_pdf) ), 0);
   G__memfunc_setup("poisson_pdf",1188,G__G__MathCore_170_0_24, 100, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - n d - - 0 - mu", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double))(&ROOT::Math::poisson_pdf) ), 0);
   G__memfunc_setup("tdistribution_pdf",1837,G__G__MathCore_170_0_25, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - r "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::tdistribution_pdf) ), 0);
   G__memfunc_setup("uniform_pdf",1177,G__G__MathCore_170_0_26, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::uniform_pdf) ), 0);
   G__memfunc_setup("beta_cdf_c",1002,G__G__MathCore_170_0_27, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::beta_cdf_c) ), 0);
   G__memfunc_setup("beta_cdf",808,G__G__MathCore_170_0_28, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::beta_cdf) ), 0);
   G__memfunc_setup("breitwigner_cdf_c",1776,G__G__MathCore_170_0_29, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - gamma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::breitwigner_cdf_c) ), 0);
   G__memfunc_setup("breitwigner_cdf",1582,G__G__MathCore_170_0_30, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - gamma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::breitwigner_cdf) ), 0);
   G__memfunc_setup("cauchy_cdf_c",1227,G__G__MathCore_170_0_31, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - b "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::cauchy_cdf_c) ), 0);
   G__memfunc_setup("cauchy_cdf",1033,G__G__MathCore_170_0_32, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - b "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::cauchy_cdf) ), 0);
   G__memfunc_setup("chisquared_cdf_c",1655,G__G__MathCore_170_0_33, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - r "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::chisquared_cdf_c) ), 0);
   G__memfunc_setup("chisquared_cdf",1461,G__G__MathCore_170_0_34, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - r "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::chisquared_cdf) ), 0);
   G__memfunc_setup("exponential_cdf_c",1781,G__G__MathCore_170_0_35, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - lambda "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::exponential_cdf_c) ), 0);
   G__memfunc_setup("exponential_cdf",1587,G__G__MathCore_170_0_36, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - lambda "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::exponential_cdf) ), 0);
   G__memfunc_setup("fdistribution_cdf_c",2004,G__G__MathCore_170_0_37, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - n "
"d - - 0 - m d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::fdistribution_cdf_c) ), 0);
   G__memfunc_setup("fdistribution_cdf",1810,G__G__MathCore_170_0_38, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - n "
"d - - 0 - m d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::fdistribution_cdf) ), 0);
   G__memfunc_setup("gamma_cdf_c",1105,G__G__MathCore_170_0_39, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - alpha "
"d - - 0 - theta d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::gamma_cdf_c) ), 0);
   G__memfunc_setup("gamma_cdf",911,G__G__MathCore_170_0_40, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - alpha "
"d - - 0 - theta d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::gamma_cdf) ), 0);
   G__memfunc_setup("landau_cdf",1025,G__G__MathCore_170_0_41, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' xi "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::landau_cdf) ), 0);
   G__memfunc_setup("landau_cdf_c",1219,G__G__MathCore_170_0_42, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' xi "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::landau_cdf_c) ), 0);
   G__memfunc_setup("lognormal_cdf_c",1561,G__G__MathCore_170_0_43, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - m "
"d - - 0 - s d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::lognormal_cdf_c) ), 0);
   G__memfunc_setup("lognormal_cdf",1367,G__G__MathCore_170_0_44, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - m "
"d - - 0 - s d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::lognormal_cdf) ), 0);
   G__memfunc_setup("normal_cdf_c",1239,G__G__MathCore_170_0_45, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' sigma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::normal_cdf_c) ), 0);
   G__memfunc_setup("gaussian_cdf_c",1449,G__G__MathCore_170_0_46, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' sigma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::gaussian_cdf_c) ), 0);
   G__memfunc_setup("normal_cdf",1045,G__G__MathCore_170_0_47, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' sigma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::normal_cdf) ), 0);
   G__memfunc_setup("gaussian_cdf",1255,G__G__MathCore_170_0_48, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' sigma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::gaussian_cdf) ), 0);
   G__memfunc_setup("tdistribution_cdf_c",2018,G__G__MathCore_170_0_49, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - r "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::tdistribution_cdf_c) ), 0);
   G__memfunc_setup("tdistribution_cdf",1824,G__G__MathCore_170_0_50, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - r "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::tdistribution_cdf) ), 0);
   G__memfunc_setup("uniform_cdf_c",1358,G__G__MathCore_170_0_51, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::uniform_cdf_c) ), 0);
   G__memfunc_setup("uniform_cdf",1164,G__G__MathCore_170_0_52, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::uniform_cdf) ), 0);
   G__memfunc_setup("poisson_cdf_c",1369,G__G__MathCore_170_0_53, 100, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - n d - - 0 - mu", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double))(&ROOT::Math::poisson_cdf_c) ), 0);
   G__memfunc_setup("poisson_cdf",1175,G__G__MathCore_170_0_54, 100, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - n d - - 0 - mu", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double))(&ROOT::Math::poisson_cdf) ), 0);
   G__memfunc_setup("binomial_cdf_c",1433,G__G__MathCore_170_0_55, 100, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - k d - - 0 - p "
"h - - 0 - n", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double, unsigned int))(&ROOT::Math::binomial_cdf_c) ), 0);
   G__memfunc_setup("binomial_cdf",1239,G__G__MathCore_170_0_56, 100, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - k d - - 0 - p "
"h - - 0 - n", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double, unsigned int))(&ROOT::Math::binomial_cdf) ), 0);
   G__memfunc_setup("negative_binomial_cdf_c",2379,G__G__MathCore_170_0_57, 100, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - k d - - 0 - p "
"d - - 0 - n", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double, double))(&ROOT::Math::negative_binomial_cdf_c) ), 0);
   G__memfunc_setup("negative_binomial_cdf",2185,G__G__MathCore_170_0_58, 100, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - k d - - 0 - p "
"d - - 0 - n", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double, double))(&ROOT::Math::negative_binomial_cdf) ), 0);
   G__memfunc_setup("landau_xm1",1002,G__G__MathCore_170_0_59, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' xi "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::landau_xm1) ), 0);
   G__memfunc_setup("landau_xm2",1003,G__G__MathCore_170_0_60, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' xi "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::landau_xm2) ), 0);
   G__memfunc_setup("beta_quantile",1374,G__G__MathCore_170_0_61, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::beta_quantile) ), 0);
   G__memfunc_setup("beta_quantile_c",1568,G__G__MathCore_170_0_62, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::beta_quantile_c) ), 0);
   G__memfunc_setup("cauchy_quantile_c",1793,G__G__MathCore_170_0_63, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::cauchy_quantile_c) ), 0);
   G__memfunc_setup("cauchy_quantile",1599,G__G__MathCore_170_0_64, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::cauchy_quantile) ), 0);
   G__memfunc_setup("breitwigner_quantile_c",2342,G__G__MathCore_170_0_65, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - gamma", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::breitwigner_quantile_c) ), 0);
   G__memfunc_setup("breitwigner_quantile",2148,G__G__MathCore_170_0_66, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - gamma", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::breitwigner_quantile) ), 0);
   G__memfunc_setup("chisquared_quantile_c",2221,G__G__MathCore_170_0_67, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - r", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::chisquared_quantile_c) ), 0);
   G__memfunc_setup("chisquared_quantile",2027,G__G__MathCore_170_0_68, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - r", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::chisquared_quantile) ), 0);
   G__memfunc_setup("exponential_quantile_c",2347,G__G__MathCore_170_0_69, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - lambda", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::exponential_quantile_c) ), 0);
   G__memfunc_setup("exponential_quantile",2153,G__G__MathCore_170_0_70, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - lambda", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::exponential_quantile) ), 0);
   G__memfunc_setup("fdistribution_quantile",2376,G__G__MathCore_170_0_71, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - n "
"d - - 0 - m", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::fdistribution_quantile) ), 0);
   G__memfunc_setup("fdistribution_quantile_c",2570,G__G__MathCore_170_0_72, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - n "
"d - - 0 - m", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::fdistribution_quantile_c) ), 0);
   G__memfunc_setup("gamma_quantile_c",1671,G__G__MathCore_170_0_73, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - alpha "
"d - - 0 - theta", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::gamma_quantile_c) ), 0);
   G__memfunc_setup("gamma_quantile",1477,G__G__MathCore_170_0_74, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - alpha "
"d - - 0 - theta", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::gamma_quantile) ), 0);
   G__memfunc_setup("gaussian_quantile_c",2015,G__G__MathCore_170_0_75, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - sigma", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::gaussian_quantile_c) ), 0);
   G__memfunc_setup("gaussian_quantile",1821,G__G__MathCore_170_0_76, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - sigma", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::gaussian_quantile) ), 0);
   G__memfunc_setup("lognormal_quantile_c",2127,G__G__MathCore_170_0_77, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - m "
"d - - 0 - s", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::lognormal_quantile_c) ), 0);
   G__memfunc_setup("lognormal_quantile",1933,G__G__MathCore_170_0_78, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - m "
"d - - 0 - s", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::lognormal_quantile) ), 0);
   G__memfunc_setup("normal_quantile_c",1805,G__G__MathCore_170_0_79, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - sigma", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::normal_quantile_c) ), 0);
   G__memfunc_setup("normal_quantile",1611,G__G__MathCore_170_0_80, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - sigma", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::normal_quantile) ), 0);
   G__memfunc_setup("uniform_quantile_c",1924,G__G__MathCore_170_0_81, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::uniform_quantile_c) ), 0);
   G__memfunc_setup("uniform_quantile",1730,G__G__MathCore_170_0_82, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::uniform_quantile) ), 0);
   G__memfunc_setup("landau_quantile",1591,G__G__MathCore_170_0_83, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 '1' xi", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::landau_quantile) ), 0);
   G__memfunc_setup("landau_quantile_c",1785,G__G__MathCore_170_0_84, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 '1' xi", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::landau_quantile_c) ), 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIBaseFunctionOneDim(void) {
   /* ROOT::Math::IBaseFunctionOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim));
   G__memfunc_setup("Clone",497,G__G__MathCore_171_0_2, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("operator()",957,G__G__MathCore_171_0_3, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathCore_171_0_4, 100, -1, -1, 0, 1, 1, 1, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~IBaseFunctionOneDim", 1988, G__G__MathCore_171_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_171_0_7, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionOneDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIGradientFunctionOneDim(void) {
   /* ROOT::Math::IGradientFunctionOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim));
   G__memfunc_setup("FdF",240,(G__InterfaceMethod) NULL,121, -1, -1, 0, 3, 1, 1, 8, 
"d - - 0 - x d - - 1 - f "
"d - - 1 - df", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~IGradientFunctionOneDim", 2423, G__G__MathCore_172_0_2, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_172_0_3, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IGradientFunctionOneDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIBaseFunctionMultiDim(void) {
   /* ROOT::Math::IBaseFunctionMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim));
   G__memfunc_setup("Clone",497,G__G__MathCore_173_0_2, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NDim",360,G__G__MathCore_173_0_3, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("operator()",957,G__G__MathCore_173_0_4, 100, -1, -1, 0, 1, 1, 1, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~IBaseFunctionMultiDim", 2221, G__G__MathCore_173_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_173_0_7, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIGradientFunctionMultiDim(void) {
   /* ROOT::Math::IGradientFunctionMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim));
   G__memfunc_setup("Gradient",814,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x D - - 0 - grad", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FdF",240,(G__InterfaceMethod) NULL,121, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x d - - 1 - f "
"D - - 0 - df", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~IGradientFunctionMultiDim", 2656, G__G__MathCore_174_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_174_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IGradientFunctionMultiDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIGradientMultiDim(void) {
   /* ROOT::Math::IGradientMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim));
   G__memfunc_setup("Gradient",814,G__G__MathCore_175_0_1, 121, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x D - - 0 - grad", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Derivative",1043,G__G__MathCore_175_0_2, 100, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x h - - 0 '0' icoord", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FdF",240,G__G__MathCore_175_0_3, 121, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x d - - 1 - f "
"D - - 0 - df", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("DoDerivative",1222,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 2, 1, 4, 8, 
"D - - 10 - x h - - 0 - icoord", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~IGradientMultiDim", 1818, G__G__MathCore_175_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_175_0_6, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IGradientMultiDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIGradientOneDim(void) {
   /* ROOT::Math::IGradientOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim));
   G__memfunc_setup("Derivative",1043,G__G__MathCore_176_0_1, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FdF",240,G__G__MathCore_176_0_2, 121, -1, -1, 0, 3, 1, 1, 8, 
"d - - 0 - x d - - 1 - f "
"d - - 1 - df", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Derivative",1043,G__G__MathCore_176_0_3, 100, -1, -1, 0, 1, 1, 1, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gradient",814,G__G__MathCore_176_0_4, 121, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x D - - 0 - g", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FdF",240,G__G__MathCore_176_0_5, 121, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x d - - 1 - f "
"D - - 0 - df", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoDerivative",1222,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~IGradientOneDim", 1585, G__G__MathCore_176_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_176_0_8, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IGradientOneDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIParametricFunctionOneDim(void) {
   /* ROOT::Math::IParametricFunctionOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim));
   G__memfunc_setup("operator()",957,G__G__MathCore_177_0_1, 100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - x D - - 10 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathCore_177_0_2, 100, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x D - - 10 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoEvalPar",862,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 2, 1, 4, 8, 
"d - - 0 - x D - - 10 - p", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~IParametricFunctionOneDim", 2641, G__G__MathCore_177_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_177_0_6, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IParametricFunctionOneDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIParametricGradFunctionOneDim(void) {
   /* ROOT::Math::IParametricGradFunctionOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim));
   G__memfunc_setup("ParameterGradient",1743,G__G__MathCore_178_0_1, 121, -1, -1, 0, 3, 1, 1, 8, 
"d - - 0 - x D - - 10 - p "
"D - - 0 - grad", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ParameterGradient",1743,G__G__MathCore_178_0_2, 121, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - x D - - 0 - grad", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterGradient",1743,G__G__MathCore_178_0_3, 121, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x D - - 10 - p "
"D - - 0 - grad", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterGradient",1743,G__G__MathCore_178_0_4, 121, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x D - - 0 - grad", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterDerivative",1972,G__G__MathCore_178_0_5, 100, -1, -1, 0, 3, 1, 1, 8, 
"d - - 0 - x D - - 10 - p "
"h - - 0 '0' ipar", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterDerivative",1972,G__G__MathCore_178_0_6, 100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - x h - - 0 '0' ipar", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterDerivative",1972,G__G__MathCore_178_0_7, 100, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x D - - 10 - p "
"h - - 0 '0' ipar", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterDerivative",1972,G__G__MathCore_178_0_8, 100, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x h - - 0 '0' ipar", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoParameterDerivative",2151,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 3, 1, 4, 8, 
"d - - 0 - x D - - 10 - p "
"h - - 0 - ipar", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~IParametricGradFunctionOneDim", 3023, G__G__MathCore_178_0_10, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_178_0_11, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IParametricGradFunctionOneDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIParametricFunctionMultiDim(void) {
   /* ROOT::Math::IParametricFunctionMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim));
   G__memfunc_setup("operator()",957,G__G__MathCore_179_0_1, 100, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x D - - 10 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoEvalPar",862,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 2, 1, 4, 8, 
"D - - 10 - x D - - 10 - p", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~IParametricFunctionMultiDim", 2874, G__G__MathCore_179_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_179_0_5, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IParametricFunctionMultiDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void) {
   /* ROOT::Math::IParametricGradFunctionMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim));
   G__memfunc_setup("ParameterGradient",1743,G__G__MathCore_180_0_1, 121, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x D - - 10 - p "
"D - - 0 - grad", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ParameterDerivative",1972,G__G__MathCore_180_0_2, 100, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x D - - 10 - p "
"h - - 0 '0' ipar", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterGradient",1743,G__G__MathCore_180_0_3, 121, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x D - - 0 - grad", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterDerivative",1972,G__G__MathCore_180_0_4, 100, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x h - - 0 '0' ipar", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoParameterDerivative",2151,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 3, 1, 4, 8, 
"D - - 10 - x D - - 10 - p "
"h - - 0 - ipar", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~IParametricGradFunctionMultiDim", 3256, G__G__MathCore_180_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_180_0_7, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IParametricGradFunctionMultiDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIBaseParam(void) {
   /* ROOT::Math::IBaseParam */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam));
   G__memfunc_setup("Parameters",1044,G__G__MathCore_182_0_1, 68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetParameters",1344,G__G__MathCore_182_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "D - - 10 - p", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NPar",369,G__G__MathCore_182_0_3, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("ParameterName",1314,G__G__MathCore_182_0_4, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 0, 1, 1, 1, 8, "h - - 0 - i", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~IBaseParam", 1075, G__G__MathCore_182_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_182_0_6, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IBaseParam' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLParamFunctor(void) {
   /* ROOT::Math::ParamFunctor */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor));
   G__memfunc_setup("ParamFunctor",1234,G__G__MathCore_184_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParamFunctor",1234,G__G__MathCore_184_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor), -1, 0, 1, 1, 1, 0, "Y - 'ROOT::Math::ParamFunctor::FreeFunc' 0 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParamFunctor",1234,G__G__MathCore_184_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::ParamFunctor' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_184_0_4, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::ParamFunctor' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetImpl",690,G__G__MathCore_184_0_5, 89, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathCore_184_0_6, 100, -1, -1, 0, 2, 1, 1, 0, 
"D - - 0 - x D - - 0 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Empty",527,G__G__MathCore_184_0_7, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_184_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "U 'ROOT::Math::ParamFunctionBase' 'ROOT::Math::ParamFunctor::Impl' 0 - f", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ParamFunctor", 1360, G__G__MathCore_184_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLFunctor(void) {
   /* ROOT::Math::Functor */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   G__memfunc_setup("Functor",737,G__G__MathCore_185_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Functor",737,G__G__MathCore_185_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor), -1, 0, 4, 1, 1, 0, 
"Y - - 0 - p h - - 0 - dim "
"C - - 10 '0' className C - - 10 '0' methodName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_185_0_3, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Functor' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim), G__defined_typename("ROOT::Math::Functor::ImplBase"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NDim",360,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("Functor", 737, G__G__MathCore_185_0_7, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Functor' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Functor", 863, G__G__MathCore_185_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLFunctor1D(void) {
   /* ROOT::Math::Functor1D */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   G__memfunc_setup("Functor1D",854,G__G__MathCore_187_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Functor1D",854,G__G__MathCore_187_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D), -1, 0, 3, 1, 1, 0, 
"Y - - 0 - p C - - 10 '0' className "
"C - - 10 '0' methodName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_187_0_3, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Functor1D' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim), G__defined_typename("ROOT::Math::Functor1D::ImplBase"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("Functor1D", 854, G__G__MathCore_187_0_6, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Functor1D' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Functor1D", 980, G__G__MathCore_187_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGradFunctor(void) {
   /* ROOT::Math::GradFunctor */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   G__memfunc_setup("GradFunctor",1119,G__G__MathCore_189_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GradFunctor",1119,G__G__MathCore_189_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor), -1, 0, 5, 1, 1, 0, 
"Y - - 0 - p1 h - - 0 - dim "
"C - - 10 - className C - - 10 - methodName "
"C - - 10 - derivName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GradFunctor",1119,G__G__MathCore_189_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor), -1, 0, 3, 1, 1, 0, 
"Y - - 0 - p1 Y - - 0 - p2 "
"h - - 0 - dim", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_189_0_4, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GradFunctor' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim), G__defined_typename("ROOT::Math::GradFunctor::ImplBase"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NDim",360,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoDerivative",1222,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 2, 1, 4, 8, 
"D - - 10 - x h - - 0 - icoord", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("GradFunctor", 1119, G__G__MathCore_189_0_9, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GradFunctor' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GradFunctor", 1245, G__G__MathCore_189_0_10, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGradFunctor1D(void) {
   /* ROOT::Math::GradFunctor1D */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   G__memfunc_setup("GradFunctor1D",1236,G__G__MathCore_191_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GradFunctor1D",1236,G__G__MathCore_191_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D), -1, 0, 4, 1, 1, 0, 
"Y - - 0 - p1 C - - 10 - className "
"C - - 10 - methodName C - - 10 - derivName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GradFunctor1D",1236,G__G__MathCore_191_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D), -1, 0, 2, 1, 1, 0, 
"Y - - 0 - p1 Y - - 0 - p2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_191_0_4, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GradFunctor1D' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim), G__defined_typename("ROOT::Math::GradFunctor1D::ImplBase"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoDerivative",1222,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("GradFunctor1D", 1236, G__G__MathCore_191_0_8, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GradFunctor1D' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GradFunctor1D", 1362, G__G__MathCore_191_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIOptions(void) {
   /* ROOT::Math::IOptions */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions));
   G__memfunc_setup("Clone",497,G__G__MathCore_193_0_2, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetValue",809,G__G__MathCore_193_0_3, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - name d - - 0 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetValue",809,G__G__MathCore_193_0_4, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - name i - - 0 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetValue",809,G__G__MathCore_193_0_5, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - name C - - 10 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RValue",591,G__G__MathCore_193_0_6, 100, -1, -1, 0, 1, 1, 1, 8, "C - - 10 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IValue",582,G__G__MathCore_193_0_7, 105, -1, -1, 0, 1, 1, 1, 8, "C - - 10 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NamedValue",994,G__G__MathCore_193_0_8, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 0, 1, 1, 1, 8, "C - - 10 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetRealValue",1185,G__G__MathCore_193_0_9, 103, -1, -1, 0, 2, 1, 1, 8, 
"C - - 10 - - d - - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetIntValue",1096,G__G__MathCore_193_0_10, 103, -1, -1, 0, 2, 1, 1, 8, 
"C - - 10 - - i - - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetNamedValue",1282,G__G__MathCore_193_0_11, 103, -1, -1, 0, 2, 1, 1, 8, 
"C - - 10 - - u 'string' - 1 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetRealValue",1197,G__G__MathCore_193_0_12, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - - d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetIntValue",1108,G__G__MathCore_193_0_13, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - - i - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetNamedValue",1294,G__G__MathCore_193_0_14, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - - C - - 10 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,G__G__MathCore_193_0_15, 121, -1, -1, 0, 1, 1, 1, 8, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoGetValue",976,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 2, 1, 4, 8, 
"C - - 10 - name d - - 1 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoGetValue",976,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 2, 1, 4, 8, 
"C - - 10 - name i - - 1 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoGetValue",976,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 2, 1, 4, 8, 
"C - - 10 - name u 'string' - 1 - val", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~IOptions", 947, G__G__MathCore_193_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_193_0_20, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IOptions' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLMinimizerOptions(void) {
   /* ROOT::Math::MinimizerOptions */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions));
   G__memfunc_setup("SetDefaultMinimizer",1957,G__G__MathCore_194_0_1, 121, -1, -1, 0, 2, 3, 1, 0, 
"C - - 10 - type C - - 10 '0' algo", (char*)NULL, (void*) G__func2void( (void (*)(const char*, const char*))(&ROOT::Math::MinimizerOptions::SetDefaultMinimizer) ), 0);
   G__memfunc_setup("SetDefaultErrorDef",1802,G__G__MathCore_194_0_2, 121, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - up", (char*)NULL, (void*) G__func2void( (void (*)(double))(&ROOT::Math::MinimizerOptions::SetDefaultErrorDef) ), 0);
   G__memfunc_setup("SetDefaultTolerance",1934,G__G__MathCore_194_0_3, 121, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - tol", (char*)NULL, (void*) G__func2void( (void (*)(double))(&ROOT::Math::MinimizerOptions::SetDefaultTolerance) ), 0);
   G__memfunc_setup("SetDefaultPrecision",1949,G__G__MathCore_194_0_4, 121, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - prec", (char*)NULL, (void*) G__func2void( (void (*)(double))(&ROOT::Math::MinimizerOptions::SetDefaultPrecision) ), 0);
   G__memfunc_setup("SetDefaultMaxFunctionCalls",2636,G__G__MathCore_194_0_5, 121, -1, -1, 0, 1, 3, 1, 0, "i - - 0 - maxcall", (char*)NULL, (void*) G__func2void( (void (*)(int))(&ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls) ), 0);
   G__memfunc_setup("SetDefaultMaxIterations",2361,G__G__MathCore_194_0_6, 121, -1, -1, 0, 1, 3, 1, 0, "i - - 0 - maxiter", (char*)NULL, (void*) G__func2void( (void (*)(int))(&ROOT::Math::MinimizerOptions::SetDefaultMaxIterations) ), 0);
   G__memfunc_setup("SetDefaultStrategy",1860,G__G__MathCore_194_0_7, 121, -1, -1, 0, 1, 3, 1, 0, "i - - 0 - strat", (char*)NULL, (void*) G__func2void( (void (*)(int))(&ROOT::Math::MinimizerOptions::SetDefaultStrategy) ), 0);
   G__memfunc_setup("SetDefaultPrintLevel",2038,G__G__MathCore_194_0_8, 121, -1, -1, 0, 1, 3, 1, 0, "i - - 0 - level", (char*)NULL, (void*) G__func2void( (void (*)(int))(&ROOT::Math::MinimizerOptions::SetDefaultPrintLevel) ), 0);
   G__memfunc_setup("DefaultMinimizerType",2075,G__G__MathCore_194_0_9, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const string& (*)())(&ROOT::Math::MinimizerOptions::DefaultMinimizerType) ), 0);
   G__memfunc_setup("DefaultMinimizerAlgo",2044,G__G__MathCore_194_0_10, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const string& (*)())(&ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo) ), 0);
   G__memfunc_setup("DefaultErrorDef",1502,G__G__MathCore_194_0_11, 100, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (double (*)())(&ROOT::Math::MinimizerOptions::DefaultErrorDef) ), 0);
   G__memfunc_setup("DefaultTolerance",1634,G__G__MathCore_194_0_12, 100, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (double (*)())(&ROOT::Math::MinimizerOptions::DefaultTolerance) ), 0);
   G__memfunc_setup("DefaultPrecision",1649,G__G__MathCore_194_0_13, 100, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (double (*)())(&ROOT::Math::MinimizerOptions::DefaultPrecision) ), 0);
   G__memfunc_setup("DefaultMaxFunctionCalls",2336,G__G__MathCore_194_0_14, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ROOT::Math::MinimizerOptions::DefaultMaxFunctionCalls) ), 0);
   G__memfunc_setup("DefaultMaxIterations",2061,G__G__MathCore_194_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ROOT::Math::MinimizerOptions::DefaultMaxIterations) ), 0);
   G__memfunc_setup("DefaultStrategy",1560,G__G__MathCore_194_0_16, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ROOT::Math::MinimizerOptions::DefaultStrategy) ), 0);
   G__memfunc_setup("DefaultPrintLevel",1738,G__G__MathCore_194_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ROOT::Math::MinimizerOptions::DefaultPrintLevel) ), 0);
   G__memfunc_setup("Default",709,G__G__MathCore_194_0_18, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions), -1, 1, 1, 3, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (ROOT::Math::IOptions& (*)(const char*))(&ROOT::Math::MinimizerOptions::Default) ), 0);
   G__memfunc_setup("FindDefault",1094,G__G__MathCore_194_0_19, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions), -1, 0, 1, 3, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (ROOT::Math::IOptions* (*)(const char*))(&ROOT::Math::MinimizerOptions::FindDefault) ), 0);
   G__memfunc_setup("PrintDefault",1234,G__G__MathCore_194_0_20, 121, -1, -1, 0, 2, 3, 1, 0, 
"C - - 10 '0' name u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) G__func2void( (void (*)(const char*, ostream&))(&ROOT::Math::MinimizerOptions::PrintDefault) ), 0);
   G__memfunc_setup("MinimizerOptions",1696,G__G__MathCore_194_0_21, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions), -1, 0, 1, 1, 1, 0, "U 'ROOT::Math::IOptions' - 0 '0' extraOpts", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MinimizerOptions",1696,G__G__MathCore_194_0_22, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::MinimizerOptions' - 11 - opt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_194_0_23, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::MinimizerOptions' - 11 - opt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintLevel",1029,G__G__MathCore_194_0_24, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MaxFunctionCalls",1627,G__G__MathCore_194_0_25, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MaxIterations",1352,G__G__MathCore_194_0_26, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Strategy",851,G__G__MathCore_194_0_27, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Tolerance",925,G__G__MathCore_194_0_28, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Precision",940,G__G__MathCore_194_0_29, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ErrorDef",793,G__G__MathCore_194_0_30, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ExtraOptions",1264,G__G__MathCore_194_0_31, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MinimizerType",1366,G__G__MathCore_194_0_32, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MinimizerAlgorithm",1883,G__G__MathCore_194_0_33, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,G__G__MathCore_194_0_34, 121, -1, -1, 0, 1, 1, 1, 8, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPrintLevel",1329,G__G__MathCore_194_0_35, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - level", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMaxFunctionCalls",1927,G__G__MathCore_194_0_36, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - maxfcn", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMaxIterations",1652,G__G__MathCore_194_0_37, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - maxiter", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetTolerance",1225,G__G__MathCore_194_0_38, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - tol", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPrecision",1240,G__G__MathCore_194_0_39, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - prec", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetStrategy",1151,G__G__MathCore_194_0_40, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - stra", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetErrorDef",1093,G__G__MathCore_194_0_41, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - err", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMinimizerType",1666,G__G__MathCore_194_0_42, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMinimizerAlgorithm",2183,G__G__MathCore_194_0_43, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetExtraOptions",1564,G__G__MathCore_194_0_44, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IOptions' - 11 - opt", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~MinimizerOptions", 1822, G__G__MathCore_194_0_45, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLMinimizer(void) {
   /* ROOT::Math::Minimizer */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizer));
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizer), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::Minimizer' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clear",487,G__G__MathCore_195_0_4, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_195_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - func", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_195_0_6, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IGradientFunctionMultiDim' 'ROOT::Math::IMultiGradFunction' 11 - func", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariable",1106,G__G__MathCore_195_0_7, 103, -1, -1, 0, 4, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetLowerLimitedVariable",2339,G__G__MathCore_195_0_8, 103, -1, -1, 0, 5, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step "
"d - - 0 - lower", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetUpperLimitedVariable",2342,G__G__MathCore_195_0_9, 103, -1, -1, 0, 5, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step "
"d - - 0 - upper", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetLimitedVariable",1818,G__G__MathCore_195_0_10, 103, -1, -1, 0, 6, 1, 1, 0, 
"h - - 0 - - u 'string' - 11 - - "
"d - - 0 - - d - - 0 - - "
"d - - 0 - - d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFixedVariable",1602,G__G__MathCore_195_0_11, 103, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - - u 'string' - 11 - - "
"d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariableValue",1615,G__G__MathCore_195_0_12, 103, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - - d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariableValues",1730,G__G__MathCore_195_0_13, 103, -1, -1, 0, 1, 1, 1, 0, "D - - 10 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Minimize",834,G__G__MathCore_195_0_14, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("MinValue",801,G__G__MathCore_195_0_15, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Edm",278,G__G__MathCore_195_0_16, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("X",88,G__G__MathCore_195_0_17, 68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("MinGradient",1106,G__G__MathCore_195_0_18, 68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NCalls",573,G__G__MathCore_195_0_19, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NDim",360,G__G__MathCore_195_0_20, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NFree",464,G__G__MathCore_195_0_21, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("ProvidesError",1366,G__G__MathCore_195_0_22, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Errors",637,G__G__MathCore_195_0_23, 68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("CovMatrix",925,G__G__MathCore_195_0_24, 100, -1, -1, 0, 2, 1, 1, 8, 
"h - - 0 - i h - - 0 - j", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("CovMatrixStatus",1569,G__G__MathCore_195_0_25, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Correlation",1154,G__G__MathCore_195_0_26, 100, -1, -1, 0, 2, 1, 1, 8, 
"h - - 0 - i h - - 0 - j", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GlobalCC",727,G__G__MathCore_195_0_27, 100, -1, -1, 0, 1, 1, 1, 8, "h - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetMinosError",1328,G__G__MathCore_195_0_28, 103, -1, -1, 0, 4, 1, 1, 0, 
"h - - 0 - - d - - 1 - errLow "
"d - - 1 - errUp i - - 0 '0' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Hesse",504,G__G__MathCore_195_0_29, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Scan",389,G__G__MathCore_195_0_30, 103, -1, -1, 0, 6, 1, 1, 0, 
"h - - 0 - - h - - 1 - - "
"D - - 0 - - D - - 0 - - "
"d - - 0 '0' - d - - 0 '0' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Contour",746,G__G__MathCore_195_0_31, 103, -1, -1, 0, 5, 1, 1, 0, 
"h - - 0 - - h - - 0 - - "
"h - - 1 - - D - - 0 - - "
"D - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("PrintResults",1279,G__G__MathCore_195_0_32, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("VariableName",1191,G__G__MathCore_195_0_33, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 0, 1, 1, 1, 8, "h - - 0 - -", "return empty string ", (void*) NULL, 1);
   G__memfunc_setup("VariableIndex",1310,G__G__MathCore_195_0_34, 105, -1, -1, 0, 1, 1, 1, 8, "u 'string' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("PrintLevel",1029,G__G__MathCore_195_0_35, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MaxFunctionCalls",1627,G__G__MathCore_195_0_36, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MaxIterations",1352,G__G__MathCore_195_0_37, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Tolerance",925,G__G__MathCore_195_0_38, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Precision",940,G__G__MathCore_195_0_39, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Strategy",851,G__G__MathCore_195_0_40, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Status",644,G__G__MathCore_195_0_41, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ErrorDef",793,G__G__MathCore_195_0_42, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsValidError",1206,G__G__MathCore_195_0_43, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Options",748,G__G__MathCore_195_0_44, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetPrintLevel",1329,G__G__MathCore_195_0_45, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - level", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMaxFunctionCalls",1927,G__G__MathCore_195_0_46, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - maxfcn", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMaxIterations",1652,G__G__MathCore_195_0_47, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - maxiter", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetTolerance",1225,G__G__MathCore_195_0_48, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - tol", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPrecision",1240,G__G__MathCore_195_0_49, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - prec", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetStrategy",1151,G__G__MathCore_195_0_50, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - strategyLevel", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetErrorDef",1093,G__G__MathCore_195_0_51, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - up", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetValidError",1318,G__G__MathCore_195_0_52, 121, -1, -1, 0, 1, 1, 1, 0, "g - - 0 - on", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetOptions",1048,G__G__MathCore_195_0_53, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::MinimizerOptions' - 11 - opt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetDefaultOptions",1757,G__G__MathCore_195_0_54, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Minimizer", 1074, G__G__MathCore_195_0_55, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIntegrationOneDim(void) {
   /* ROOT::Math::IntegrationOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDim));
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIntegrationMultiDim(void) {
   /* ROOT::Math::IntegrationMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDim));
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLBaseIntegratorOptions(void) {
   /* ROOT::Math::BaseIntegratorOptions */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBaseIntegratorOptions));
   G__memfunc_setup("operator=",937,G__G__MathCore_200_0_3, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBaseIntegratorOptions), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::BaseIntegratorOptions' - 11 - opt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integrator",1055,G__G__MathCore_200_0_4, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("AbsTolerance",1203,G__G__MathCore_200_0_5, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RelTolerance",1216,G__G__MathCore_200_0_6, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("WKSize",573,G__G__MathCore_200_0_7, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ExtraOptions",1264,G__G__MathCore_200_0_8, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetAbsTolerance",1503,G__G__MathCore_200_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - tol", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRelTolerance",1516,G__G__MathCore_200_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - tol", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetWKSize",873,G__G__MathCore_200_0_11, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetExtraOptions",1564,G__G__MathCore_200_0_12, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IOptions' - 11 - opt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ClearExtra",1003,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 2, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BaseIntegratorOptions", 2308, G__G__MathCore_200_0_14, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIntegratorOneDimOptions(void) {
   /* ROOT::Math::IntegratorOneDimOptions */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions));
   G__memfunc_setup("IntegratorOneDimOptions",2375,G__G__MathCore_201_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions), -1, 0, 1, 1, 1, 0, "U 'ROOT::Math::IOptions' - 0 '0' extraOpts", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegratorOneDimOptions",2375,G__G__MathCore_201_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IntegratorOneDimOptions' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_201_0_3, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IntegratorOneDimOptions' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetNPoints",1015,G__G__MathCore_201_0_4, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NPoints",715,G__G__MathCore_201_0_5, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integrator",1055,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntegratorType",1473,G__G__MathCore_201_0_7, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetIntegrator",1355,G__G__MathCore_201_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,G__G__MathCore_201_0_9, 121, -1, -1, 0, 1, 1, 1, 8, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetDefaultIntegrator",2064,G__G__MathCore_201_0_10, 121, -1, -1, 0, 1, 3, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (void (*)(const char*))(&ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator) ), 0);
   G__memfunc_setup("SetDefaultAbsTolerance",2212,G__G__MathCore_201_0_11, 121, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - tol", (char*)NULL, (void*) G__func2void( (void (*)(double))(&ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance) ), 0);
   G__memfunc_setup("SetDefaultRelTolerance",2225,G__G__MathCore_201_0_12, 121, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - tol", (char*)NULL, (void*) G__func2void( (void (*)(double))(&ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance) ), 0);
   G__memfunc_setup("SetDefaultWKSize",1582,G__G__MathCore_201_0_13, 121, -1, -1, 0, 1, 3, 1, 0, "h - - 0 - size", (char*)NULL, (void*) G__func2void( (void (*)(unsigned int))(&ROOT::Math::IntegratorOneDimOptions::SetDefaultWKSize) ), 0);
   G__memfunc_setup("SetDefaultNPoints",1724,G__G__MathCore_201_0_14, 121, -1, -1, 0, 1, 3, 1, 0, "h - - 0 - n", (char*)NULL, (void*) G__func2void( (void (*)(unsigned int))(&ROOT::Math::IntegratorOneDimOptions::SetDefaultNPoints) ), 0);
   G__memfunc_setup("DefaultIntegrator",1764,G__G__MathCore_201_0_15, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (string (*)())(&ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator) ), 0);
   G__memfunc_setup("DefaultIntegratorType",2182,G__G__MathCore_201_0_16, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (ROOT::Math::IntegrationOneDim::Type (*)())(&ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType) ), 0);
   G__memfunc_setup("DefaultAbsTolerance",1912,G__G__MathCore_201_0_17, 100, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (double (*)())(&ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerance) ), 0);
   G__memfunc_setup("DefaultRelTolerance",1925,G__G__MathCore_201_0_18, 100, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (double (*)())(&ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerance) ), 0);
   G__memfunc_setup("DefaultWKSize",1282,G__G__MathCore_201_0_19, 104, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (unsigned int (*)())(&ROOT::Math::IntegratorOneDimOptions::DefaultWKSize) ), 0);
   G__memfunc_setup("DefaultNPoints",1424,G__G__MathCore_201_0_20, 104, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (unsigned int (*)())(&ROOT::Math::IntegratorOneDimOptions::DefaultNPoints) ), 0);
   G__memfunc_setup("Default",709,G__G__MathCore_201_0_21, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions), -1, 1, 1, 3, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (ROOT::Math::IOptions& (*)(const char*))(&ROOT::Math::IntegratorOneDimOptions::Default) ), 0);
   G__memfunc_setup("FindDefault",1094,G__G__MathCore_201_0_22, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions), -1, 0, 1, 3, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (ROOT::Math::IOptions* (*)(const char*))(&ROOT::Math::IntegratorOneDimOptions::FindDefault) ), 0);
   G__memfunc_setup("PrintDefault",1234,G__G__MathCore_201_0_23, 121, -1, -1, 0, 2, 3, 1, 0, 
"C - - 10 '0' name u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) G__func2void( (void (*)(const char*, ostream&))(&ROOT::Math::IntegratorOneDimOptions::PrintDefault) ), 0);
   // automatic destructor
   G__memfunc_setup("~IntegratorOneDimOptions", 2501, G__G__MathCore_201_0_24, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIntegratorMultiDimOptions(void) {
   /* ROOT::Math::IntegratorMultiDimOptions */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions));
   G__memfunc_setup("IntegratorMultiDimOptions",2608,G__G__MathCore_202_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions), -1, 0, 1, 1, 1, 0, "U 'ROOT::Math::IOptions' - 0 '0' extraOpts", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegratorMultiDimOptions",2608,G__G__MathCore_202_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IntegratorMultiDimOptions' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_202_0_3, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IntegratorMultiDimOptions' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetNCalls",873,G__G__MathCore_202_0_4, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - calls", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NCalls",573,G__G__MathCore_202_0_5, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integrator",1055,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntegratorType",1473,G__G__MathCore_202_0_7, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetIntegrator",1355,G__G__MathCore_202_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,G__G__MathCore_202_0_9, 121, -1, -1, 0, 1, 1, 1, 8, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetDefaultIntegrator",2064,G__G__MathCore_202_0_10, 121, -1, -1, 0, 1, 3, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (void (*)(const char*))(&ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator) ), 0);
   G__memfunc_setup("SetDefaultAbsTolerance",2212,G__G__MathCore_202_0_11, 121, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - tol", (char*)NULL, (void*) G__func2void( (void (*)(double))(&ROOT::Math::IntegratorMultiDimOptions::SetDefaultAbsTolerance) ), 0);
   G__memfunc_setup("SetDefaultRelTolerance",2225,G__G__MathCore_202_0_12, 121, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - tol", (char*)NULL, (void*) G__func2void( (void (*)(double))(&ROOT::Math::IntegratorMultiDimOptions::SetDefaultRelTolerance) ), 0);
   G__memfunc_setup("SetDefaultWKSize",1582,G__G__MathCore_202_0_13, 121, -1, -1, 0, 1, 3, 1, 0, "h - - 0 - size", (char*)NULL, (void*) G__func2void( (void (*)(unsigned int))(&ROOT::Math::IntegratorMultiDimOptions::SetDefaultWKSize) ), 0);
   G__memfunc_setup("SetDefaultNCalls",1582,G__G__MathCore_202_0_14, 121, -1, -1, 0, 1, 3, 1, 0, "h - - 0 - ncall", (char*)NULL, (void*) G__func2void( (void (*)(unsigned int))(&ROOT::Math::IntegratorMultiDimOptions::SetDefaultNCalls) ), 0);
   G__memfunc_setup("DefaultIntegrator",1764,G__G__MathCore_202_0_15, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (string (*)())(&ROOT::Math::IntegratorMultiDimOptions::DefaultIntegrator) ), 0);
   G__memfunc_setup("DefaultIntegratorType",2182,G__G__MathCore_202_0_16, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (ROOT::Math::IntegrationMultiDim::Type (*)())(&ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType) ), 0);
   G__memfunc_setup("DefaultAbsTolerance",1912,G__G__MathCore_202_0_17, 100, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (double (*)())(&ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerance) ), 0);
   G__memfunc_setup("DefaultRelTolerance",1925,G__G__MathCore_202_0_18, 100, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (double (*)())(&ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance) ), 0);
   G__memfunc_setup("DefaultWKSize",1282,G__G__MathCore_202_0_19, 104, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (unsigned int (*)())(&ROOT::Math::IntegratorMultiDimOptions::DefaultWKSize) ), 0);
   G__memfunc_setup("DefaultNCalls",1282,G__G__MathCore_202_0_20, 104, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (unsigned int (*)())(&ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls) ), 0);
   G__memfunc_setup("Default",709,G__G__MathCore_202_0_21, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions), -1, 1, 1, 3, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (ROOT::Math::IOptions& (*)(const char*))(&ROOT::Math::IntegratorMultiDimOptions::Default) ), 0);
   G__memfunc_setup("FindDefault",1094,G__G__MathCore_202_0_22, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions), -1, 0, 1, 3, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (ROOT::Math::IOptions* (*)(const char*))(&ROOT::Math::IntegratorMultiDimOptions::FindDefault) ), 0);
   G__memfunc_setup("PrintDefault",1234,G__G__MathCore_202_0_23, 121, -1, -1, 0, 2, 3, 1, 0, 
"C - - 10 '0' name u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) G__func2void( (void (*)(const char*, ostream&))(&ROOT::Math::IntegratorMultiDimOptions::PrintDefault) ), 0);
   // automatic destructor
   G__memfunc_setup("~IntegratorMultiDimOptions", 2734, G__G__MathCore_202_0_24, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLVirtualIntegrator(void) {
   /* ROOT::Math::VirtualIntegrator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator));
   G__memfunc_setup("SetRelTolerance",1516,G__G__MathCore_203_0_1, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetAbsTolerance",1503,G__G__MathCore_203_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Result",639,G__G__MathCore_203_0_3, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Error",522,G__G__MathCore_203_0_4, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Status",644,G__G__MathCore_203_0_5, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NEval",470,G__G__MathCore_203_0_6, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~VirtualIntegrator", 1924, G__G__MathCore_203_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_203_0_8, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::VirtualIntegrator' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLVirtualIntegratorOneDim(void) {
   /* ROOT::Math::VirtualIntegratorOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim));
   G__memfunc_setup("Integral",822,G__G__MathCore_204_0_1, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_204_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Integral",822,G__G__MathCore_204_0_3, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("IntegralUp",1019,G__G__MathCore_204_0_4, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - a", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("IntegralLow",1128,G__G__MathCore_204_0_5, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - b", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Integral",822,G__G__MathCore_204_0_6, 100, -1, -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >' 'vector<double>' 11 - pts", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("IntegralCauchy",1427,G__G__MathCore_204_0_7, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - a d - - 0 - b "
"d - - 0 - c", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Options",748,G__G__MathCore_204_0_8, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Type",418,G__G__MathCore_204_0_9, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetOptions",1048,G__G__MathCore_204_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IntegratorOneDimOptions' - 11 - opt", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~VirtualIntegratorOneDim", 2496, G__G__MathCore_204_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_204_0_12, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::VirtualIntegratorOneDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLVirtualIntegratorMultiDim(void) {
   /* ROOT::Math::VirtualIntegratorMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim));
   G__memfunc_setup("Integral",822,G__G__MathCore_205_0_1, 100, -1, -1, 0, 2, 1, 1, 0, 
"D - - 10 - - D - - 10 - -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_205_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Options",748,G__G__MathCore_205_0_3, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Type",418,G__G__MathCore_205_0_4, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetOptions",1048,G__G__MathCore_205_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IntegratorMultiDimOptions' - 11 - opt", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~VirtualIntegratorMultiDim", 2729, G__G__MathCore_205_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_205_0_7, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::VirtualIntegratorMultiDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIntegratorOneDim(void) {
   /* ROOT::Math::IntegratorOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim));
   G__memfunc_setup("IntegratorOneDim",1627,G__G__MathCore_206_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim), -1, 0, 5, 5, 1, 0, 
"i 'ROOT::Math::IntegrationOneDim::Type' - 0 'IntegrationOneDim::kDEFAULT' type d - - 0 '0' absTol "
"d - - 0 '0' relTol h - - 0 '0' size "
"h - - 0 '0' rule", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegratorOneDim",1627,G__G__MathCore_206_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim), -1, 0, 6, 5, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f i 'ROOT::Math::IntegrationOneDim::Type' - 0 'IntegrationOneDim::kDEFAULT' type "
"d - - 0 '0' absTol d - - 0 '0' relTol "
"h - - 0 '0' size i - - 0 '0' rule", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegratorOneDim",1627,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::IntegratorOneDim' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::IntegratorOneDim' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_206_0_5, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f g - - 0 'false' copy", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_206_0_6, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f h - - 0 - icoord "
"D - - 10 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_206_0_7, 100, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_206_0_8, 100, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralUp",1019,G__G__MathCore_206_0_9, 100, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralLow",1128,G__G__MathCore_206_0_10, 100, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_206_0_11, 100, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f u 'vector<double,allocator<double> >' 'vector<double>' 11 - pts", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralCauchy",1427,G__G__MathCore_206_0_12, 100, -1, -1, 0, 4, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - a "
"d - - 0 - b d - - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_206_0_13, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_206_0_14, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralUp",1019,G__G__MathCore_206_0_15, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralLow",1128,G__G__MathCore_206_0_16, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathCore_206_0_17, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_206_0_18, 100, -1, -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >' 'vector<double>' 11 - pts", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralCauchy",1427,G__G__MathCore_206_0_19, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - a d - - 0 - b "
"d - - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Result",639,G__G__MathCore_206_0_20, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Error",522,G__G__MathCore_206_0_21, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Status",644,G__G__MathCore_206_0_22, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NEval",470,G__G__MathCore_206_0_23, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRelTolerance",1516,G__G__MathCore_206_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - relTolerance", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetAbsTolerance",1503,G__G__MathCore_206_0_25, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - absTolerance", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetIntegrator",1343,G__G__MathCore_206_0_26, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetOptions",1048,G__G__MathCore_206_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IntegratorOneDimOptions' - 11 - opt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Options",748,G__G__MathCore_206_0_28, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Name",385,G__G__MathCore_206_0_29, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetType",706,G__G__MathCore_206_0_30, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType), -1, 0, 1, 3, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (ROOT::Math::IntegrationOneDim::Type (*)(const char*))(&ROOT::Math::IntegratorOneDim::GetType) ), 0);
   G__memfunc_setup("GetName",673,G__G__MathCore_206_0_31, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 0, 1, 3, 1, 0, "i 'ROOT::Math::IntegrationOneDim::Type' - 0 - -", (char*)NULL, (void*) G__func2void( (string (*)(ROOT::Math::IntegrationOneDim::Type))(&ROOT::Math::IntegratorOneDim::GetName) ), 0);
   G__memfunc_setup("CreateIntegrator",1651,(G__InterfaceMethod) NULL, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim), -1, 0, 5, 1, 2, 0, 
"i 'ROOT::Math::IntegrationOneDim::Type' - 0 - type d - - 0 - absTol "
"d - - 0 - relTol h - - 0 - size "
"i - - 0 - rule", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~IntegratorOneDim", 1753, G__G__MathCore_206_0_33, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void) {
   /* ROOT::Math::AdaptiveIntegratorMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim));
   G__memfunc_setup("AdaptiveIntegratorMultiDim",2674,G__G__MathCore_207_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim), -1, 0, 4, 5, 1, 0, 
"d - - 0 '1.E-6' absTol d - - 0 '1E-6' relTol "
"h - - 0 '100000' maxpts h - - 0 '0' size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AdaptiveIntegratorMultiDim",2674,G__G__MathCore_207_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim), -1, 0, 5, 5, 1, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f d - - 0 '1.E-9' absTol "
"d - - 0 '1E-6' relTol h - - 0 '100000' maxcall "
"h - - 0 '0' size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 0, 
"D - - 10 - xmin D - - 10 - xmax", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integral",822,G__G__MathCore_207_0_4, 100, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f D - - 10 - xmin "
"D - - 10 - xmax", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Result",639,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Error",522,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RelError",813,G__G__MathCore_207_0_8, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Status",644,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NEval",470,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetRelTolerance",1516,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - relTol", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetAbsTolerance",1503,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - absTol", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSize",711,G__G__MathCore_207_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMinPts",903,G__G__MathCore_207_0_14, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMaxPts",905,G__G__MathCore_207_0_15, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetOptions",1048,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IntegratorMultiDimOptions' - 11 - opt", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Options",748,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoIntegral",1001,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 3, 1, 2, 0, 
"D - - 10 - xmin D - - 10 - xmax "
"g - - 0 'false' absVal", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("AdaptiveIntegratorMultiDim", 2674, G__G__MathCore_207_0_19, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::AdaptiveIntegratorMultiDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AdaptiveIntegratorMultiDim", 2800, G__G__MathCore_207_0_20, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIntegratorMultiDim(void) {
   /* ROOT::Math::IntegratorMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim));
   G__memfunc_setup("IntegratorMultiDim",1860,G__G__MathCore_208_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim), -1, 0, 4, 5, 1, 0, 
"i 'ROOT::Math::IntegrationMultiDim::Type' - 0 'IntegrationMultiDim::kDEFAULT' type d - - 0 '0' absTol "
"d - - 0 '0' relTol h - - 0 '0' ncall", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegratorMultiDim",1860,G__G__MathCore_208_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim), -1, 0, 5, 5, 1, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f i 'ROOT::Math::IntegrationMultiDim::Type' - 0 'IntegrationMultiDim::kDEFAULT' type "
"d - - 0 '0' absTol d - - 0 '0' relTol "
"h - - 0 '0' ncall", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegratorMultiDim",1860,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::IntegratorMultiDim' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::IntegratorMultiDim' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_208_0_5, 100, -1, -1, 0, 2, 1, 1, 0, 
"D - - 10 - xmin D - - 10 - xmax", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_208_0_6, 100, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f D - - 10 - xmin "
"D - - 10 - xmax", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_208_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Result",639,G__G__MathCore_208_0_8, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Error",522,G__G__MathCore_208_0_9, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Status",644,G__G__MathCore_208_0_10, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRelTolerance",1516,G__G__MathCore_208_0_11, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - relTol", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetAbsTolerance",1503,G__G__MathCore_208_0_12, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - absTol", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetOptions",1048,G__G__MathCore_208_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IntegratorMultiDimOptions' - 11 - opt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Options",748,G__G__MathCore_208_0_14, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetIntegrator",1343,G__G__MathCore_208_0_15, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Name",385,G__G__MathCore_208_0_16, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetType",706,G__G__MathCore_208_0_17, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType), -1, 0, 1, 3, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (ROOT::Math::IntegrationMultiDim::Type (*)(const char*))(&ROOT::Math::IntegratorMultiDim::GetType) ), 0);
   G__memfunc_setup("GetName",673,G__G__MathCore_208_0_18, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 0, 1, 3, 1, 0, "i 'ROOT::Math::IntegrationMultiDim::Type' - 0 - -", (char*)NULL, (void*) G__func2void( (string (*)(ROOT::Math::IntegrationMultiDim::Type))(&ROOT::Math::IntegratorMultiDim::GetName) ), 0);
   G__memfunc_setup("CreateIntegrator",1651,(G__InterfaceMethod) NULL, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim), -1, 0, 4, 1, 2, 0, 
"i 'ROOT::Math::IntegrationMultiDim::Type' - 0 - type d - - 0 - absTol "
"d - - 0 - relTol h - - 0 - ncall", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~IntegratorMultiDim", 1986, G__G__MathCore_208_0_20, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLDistSampler(void) {
   /* ROOT::Math::DistSampler */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLDistSampler));
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_209_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - func", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_209_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - func", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NDim",360,G__G__MathCore_209_0_4, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Init",404,G__G__MathCore_209_0_5, 103, -1, -1, 0, 1, 1, 1, 0, "C - - 10 '\"\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Init",404,G__G__MathCore_209_0_6, 103, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::DistSamplerOptions' - 11 - opt", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetRandom",909,G__G__MathCore_209_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "U 'TRandom' - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSeed",685,G__G__MathCore_209_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetRandom",897,G__G__MathCore_209_0_9, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TRandom), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetRange",793,G__G__MathCore_209_0_10, 121, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - xmin d - - 0 - xmax "
"i - - 0 '0' icoord", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRange",793,G__G__MathCore_209_0_11, 121, -1, -1, 0, 2, 1, 1, 0, 
"D - - 10 - xmin D - - 10 - xmax", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRange",793,G__G__MathCore_209_0_12, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Fit::DataRange' - 11 - range", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMode",689,G__G__MathCore_209_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetArea",677,G__G__MathCore_209_0_14, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ParentPdf",900,G__G__MathCore_209_0_15, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim), G__defined_typename("ROOT::Math::IMultiGenFunction"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sample1D",727,G__G__MathCore_209_0_16, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Sample",610,G__G__MathCore_209_0_17, 68, -1, -1, 0, 0, 1, 1, 1, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sample",610,G__G__MathCore_209_0_18, 103, -1, -1, 0, 1, 1, 1, 0, "D - - 0 - x", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SampleBin",891,G__G__MathCore_209_0_19, 103, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - prob d - - 1 - value "
"D - - 0 '0' error", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SampleBins",1006,G__G__MathCore_209_0_20, 103, -1, -1, 0, 4, 1, 1, 0, 
"h - - 0 - n D - - 10 - prob "
"D - - 0 - values D - - 0 '0' errors", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Generate",811,G__G__MathCore_209_0_21, 103, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - nevt u 'ROOT::Fit::UnBinData' - 1 - data", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Generate",811,G__G__MathCore_209_0_22, 103, -1, -1, 0, 4, 1, 1, 0, 
"h - - 0 - nevt I - - 10 - nbins "
"u 'ROOT::Fit::BinData' - 1 - data g - - 0 'true' extend", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Generate",811,G__G__MathCore_209_0_23, 103, -1, -1, 0, 6, 1, 1, 0, 
"h - - 0 - nevt i - - 0 - nbins "
"d - - 0 - xmin d - - 0 - xmax "
"u 'ROOT::Fit::BinData' - 1 - data g - - 0 'true' extend", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoSetFunction",1317,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 2, 1, 2, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - func g - - 0 - copy", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IsInitialized",1330,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 0, 1, 2, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PdfRange",775,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLFitcLcLDataRange), -1, 1, 0, 1, 2, 9, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DistSampler", 1254, G__G__MathCore_209_0_27, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLFactory(void) {
   /* ROOT::Math::Factory */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory));
   G__memfunc_setup("CreateMinimizer",1544,G__G__MathCore_210_0_1, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizer), -1, 0, 2, 3, 1, 0, 
"u 'string' - 11 '\"\"' minimizerType u 'string' - 11 '\"\"' algoType", (char*)NULL, (void*) G__func2void( (ROOT::Math::Minimizer* (*)(const string&, const string&))(&ROOT::Math::Factory::CreateMinimizer) ), 0);
   G__memfunc_setup("CreateDistSampler",1724,G__G__MathCore_210_0_2, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLDistSampler), -1, 0, 1, 3, 1, 0, "u 'string' - 11 '\"\"' samplerType", (char*)NULL, (void*) G__func2void( (ROOT::Math::DistSampler* (*)(const string&))(&ROOT::Math::Factory::CreateDistSampler) ), 0);
   // automatic default constructor
   G__memfunc_setup("Factory", 728, G__G__MathCore_210_0_3, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Factory", 728, G__G__MathCore_210_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Factory' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Factory", 854, G__G__MathCore_210_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_210_0_6, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Factory' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void) {
   /* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR));
   G__memfunc_setup("NDim",360,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DataElement",1092,G__G__MathCore_211_0_3, 100, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x h - - 0 - i "
"D - - 0 '0' g", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NPoints",715,G__G__MathCore_211_0_4, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Type",418,G__G__MathCore_211_0_5, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgRcLcLType_t), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NCalls",573,G__G__MathCore_211_0_6, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("UpdateNCalls",1184,G__G__MathCore_211_0_7, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ResetNCalls",1088,G__G__MathCore_211_0_8, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>", 5513, G__G__MathCore_211_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_211_0_10, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void) {
   /* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR));
   G__memfunc_setup("NDim",360,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DataElement",1092,G__G__MathCore_213_0_3, 100, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x h - - 0 - i "
"D - - 0 '0' g", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NPoints",715,G__G__MathCore_213_0_4, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Type",418,G__G__MathCore_213_0_5, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgRcLcLType_t), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NCalls",573,G__G__MathCore_213_0_6, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("UpdateNCalls",1184,G__G__MathCore_213_0_7, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ResetNCalls",1088,G__G__MathCore_213_0_8, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>", 5948, G__G__MathCore_213_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_213_0_10, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGaussIntegrator(void) {
   /* ROOT::Math::GaussIntegrator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator));
   G__memfunc_setup("GaussIntegrator",1570,G__G__MathCore_215_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator), -1, 0, 1, 1, 1, 0, "d - - 0 '1.E-12' relTol", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AbsValue",787,G__G__MathCore_215_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "g - - 0 - flag", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRelTolerance",1516,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetAbsTolerance",1503,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Result",639,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Error",522,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Status",644,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntegralUp",1019,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - a", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntegralLow",1128,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >' 'vector<double>' 11 - pts", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntegralCauchy",1427,(G__InterfaceMethod) NULL,100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - a d - - 0 - b "
"d - - 0 - c", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Options",748,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetOptions",1048,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IntegratorOneDimOptions' - 11 - opt", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoIntegral",1001,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 3, 1, 4, 0, 
"d - - 0 - a d - - 0 - b "
"U 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 10 - func", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("GaussIntegrator", 1570, G__G__MathCore_215_0_18, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GaussIntegrator' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GaussIntegrator", 1696, G__G__MathCore_215_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGaussLegendreIntegrator(void) {
   /* ROOT::Math::GaussLegendreIntegrator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator));
   G__memfunc_setup("GaussLegendreIntegrator",2376,G__G__MathCore_218_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator), -1, 0, 2, 1, 1, 0, 
"i - - 0 '10' num d - - 0 '1e-12' eps", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetNumberPoints",1554,G__G__MathCore_218_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - num", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRelTolerance",1516,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetAbsTolerance",1503,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetWeightVectors",1646,G__G__MathCore_218_0_5, 121, -1, -1, 0, 2, 1, 1, 8, 
"D - - 0 - x D - - 0 - w", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNumberPoints",1542,G__G__MathCore_218_0_6, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NEval",470,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Options",748,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetOptions",1048,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IntegratorOneDimOptions' - 11 - opt", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoIntegral",1001,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 3, 1, 4, 0, 
"d - - 0 - a d - - 0 - b "
"U 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 10 - func", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("CalcGaussLegendreSamplingPoints",3156,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GaussLegendreIntegrator", 2376, G__G__MathCore_218_0_12, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GaussLegendreIntegrator' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GaussLegendreIntegrator", 2502, G__G__MathCore_218_0_13, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIRootFinderMethod(void) {
   /* ROOT::Math::IRootFinderMethod */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod));
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_219_0_2, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IGradientFunctionOneDim' 'ROOT::Math::IGradFunction' 11 - - d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_219_0_3, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - - d - - 0 - - "
"d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Root",420,G__G__MathCore_219_0_4, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Status",644,G__G__MathCore_219_0_5, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Solve",521,G__G__MathCore_219_0_6, 103, -1, -1, 0, 3, 1, 1, 0, 
"i - - 0 '100' maxIter d - - 0 '1E-8' absTol "
"d - - 0 '1E-10' relTol", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Name",385,G__G__MathCore_219_0_7, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Iterate",718,G__G__MathCore_219_0_8, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Iterations",1058,G__G__MathCore_219_0_9, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~IRootFinderMethod", 1828, G__G__MathCore_219_0_10, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_219_0_11, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IRootFinderMethod' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRootFinder(void) {
   /* ROOT::Math::RootFinder */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder));
   G__memfunc_setup("RootFinder",1020,G__G__MathCore_220_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder), -1, 0, 1, 1, 1, 0, "i 'ROOT::Math::RootFinder::EType' - 0 'RootFinder::kBRENT' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RootFinder",1020,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::RootFinder' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::RootFinder' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMethod",909,G__G__MathCore_220_0_4, 103, -1, -1, 0, 1, 1, 1, 0, "i 'ROOT::Math::RootFinder::EType' - 0 'RootFinder::kBRENT' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_220_0_5, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - xlow "
"d - - 0 - xup", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_220_0_6, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IGradientFunctionOneDim' 'ROOT::Math::IGradFunction' 11 - f d - - 0 - xstart", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Solve",521,G__G__MathCore_220_0_7, 103, -1, -1, 0, 3, 1, 1, 0, 
"i - - 0 '100' maxIter d - - 0 '1E-8' absTol "
"d - - 0 '1E-10' relTol", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Iterations",1058,G__G__MathCore_220_0_8, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Iterate",718,G__G__MathCore_220_0_9, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Root",420,G__G__MathCore_220_0_10, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Status",644,G__G__MathCore_220_0_11, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Name",385,G__G__MathCore_220_0_12, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RootFinder", 1146, G__G__MathCore_220_0_13, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRichardsonDerivator(void) {
   /* ROOT::Math::RichardsonDerivator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator));
   G__memfunc_setup("RichardsonDerivator",1981,G__G__MathCore_224_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator), -1, 0, 1, 1, 1, 0, "d - - 0 '0.001' h", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RichardsonDerivator",1981,G__G__MathCore_224_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator), -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 '0.001' h "
"g - - 0 'false' copyFunc", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RichardsonDerivator",1981,G__G__MathCore_224_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::RichardsonDerivator' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_224_0_4, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::RichardsonDerivator' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Error",522,G__G__MathCore_224_0_5, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivative1",1092,G__G__MathCore_224_0_6, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathCore_224_0_7, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivative1",1092,G__G__MathCore_224_0_8, 100, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - x "
"d - - 0 - h", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivative2",1093,G__G__MathCore_224_0_9, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivative2",1093,G__G__MathCore_224_0_10, 100, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - x "
"d - - 0 - h", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivative3",1094,G__G__MathCore_224_0_11, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivative3",1094,G__G__MathCore_224_0_12, 100, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - x "
"d - - 0 - h", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_224_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetStepSize",1123,G__G__MathCore_224_0_14, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - h", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RichardsonDerivator", 2107, G__G__MathCore_224_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIMinimizer1D(void) {
   /* ROOT::Math::IMinimizer1D */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIMinimizer1D));
   G__memfunc_setup("XMinimum",820,G__G__MathCore_226_0_2, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("XLower",609,G__G__MathCore_226_0_3, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("XUpper",612,G__G__MathCore_226_0_4, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("FValMinimum",1093,G__G__MathCore_226_0_5, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("FValLower",882,G__G__MathCore_226_0_6, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("FValUpper",885,G__G__MathCore_226_0_7, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Minimize",834,G__G__MathCore_226_0_8, 103, -1, -1, 0, 3, 1, 1, 0, 
"i - - 0 - maxIter d - - 0 - absTol "
"d - - 0 - relTol", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Iterations",1058,G__G__MathCore_226_0_9, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Name",385,G__G__MathCore_226_0_10, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Status",644,G__G__MathCore_226_0_11, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~IMinimizer1D", 1264, G__G__MathCore_226_0_12, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_226_0_13, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIMinimizer1D), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IMinimizer1D' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLBrentMinimizer1D(void) {
   /* ROOT::Math::BrentMinimizer1D */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D));
   G__memfunc_setup("BrentMinimizer1D",1572,G__G__MathCore_227_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("XMinimum",820,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("XLower",609,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("XUpper",612,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FValMinimum",1093,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FValLower",882,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FValUpper",885,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Minimize",834,G__G__MathCore_227_0_8, 103, -1, -1, 0, 3, 1, 1, 0, 
"i - - 0 - maxIter d - - 0 '1.E-8' absTol "
"d - - 0 '1.E-10' relTol", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Iterations",1058,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Name",385,(G__InterfaceMethod) NULL,67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_227_0_11, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - xlow "
"d - - 0 - xup", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetNpx",610,G__G__MathCore_227_0_12, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - npx", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetLogScan",979,G__G__MathCore_227_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "g - - 0 - on", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Status",644,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetDefaultNpx",1319,G__G__MathCore_227_0_15, 121, -1, -1, 0, 1, 3, 1, 0, "i - - 0 - npx", (char*)NULL, (void*) G__func2void( (void (*)(int))(&ROOT::Math::BrentMinimizer1D::SetDefaultNpx) ), 0);
   G__memfunc_setup("SetDefaultNSearch",1685,G__G__MathCore_227_0_16, 121, -1, -1, 0, 1, 3, 1, 0, "i - - 0 - n", (char*)NULL, (void*) G__func2void( (void (*)(int))(&ROOT::Math::BrentMinimizer1D::SetDefaultNSearch) ), 0);
   // automatic copy constructor
   G__memfunc_setup("BrentMinimizer1D", 1572, G__G__MathCore_227_0_17, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::BrentMinimizer1D' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BrentMinimizer1D", 1698, G__G__MathCore_227_0_18, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLBrentRootFinder(void) {
   /* ROOT::Math::BrentRootFinder */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder));
   G__memfunc_setup("BrentRootFinder",1527,G__G__MathCore_228_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - xlow "
"d - - 0 - xup", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Solve",521,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 0, 
"i - - 0 '100' maxIter d - - 0 '1E-8' absTol "
"d - - 0 '1E-10' relTol", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetNpx",610,G__G__MathCore_228_0_4, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - npx", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetLogScan",979,G__G__MathCore_228_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "g - - 0 - on", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Root",420,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Status",644,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Iterations",1058,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Name",385,(G__InterfaceMethod) NULL,67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetDefaultNpx",1319,G__G__MathCore_228_0_10, 121, -1, -1, 0, 1, 3, 1, 0, "i - - 0 - npx", (char*)NULL, (void*) G__func2void( (void (*)(int))(&ROOT::Math::BrentRootFinder::SetDefaultNpx) ), 0);
   G__memfunc_setup("SetDefaultNSearch",1685,G__G__MathCore_228_0_11, 121, -1, -1, 0, 1, 3, 1, 0, "i - - 0 - n", (char*)NULL, (void*) G__func2void( (void (*)(int))(&ROOT::Math::BrentRootFinder::SetDefaultNSearch) ), 0);
   // automatic copy constructor
   G__memfunc_setup("BrentRootFinder", 1527, G__G__MathCore_228_0_12, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::BrentRootFinder' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BrentRootFinder", 1653, G__G__MathCore_228_0_13, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLDistSamplerOptions(void) {
   /* ROOT::Math::DistSamplerOptions */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLDistSamplerOptions));
   G__memfunc_setup("SetDefaultSampler",1733,G__G__MathCore_231_0_1, 121, -1, -1, 0, 1, 3, 1, 0, "C - - 10 - type", (char*)NULL, (void*) G__func2void( (void (*)(const char*))(&ROOT::Math::DistSamplerOptions::SetDefaultSampler) ), 0);
   G__memfunc_setup("SetDefaultAlgorithm1D",2061,G__G__MathCore_231_0_2, 121, -1, -1, 0, 1, 3, 1, 0, "C - - 10 - algo", (char*)NULL, (void*) G__func2void( (void (*)(const char*))(&ROOT::Math::DistSamplerOptions::SetDefaultAlgorithm1D) ), 0);
   G__memfunc_setup("SetDefaultAlgorithmND",2090,G__G__MathCore_231_0_3, 121, -1, -1, 0, 1, 3, 1, 0, "C - - 10 - algo", (char*)NULL, (void*) G__func2void( (void (*)(const char*))(&ROOT::Math::DistSamplerOptions::SetDefaultAlgorithmND) ), 0);
   G__memfunc_setup("SetDefaultPrintLevel",2038,G__G__MathCore_231_0_4, 121, -1, -1, 0, 1, 3, 1, 0, "i - - 0 - level", (char*)NULL, (void*) G__func2void( (void (*)(int))(&ROOT::Math::DistSamplerOptions::SetDefaultPrintLevel) ), 0);
   G__memfunc_setup("DefaultSampler",1433,G__G__MathCore_231_0_5, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const string& (*)())(&ROOT::Math::DistSamplerOptions::DefaultSampler) ), 0);
   G__memfunc_setup("DefaultAlgorithm1D",1761,G__G__MathCore_231_0_6, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const string& (*)())(&ROOT::Math::DistSamplerOptions::DefaultAlgorithm1D) ), 0);
   G__memfunc_setup("DefaultAlgorithmND",1790,G__G__MathCore_231_0_7, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const string& (*)())(&ROOT::Math::DistSamplerOptions::DefaultAlgorithmND) ), 0);
   G__memfunc_setup("DefaultPrintLevel",1738,G__G__MathCore_231_0_8, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ROOT::Math::DistSamplerOptions::DefaultPrintLevel) ), 0);
   G__memfunc_setup("Default",709,G__G__MathCore_231_0_9, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions), -1, 1, 1, 3, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (ROOT::Math::IOptions& (*)(const char*))(&ROOT::Math::DistSamplerOptions::Default) ), 0);
   G__memfunc_setup("FindDefault",1094,G__G__MathCore_231_0_10, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions), -1, 0, 1, 3, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (ROOT::Math::IOptions* (*)(const char*))(&ROOT::Math::DistSamplerOptions::FindDefault) ), 0);
   G__memfunc_setup("PrintDefault",1234,G__G__MathCore_231_0_11, 121, -1, -1, 0, 2, 3, 1, 0, 
"C - - 10 '0' name u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) G__func2void( (void (*)(const char*, ostream&))(&ROOT::Math::DistSamplerOptions::PrintDefault) ), 0);
   G__memfunc_setup("DistSamplerOptions",1876,G__G__MathCore_231_0_12, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLDistSamplerOptions), -1, 0, 1, 1, 1, 0, "i - - 0 '0' dim", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DistSamplerOptions",1876,G__G__MathCore_231_0_13, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLDistSamplerOptions), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::DistSamplerOptions' - 11 - opt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_231_0_14, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLDistSamplerOptions), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::DistSamplerOptions' - 11 - opt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintLevel",1029,G__G__MathCore_231_0_15, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ExtraOptions",1264,G__G__MathCore_231_0_16, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sampler",724,G__G__MathCore_231_0_17, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Algorithm",935,G__G__MathCore_231_0_18, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,G__G__MathCore_231_0_19, 121, -1, -1, 0, 1, 1, 1, 8, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPrintLevel",1329,G__G__MathCore_231_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - level", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSampler",1024,G__G__MathCore_231_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetAlgorithm",1235,G__G__MathCore_231_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetExtraOptions",1564,G__G__MathCore_231_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IOptions' - 11 - opt", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DistSamplerOptions", 2002, G__G__MathCore_231_0_24, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGoFTest(void) {
   /* ROOT::Math::GoFTest */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest));
   G__memfunc_setup("GoFTest",668,G__G__MathCore_232_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest), -1, 0, 4, 1, 1, 0, 
"h - 'UInt_t' 0 - sample1Size D - 'Double_t' 10 - sample1 "
"h - 'UInt_t' 0 - sample2Size D - 'Double_t' 10 - sample2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GoFTest",668,G__G__MathCore_232_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest), -1, 0, 3, 1, 1, 0, 
"h - 'UInt_t' 0 - sampleSize D - 'Double_t' 10 - sample "
"i 'ROOT::Math::GoFTest::EDistribution' - 0 'kUndefined' dist", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GoFTest",668,G__G__MathCore_232_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest), -1, 0, 6, 1, 1, 0, 
"h - 'UInt_t' 0 - sampleSize D - 'Double_t' 10 - sample "
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - dist i 'ROOT::Math::GoFTest::EUserDistribution' - 0 'kPDF' userDist "
"d - 'Double_t' 0 '1' xmin d - 'Double_t' 0 '0' xmax", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetUserDistribution",1995,G__G__MathCore_232_0_4, 121, -1, -1, 0, 4, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - dist i 'ROOT::Math::GoFTest::EUserDistribution' - 0 'kPDF' userDist "
"d - 'Double_t' 0 '1' xmin d - 'Double_t' 0 '0' xmax", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetUserPDF",933,G__G__MathCore_232_0_5, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - pdf d - 'Double_t' 0 '1' xmin "
"d - 'Double_t' 0 '0' xmax", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetUserCDF",920,G__G__MathCore_232_0_6, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - cdf d - 'Double_t' 0 '1' xmin "
"d - 'Double_t' 0 '0' xmax", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetDistribution",1580,G__G__MathCore_232_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "i 'ROOT::Math::GoFTest::EDistribution' - 0 - dist", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AndersonDarling2SamplesTest",2722,G__G__MathCore_232_0_8, 121, -1, -1, 0, 2, 1, 1, 8, 
"d - 'Double_t' 1 - pvalue d - 'Double_t' 1 - testStat", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AndersonDarling2SamplesTest",2722,G__G__MathCore_232_0_9, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 8, "C - 'Char_t' 10 '\"p\"' option", "Returns default p-value; option \"t\" returns the test statistic value \"A2\"", (void*) NULL, 0);
   G__memfunc_setup("AndersonDarlingTest",1947,G__G__MathCore_232_0_10, 121, -1, -1, 0, 2, 1, 1, 8, 
"d - 'Double_t' 1 - pvalue d - 'Double_t' 1 - testStat", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AndersonDarlingTest",1947,G__G__MathCore_232_0_11, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 8, "C - 'Char_t' 10 '\"p\"' option", "Returns default p-value; option \"t\" returns the test statistic value \"A2\"", (void*) NULL, 0);
   G__memfunc_setup("KolmogorovSmirnov2SamplesTest",3012,G__G__MathCore_232_0_12, 121, -1, -1, 0, 2, 1, 1, 8, 
"d - 'Double_t' 1 - pvalue d - 'Double_t' 1 - testStat", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("KolmogorovSmirnov2SamplesTest",3012,G__G__MathCore_232_0_13, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 8, "C - 'Char_t' 10 '\"p\"' option", "Returns default p-value; option \"t\" returns the test statistic value \"Dn\"", (void*) NULL, 0);
   G__memfunc_setup("KolmogorovSmirnovTest",2237,G__G__MathCore_232_0_14, 121, -1, -1, 0, 2, 1, 1, 8, 
"d - 'Double_t' 1 - pvalue d - 'Double_t' 1 - testStat", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("KolmogorovSmirnovTest",2237,G__G__MathCore_232_0_15, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 8, "C - 'Char_t' 10 '\"p\"' option", "Returns default p-value; option \"t\" returns the test statistic value \"Dn\"", (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathCore_232_0_16, 121, -1, -1, 0, 3, 1, 1, 8, 
"i 'ROOT::Math::GoFTest::ETestType' - 0 - test d - 'Double_t' 1 - pvalue "
"d - 'Double_t' 1 - testStat", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathCore_232_0_17, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 8, 
"i 'ROOT::Math::GoFTest::ETestType' - 0 'kAD' test C - 'Char_t' 10 '\"p\"' option", "Returns default Anderson Darling 1-Sample Test and default p-value; option \"t\" returns the test statistic value specific to the test type", (void*) NULL, 0);
   G__memfunc_setup("GoFTest",668,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest), -1, 0, 0, 1, 4, 0, "", "Disallowed default constructor", (void*) NULL, 0);
   G__memfunc_setup("GoFTest",668,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::GoFTest' - 1 - gof", "Disallowed copy constructor", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::GoFTest' - 1 - gof", "Disallowed assign operator", (void*) NULL, 0);
   G__memfunc_setup("SetCDF",505,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetDistributionFunction",2418,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 4, 1, 4, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - cdf g - 'Bool_t' 0 - isPDF "
"d - 'Double_t' 0 - xmin d - 'Double_t' 0 - xmax", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Instantiate",1156,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 2, 1, 4, 0, 
"D - 'Double_t' 10 - sample h - 'UInt_t' 0 - sampleSize", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LogNormalCDF",1112,(G__InterfaceMethod) NULL, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 4, 8, "d - 'Double_t' 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GaussianCDF",1032,(G__InterfaceMethod) NULL, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 4, 8, "d - 'Double_t' 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ExponentialCDF",1364,(G__InterfaceMethod) NULL, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 4, 8, "d - 'Double_t' 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetSigmaN",863,(G__InterfaceMethod) NULL, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 4, 8, "h - 'UInt_t' 0 - N", "Computation of sigma_N as described in (1) ", (void*) NULL, 0);
   G__memfunc_setup("InterpolatePValues",1863,(G__InterfaceMethod) NULL, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 4, 8, 
"d - 'Double_t' 0 - dA2 i - 'Int_t' 0 - bin", "Linear interpolation used in GoFTest::PValueAD2Samples", (void*) NULL, 0);
   G__memfunc_setup("PValueAD2Samples",1497,(G__InterfaceMethod) NULL, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 4, 8, 
"d - 'Double_t' 1 - A2 h - 'UInt_t' 0 - N", "Computation of the 2-Sample Anderson-Darling Test's p-value as described in (1)", (void*) NULL, 0);
   G__memfunc_setup("PValueAD1Sample",1381,(G__InterfaceMethod) NULL, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 4, 8, "d - 'Double_t' 0 - A2", "Computation of the 1-Sample Anderson-Darling Test's p-value ", (void*) NULL, 0);
   G__memfunc_setup("LogSample",900,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", "Applies the logarithm to the sample when the specified distribution to test is LogNormal", (void*) NULL, 0);
   G__memfunc_setup("SetSamples",1025,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 2, 1, 4, 0, 
"u 'vector<const double*,allocator<const double*> >' 'vector<const Double_t*>' 0 - samples u 'vector<unsigned int,allocator<unsigned int> >' 'vector<UInt_t>' 10 - samplesSizes", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetParameters",1344,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", "Sets the estimated mean and standard-deviation from the samples ", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GoFTest", 794, G__G__MathCore_232_0_34, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncG__MathCore() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {
   G__memvar_setup((void*)(&gRandom),85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom),-1,-1,1,"gRandom=",0,(char*)NULL);
}

static void G__cpp_setup_global2() {
}

static void G__cpp_setup_global3() {
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"ROOT_Math_SpecFuncMathCore=0",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"ROOT_Math_PdfFuncMathCore=0",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"ROOT_Math_ProbFuncMathCore=0",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"ROOT_Math_QuantFuncMathCore=0",1,(char*)NULL);

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalG__MathCore() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
  G__cpp_setup_global2();
  G__cpp_setup_global3();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
   G__memfunc_setup("operator==", 998, G__G__MathCore__0_440, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<double,allocator<double> >::iterator' - 11 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator!=", 970, G__G__MathCore__0_441, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<double,allocator<double> >::iterator' - 11 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<", 936, G__G__MathCore__0_442, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<double,allocator<double> >::iterator' - 11 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>", 938, G__G__MathCore__0_443, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<double,allocator<double> >::iterator' - 11 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<=", 997, G__G__MathCore__0_444, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<double,allocator<double> >::iterator' - 11 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>=", 999, G__G__MathCore__0_445, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<double,allocator<double> >::iterator' - 11 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator-", 921, G__G__MathCore__0_446, 108, -1, G__defined_typename("difference_type"), 0, 2, 1, 1, 8, 
"u 'vector<double,allocator<double> >::iterator' - 11 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator+", 919, G__G__MathCore__0_447, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 2, 1, 1, 8, 
"l - 'difference_type' 10 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator==", 998, G__G__MathCore__0_448, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'reverse_iterator<vector<double,allocator<double> >::iterator>' 'reverse_iterator' 11 - x u 'reverse_iterator<vector<double,allocator<double> >::iterator>' 'reverse_iterator' 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator!=", 970, G__G__MathCore__0_449, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'reverse_iterator<vector<double,allocator<double> >::iterator>' 'reverse_iterator' 11 - x u 'reverse_iterator<vector<double,allocator<double> >::iterator>' 'reverse_iterator' 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator==", 998, G__G__MathCore__0_450, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >' - 11 - x u 'vector<double,allocator<double> >' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<", 936, G__G__MathCore__0_451, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >' - 11 - x u 'vector<double,allocator<double> >' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator!=", 970, G__G__MathCore__0_452, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >' - 11 - x u 'vector<double,allocator<double> >' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>", 938, G__G__MathCore__0_453, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >' - 11 - x u 'vector<double,allocator<double> >' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>=", 999, G__G__MathCore__0_454, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >' - 11 - x u 'vector<double,allocator<double> >' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<=", 997, G__G__MathCore__0_455, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >' - 11 - x u 'vector<double,allocator<double> >' - 11 - y", (char*) NULL
, (void*) NULL, 0);
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcG__MathCore() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__G__MathCoreLN_type_info = { "type_info" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TClass = { "TClass" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TBuffer = { "TBuffer" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TMemberInspector = { "TMemberInspector" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TObject = { "TObject" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TNamed = { "TNamed" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TString = { "TString" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TVirtualIsAProxy = { "TVirtualIsAProxy" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOT = { "ROOT" , 110 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLTInitBehavior = { "ROOT::TInitBehavior" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR = { "basic_ostream<char,char_traits<char> >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TRandom = { "TRandom" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TRandom1 = { "TRandom1" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TRandom2 = { "TRandom2" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TRandom3 = { "TRandom3" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TMethodCall = { "TMethodCall" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_Foption_t = { "Foption_t" , 115 , -1 };
G__linked_taginfo G__G__MathCoreLN_TVirtualFitter = { "TVirtualFitter" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TKDTreelEintcOdoublegR = { "TKDTree<int,double>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEintcOallocatorlEintgRsPgR = { "vector<int,allocator<int> >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<int,allocator<int> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TKDTreelEintcOfloatgR = { "TKDTree<int,float>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLFit = { "ROOT::Fit" , 110 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLFitcLcLBinData = { "ROOT::Fit::BinData" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TKDTreeBinning = { "TKDTreeBinning" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR = { "vector<double,allocator<double> >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator = { "vector<double,allocator<double> >::iterator" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<double,allocator<double> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_pairlEdoublecOdoublegR = { "pair<double,double>" , 115 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR = { "vector<pair<double,double>,allocator<pair<double,double> > >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_reverse_iteratorlEvectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<pair<double,double>,allocator<pair<double,double> > >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_pairlEboolcOboolgR = { "pair<bool,bool>" , 115 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgR = { "vector<pair<bool,bool>,allocator<pair<bool,bool> > >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_reverse_iteratorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<pair<bool,bool>,allocator<pair<bool,bool> > >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcOallocatorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRsPgRsPgR = { "vector<vector<pair<bool,bool>,allocator<pair<bool,bool> > >,allocator<vector<pair<bool,bool>,allocator<pair<bool,bool> > > > >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_reverse_iteratorlEvectorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcOallocatorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<vector<pair<bool,bool>,allocator<pair<bool,bool> > >,allocator<vector<pair<bool,bool>,allocator<pair<bool,bool> > > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR = { "vector<unsigned int,allocator<unsigned int> >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<unsigned int,allocator<unsigned int> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_maplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR = { "map<double,vector<unsigned int,allocator<unsigned int> >,less<double>,allocator<pair<const double,vector<unsigned int,allocator<unsigned int> > > > >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRcOallocatorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRsPgRsPgR = { "vector<map<double,vector<unsigned int,allocator<unsigned int> >,less<double>,allocator<pair<const double,vector<unsigned int,allocator<unsigned int> > > > >,allocator<map<double,vector<unsigned int,allocator<unsigned int> >,less<double>,allocator<pair<const double,vector<unsigned int,allocator<unsigned int> > > > > > >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_reverse_iteratorlEvectorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRcOallocatorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<map<double,vector<unsigned int,allocator<unsigned int> >,less<double>,allocator<pair<const double,vector<unsigned int,allocator<unsigned int> > > > >,allocator<map<double,vector<unsigned int,allocator<unsigned int> >,less<double>,allocator<pair<const double,vector<unsigned int,allocator<unsigned int> > > > > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TKDTreeBinningcLcLdA = { "TKDTreeBinning::$" , 101 , -1 };
G__linked_taginfo G__G__MathCoreLN_pairlEconstsPdoublemUcOconstsPdoublemUgR = { "pair<const double*,const double*>" , 115 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMath = { "ROOT::Math" , 110 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim = { "ROOT::Math::IBaseFunctionOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim = { "ROOT::Math::IGradientFunctionOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim = { "ROOT::Math::IBaseFunctionMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim = { "ROOT::Math::IGradientFunctionMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim = { "ROOT::Math::IGradientMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim = { "ROOT::Math::IGradientOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim = { "ROOT::Math::IParametricFunctionOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim = { "ROOT::Math::IParametricGradFunctionOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim = { "ROOT::Math::IParametricFunctionMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim = { "ROOT::Math::IParametricGradFunctionMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam = { "ROOT::Math::IBaseParam" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctionBase = { "ROOT::Math::ParamFunctionBase" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor = { "ROOT::Math::ParamFunctor" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor = { "ROOT::Math::Functor" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR = { "auto_ptr<ROOT::Math::IBaseFunctionMultiDim>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D = { "ROOT::Math::Functor1D" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionOneDimgR = { "auto_ptr<ROOT::Math::IBaseFunctionOneDim>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor = { "ROOT::Math::GradFunctor" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR = { "auto_ptr<ROOT::Math::IGradientFunctionMultiDim>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D = { "ROOT::Math::GradFunctor1D" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionOneDimgR = { "auto_ptr<ROOT::Math::IGradientFunctionOneDim>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions = { "ROOT::Math::IOptions" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions = { "ROOT::Math::MinimizerOptions" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizer = { "ROOT::Math::Minimizer" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDim = { "ROOT::Math::IntegrationOneDim" , 110 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType = { "ROOT::Math::IntegrationOneDim::Type" , 101 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDim = { "ROOT::Math::IntegrationMultiDim" , 110 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType = { "ROOT::Math::IntegrationMultiDim::Type" , 101 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLBaseIntegratorOptions = { "ROOT::Math::BaseIntegratorOptions" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions = { "ROOT::Math::IntegratorOneDimOptions" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions = { "ROOT::Math::IntegratorMultiDimOptions" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator = { "ROOT::Math::VirtualIntegrator" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim = { "ROOT::Math::VirtualIntegratorOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim = { "ROOT::Math::VirtualIntegratorMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim = { "ROOT::Math::IntegratorOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim = { "ROOT::Math::AdaptiveIntegratorMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim = { "ROOT::Math::IntegratorMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLDistSampler = { "ROOT::Math::DistSampler" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLFactory = { "ROOT::Math::Factory" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR = { "ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgRcLcLType_t = { "ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_t" , 101 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR = { "ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgRcLcLType_t = { "ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_t" , 101 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator = { "ROOT::Math::GaussIntegrator" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator = { "ROOT::Math::GaussLegendreIntegrator" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod = { "ROOT::Math::IRootFinderMethod" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder = { "ROOT::Math::RootFinder" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType = { "ROOT::Math::RootFinder::EType" , 101 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLtypedef = { "ROOT::Math::typedef" , 0 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator = { "ROOT::Math::RichardsonDerivator" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIMinimizer1D = { "ROOT::Math::IMinimizer1D" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D = { "ROOT::Math::BrentMinimizer1D" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder = { "ROOT::Math::BrentRootFinder" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLFitcLcLDataRange = { "ROOT::Fit::DataRange" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLFitcLcLUnBinData = { "ROOT::Fit::UnBinData" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLDistSamplerOptions = { "ROOT::Math::DistSamplerOptions" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest = { "ROOT::Math::GoFTest" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLEDistribution = { "ROOT::Math::GoFTest::EDistribution" , 101 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLEUserDistribution = { "ROOT::Math::GoFTest::EUserDistribution" , 101 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLETestType = { "ROOT::Math::GoFTest::ETestType" , 101 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR = { "vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_reverse_iteratorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEconstsPdoublemUcOallocatorlEconstsPdoublemUgRsPgR = { "vector<const double*,allocator<const double*> >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_reverse_iteratorlEvectorlEconstsPdoublemUcOallocatorlEconstsPdoublemUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<const double*,allocator<const double*> >::iterator>" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableG__MathCore() {
  G__G__MathCoreLN_type_info.tagnum = -1 ;
  G__G__MathCoreLN_TClass.tagnum = -1 ;
  G__G__MathCoreLN_TBuffer.tagnum = -1 ;
  G__G__MathCoreLN_TMemberInspector.tagnum = -1 ;
  G__G__MathCoreLN_TObject.tagnum = -1 ;
  G__G__MathCoreLN_TNamed.tagnum = -1 ;
  G__G__MathCoreLN_TString.tagnum = -1 ;
  G__G__MathCoreLN_TVirtualIsAProxy.tagnum = -1 ;
  G__G__MathCoreLN_ROOT.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLTInitBehavior.tagnum = -1 ;
  G__G__MathCoreLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_string.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathCoreLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathCoreLN_TRandom.tagnum = -1 ;
  G__G__MathCoreLN_TRandom1.tagnum = -1 ;
  G__G__MathCoreLN_TRandom2.tagnum = -1 ;
  G__G__MathCoreLN_TRandom3.tagnum = -1 ;
  G__G__MathCoreLN_TMethodCall.tagnum = -1 ;
  G__G__MathCoreLN_Foption_t.tagnum = -1 ;
  G__G__MathCoreLN_TVirtualFitter.tagnum = -1 ;
  G__G__MathCoreLN_TKDTreelEintcOdoublegR.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEintcOallocatorlEintgRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathCoreLN_TKDTreelEintcOfloatgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLFit.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLFitcLcLBinData.tagnum = -1 ;
  G__G__MathCoreLN_TKDTreeBinning.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator.tagnum = -1 ;
  G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathCoreLN_pairlEdoublecOdoublegR.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_reverse_iteratorlEvectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathCoreLN_pairlEboolcOboolgR.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_reverse_iteratorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcOallocatorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_reverse_iteratorlEvectorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcOallocatorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathCoreLN_maplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRcOallocatorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_reverse_iteratorlEvectorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRcOallocatorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathCoreLN_TKDTreeBinningcLcLdA.tagnum = -1 ;
  G__G__MathCoreLN_pairlEconstsPdoublemUcOconstsPdoublemUgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMath.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctionBase.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor.tagnum = -1 ;
  G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D.tagnum = -1 ;
  G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionOneDimgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor.tagnum = -1 ;
  G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D.tagnum = -1 ;
  G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionOneDimgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizer.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLBaseIntegratorOptions.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLDistSampler.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLFactory.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgRcLcLType_t.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgRcLcLType_t.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLtypedef.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIMinimizer1D.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLFitcLcLDataRange.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLFitcLcLUnBinData.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLDistSamplerOptions.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLEDistribution.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLEUserDistribution.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLETestType.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_reverse_iteratorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEconstsPdoublemUcOallocatorlEconstsPdoublemUgRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_reverse_iteratorlEvectorlEconstsPdoublemUcOallocatorlEconstsPdoublemUgRsPgRcLcLiteratorgR.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableG__MathCore() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_type_info);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TClass);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TBuffer);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TMemberInspector);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TObject);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TNamed);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TString);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TVirtualIsAProxy);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOT),0,-1,0,(char*)NULL,G__setup_memvarROOT,G__setup_memfuncROOT);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLTInitBehavior);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_string);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TRandom),sizeof(TRandom),-1,324864,"Simple Random number generator (periodicity = 10**9)",G__setup_memvarTRandom,G__setup_memfuncTRandom);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TRandom1),sizeof(TRandom1),-1,324864,"Ranlux Random number generators with periodicity > 10**14",G__setup_memvarTRandom1,G__setup_memfuncTRandom1);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TRandom2),sizeof(TRandom2),-1,324864,"Random number generator with periodicity of 10**26",G__setup_memvarTRandom2,G__setup_memfuncTRandom2);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TRandom3),sizeof(TRandom3),-1,128256,"Random number generator: Mersenne Twistor",G__setup_memvarTRandom3,G__setup_memfuncTRandom3);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TMethodCall);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_Foption_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TVirtualFitter),sizeof(TVirtualFitter),-1,327444,"Abstract interface for fitting",G__setup_memvarTVirtualFitter,G__setup_memfuncTVirtualFitter);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TKDTreelEintcOdoublegR),sizeof(TKDTree<int,double>),-1,327424,"KD tree",G__setup_memvarTKDTreelEintcOdoublegR,G__setup_memfuncTKDTreelEintcOdoublegR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_vectorlEintcOallocatorlEintgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TKDTreelEintcOfloatgR),sizeof(TKDTree<int,float>),-1,327424,"KD tree",G__setup_memvarTKDTreelEintcOfloatgR,G__setup_memfuncTKDTreelEintcOfloatgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLFit);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLFitcLcLBinData);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TKDTreeBinning),sizeof(TKDTreeBinning),-1,327168,(char*)NULL,G__setup_memvarTKDTreeBinning,G__setup_memfuncTKDTreeBinning);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),sizeof(vector<double,allocator<double> >),-1,298752,(char*)NULL,G__setup_memvarvectorlEdoublecOallocatorlEdoublegRsPgR,G__setup_memfuncvectorlEdoublecOallocatorlEdoublegRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator),sizeof(vector<double,allocator<double> >::iterator),-1,35072,(char*)NULL,G__setup_memvarvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator,G__setup_memfuncvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),sizeof(reverse_iterator<vector<double,allocator<double> >::iterator>),-1,256,(char*)NULL,G__setup_memvarreverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR,G__setup_memfuncreverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_pairlEdoublecOdoublegR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_reverse_iteratorlEvectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_pairlEboolcOboolgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_vectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_reverse_iteratorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_vectorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcOallocatorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_reverse_iteratorlEvectorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRcOallocatorlEvectorlEpairlEboolcOboolgRcOallocatorlEpairlEboolcOboolgRsPgRsPgRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_maplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_vectorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRcOallocatorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_reverse_iteratorlEvectorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRcOallocatorlEmaplEdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOlesslEdoublegRcOallocatorlEpairlEconstsPdoublecOvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TKDTreeBinningcLcLdA);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_pairlEconstsPdoublemUcOconstsPdoublemUgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMath),0,-1,0,(char*)NULL,G__setup_memvarROOTcLcLMath,G__setup_memfuncROOTcLcLMath);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),sizeof(ROOT::Math::IBaseFunctionOneDim),-1,263426,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIBaseFunctionOneDim,G__setup_memfuncROOTcLcLMathcLcLIBaseFunctionOneDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),sizeof(ROOT::Math::IGradientFunctionOneDim),-1,263171,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIGradientFunctionOneDim,G__setup_memfuncROOTcLcLMathcLcLIGradientFunctionOneDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),sizeof(ROOT::Math::IBaseFunctionMultiDim),-1,263427,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIBaseFunctionMultiDim,G__setup_memfuncROOTcLcLMathcLcLIBaseFunctionMultiDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),sizeof(ROOT::Math::IGradientFunctionMultiDim),-1,263172,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIGradientFunctionMultiDim,G__setup_memfuncROOTcLcLMathcLcLIGradientFunctionMultiDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim),sizeof(ROOT::Math::IGradientMultiDim),-1,263171,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIGradientMultiDim,G__setup_memfuncROOTcLcLMathcLcLIGradientMultiDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim),sizeof(ROOT::Math::IGradientOneDim),-1,263170,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIGradientOneDim,G__setup_memfuncROOTcLcLMathcLcLIGradientOneDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),sizeof(ROOT::Math::IParametricFunctionOneDim),-1,262149,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIParametricFunctionOneDim,G__setup_memfuncROOTcLcLMathcLcLIParametricFunctionOneDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim),sizeof(ROOT::Math::IParametricGradFunctionOneDim),-1,263174,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIParametricGradFunctionOneDim,G__setup_memfuncROOTcLcLMathcLcLIParametricGradFunctionOneDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim),sizeof(ROOT::Math::IParametricFunctionMultiDim),-1,262150,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIParametricFunctionMultiDim,G__setup_memfuncROOTcLcLMathcLcLIParametricFunctionMultiDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim),sizeof(ROOT::Math::IParametricGradFunctionMultiDim),-1,263175,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIParametricGradFunctionMultiDim,G__setup_memfuncROOTcLcLMathcLcLIParametricGradFunctionMultiDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam),sizeof(ROOT::Math::IBaseParam),-1,263171,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIBaseParam,G__setup_memfuncROOTcLcLMathcLcLIBaseParam);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctionBase);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor),sizeof(ROOT::Math::ParamFunctor),-1,298752,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLParamFunctor,G__setup_memfuncROOTcLcLMathcLcLParamFunctor);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor),sizeof(ROOT::Math::Functor),-1,101632,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLFunctor,G__setup_memfuncROOTcLcLMathcLcLFunctor);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D),sizeof(ROOT::Math::Functor1D),-1,101632,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLFunctor1D,G__setup_memfuncROOTcLcLMathcLcLFunctor1D);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionOneDimgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor),sizeof(ROOT::Math::GradFunctor),-1,101632,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGradFunctor,G__setup_memfuncROOTcLcLMathcLcLGradFunctor);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D),sizeof(ROOT::Math::GradFunctor1D),-1,101632,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGradFunctor1D,G__setup_memfuncROOTcLcLMathcLcLGradFunctor1D);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionOneDimgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIOptions),sizeof(ROOT::Math::IOptions),-1,263425,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIOptions,G__setup_memfuncROOTcLcLMathcLcLIOptions);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions),sizeof(ROOT::Math::MinimizerOptions),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLMinimizerOptions,G__setup_memfuncROOTcLcLMathcLcLMinimizerOptions);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizer),sizeof(ROOT::Math::Minimizer),-1,265997,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLMinimizer,G__setup_memfuncROOTcLcLMathcLcLMinimizer);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDim),0,-1,0,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIntegrationOneDim,G__setup_memfuncROOTcLcLMathcLcLIntegrationOneDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDim),0,-1,0,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIntegrationMultiDim,G__setup_memfuncROOTcLcLMathcLcLIntegrationMultiDim);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLBaseIntegratorOptions),sizeof(ROOT::Math::BaseIntegratorOptions),-1,265985,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLBaseIntegratorOptions,G__setup_memfuncROOTcLcLMathcLcLBaseIntegratorOptions);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions),sizeof(ROOT::Math::IntegratorOneDimOptions),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIntegratorOneDimOptions,G__setup_memfuncROOTcLcLMathcLcLIntegratorOneDimOptions);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions),sizeof(ROOT::Math::IntegratorMultiDimOptions),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIntegratorMultiDimOptions,G__setup_memfuncROOTcLcLMathcLcLIntegratorMultiDimOptions);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator),sizeof(ROOT::Math::VirtualIntegrator),-1,263173,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLVirtualIntegrator,G__setup_memfuncROOTcLcLMathcLcLVirtualIntegrator);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim),sizeof(ROOT::Math::VirtualIntegratorOneDim),-1,263181,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLVirtualIntegratorOneDim,G__setup_memfuncROOTcLcLMathcLcLVirtualIntegratorOneDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim),sizeof(ROOT::Math::VirtualIntegratorMultiDim),-1,263176,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLVirtualIntegratorMultiDim,G__setup_memfuncROOTcLcLMathcLcLVirtualIntegratorMultiDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim),sizeof(ROOT::Math::IntegratorOneDim),-1,298752,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIntegratorOneDim,G__setup_memfuncROOTcLcLMathcLcLIntegratorOneDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim),sizeof(ROOT::Math::AdaptiveIntegratorMultiDim),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLAdaptiveIntegratorMultiDim,G__setup_memfuncROOTcLcLMathcLcLAdaptiveIntegratorMultiDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim),sizeof(ROOT::Math::IntegratorMultiDim),-1,298752,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIntegratorMultiDim,G__setup_memfuncROOTcLcLMathcLcLIntegratorMultiDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLDistSampler),sizeof(ROOT::Math::DistSampler),-1,263425,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLDistSampler,G__setup_memfuncROOTcLcLMathcLcLDistSampler);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory),sizeof(ROOT::Math::Factory),-1,262144,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLFactory,G__setup_memfuncROOTcLcLMathcLcLFactory);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),sizeof(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>),-1,295939,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR,G__setup_memfuncROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgRcLcLType_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),sizeof(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>),-1,295940,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR,G__setup_memfuncROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgRcLcLType_t);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator),sizeof(ROOT::Math::GaussIntegrator),-1,263424,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGaussIntegrator,G__setup_memfuncROOTcLcLMathcLcLGaussIntegrator);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator),sizeof(ROOT::Math::GaussLegendreIntegrator),-1,263424,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGaussLegendreIntegrator,G__setup_memfuncROOTcLcLMathcLcLGaussLegendreIntegrator);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod),sizeof(ROOT::Math::IRootFinderMethod),-1,263428,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIRootFinderMethod,G__setup_memfuncROOTcLcLMathcLcLIRootFinderMethod);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder),sizeof(ROOT::Math::RootFinder),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRootFinder,G__setup_memfuncROOTcLcLMathcLcLRootFinder);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLtypedef);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator),sizeof(ROOT::Math::RichardsonDerivator),-1,298752,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRichardsonDerivator,G__setup_memfuncROOTcLcLMathcLcLRichardsonDerivator);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIMinimizer1D),sizeof(ROOT::Math::IMinimizer1D),-1,263434,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIMinimizer1D,G__setup_memfuncROOTcLcLMathcLcLIMinimizer1D);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D),sizeof(ROOT::Math::BrentMinimizer1D),-1,263424,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLBrentMinimizer1D,G__setup_memfuncROOTcLcLMathcLcLBrentMinimizer1D);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder),sizeof(ROOT::Math::BrentRootFinder),-1,263424,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLBrentRootFinder,G__setup_memfuncROOTcLcLMathcLcLBrentRootFinder);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLFitcLcLDataRange);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLFitcLcLUnBinData);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLDistSamplerOptions),sizeof(ROOT::Math::DistSamplerOptions),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLDistSamplerOptions,G__setup_memfuncROOTcLcLMathcLcLDistSamplerOptions);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTest),sizeof(ROOT::Math::GoFTest),-1,298752,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGoFTest,G__setup_memfuncROOTcLcLMathcLcLGoFTest);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLEDistribution);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLEUserDistribution);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLGoFTestcLcLETestType);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_reverse_iteratorlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_vectorlEconstsPdoublemUcOallocatorlEconstsPdoublemUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_reverse_iteratorlEvectorlEconstsPdoublemUcOallocatorlEconstsPdoublemUgRsPgRcLcLiteratorgR);
}
extern "C" void G__cpp_setupG__MathCore(void) {
  G__check_setup_version(30051515,"G__cpp_setupG__MathCore()");
  G__set_cpp_environmentG__MathCore();
  G__cpp_setup_tagtableG__MathCore();

  G__cpp_setup_inheritanceG__MathCore();

  G__cpp_setup_typetableG__MathCore();

  G__cpp_setup_memvarG__MathCore();

  G__cpp_setup_memfuncG__MathCore();
  G__cpp_setup_globalG__MathCore();
  G__cpp_setup_funcG__MathCore();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncG__MathCore();
  return;
}
class G__cpp_setup_initG__MathCore {
  public:
    G__cpp_setup_initG__MathCore() { G__add_setup_func("G__MathCore",(G__incsetup)(&G__cpp_setupG__MathCore)); G__call_setup_funcs(); }
   ~G__cpp_setup_initG__MathCore() { G__remove_setup_func("G__MathCore"); }
};
G__cpp_setup_initG__MathCore G__cpp_setup_initializerG__MathCore;

