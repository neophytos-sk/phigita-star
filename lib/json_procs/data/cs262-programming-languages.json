{"version": "dacity-32", "payload": {"course": {"instructors": [{"bio": "Westley Weimer is a Professor of Computer Science at the University of Virginia where he teaches computer science and leads research in <a href=\"http://www.cs.virginia.edu/~weimer/\" target=\"_blank\">programming languages and software engineering</a>. He has won three awards for teaching and over half a dozen \"best paper\" awards for research. He has MS and PhD degrees from the University of California at Berkeley.", "name": "Westley Weimer", "parent": "None", "headshot_url": "/image/headshot/Instructor/859012", "key": "agpzfnVkYWNpdHl1chILEgpJbnN0cnVjdG9yGIS3NAw", "path": "Instructor/859012", "type": "Instructor", "id": 859012}], "name": "Programming Languages", "parent": "None", "icon_url": "/icon/Course/cs262", "faq": "<p>\n<b>Is there a fee to take the course?</b><br/>\nNope, no fees. All of our classes are offered free of charge.\n</p>\n\n<p>\n<b>Can you enroll in more than one class? </b><br/>\nYes! Keep in mind CS101 is intended for students with no previous programming background, CS212, 253 and 262 are courses are oriented towards students with some programming experience (the equivalent of CS101), while CS373 and CS387 assumes students have prior programming experience.</p>\n\n<p>\n<b>When do classes start?</b><br/>\n\nApril 16, 2012.\n</p>\n\n<p>\n<b>When do I have to be online to watch the lectures?</b><br/>\nThe lectures are posted each week for you to view at your convenience.\n</p>\n\n<p>\n<b>How is the class formatted?</b><br/>\nBoth classes are broken into 6 week-long units and seventh week that wraps up the course and has a final exam. Each unit contains multiple lecture segments with interactive quizzes built in.  There will be one homework assignment which will include programming problems each week. There will be approximately 50 minutes of lecture videos.\n</p>\n\n<p>\n<b>Will there be closed captioning?</b><br/>\n\nYes, the videos will have captions in English.  We're also working to support other languages in future.\n</p>\n\n<p>\n<b>What will I get for completing the classes?</b><br/>\nStudents who complete a course will also receive a certificate signed by the instructors. \n</p>", "syllabus": "<p><b>Description</b>: This class will give you an introduction to fundamentals \n\t\tof programming languages. In seven weeks, you will build your own simple web browser \n\t\tcomplete with the ability to parse and understand HTML and JavaScript. You will learn \n\t\tkey concepts such as how to specify and process valid strings, sentences and program \n\t\tstructures. Then, you will design and build an interpreter - a program that simulates \n\t\tother programs.</p>\n\t\t\n\t\t<p class=\"syllabus-week\">WEEK 1:</p>\n\t\t<p class=\"syllabus-desc\">\n\t\t<b>String Patterns</b><br>\n\t\t   Finding and specifying classes of strings using regular expressions\n\t\t</p>\n\t\t<br class=\"clear\"/>\n\t\t<p class=\"syllabus-week\">WEEK 2:</p>\n\t\t<p class=\"syllabus-desc\">\n\t\t<b>Lexical Analysis</b><br>\n\t\t   Breaking strings down into important words\n\t\t</p>\n\t\t<br class=\"clear\"/>\n\t\t<p class=\"syllabus-week\">WEEK 3:</p>\n\t\t<p class=\"syllabus-desc\">\n\t\t<b>Grammars</b><br>\n\t\t   Specifying and deconstructing valid sentences\n\t\t</p>\n\t\t<br class=\"clear\"/>\n\t\t<p class=\"syllabus-week\">WEEK 4:</p>\n\t\t<p class=\"syllabus-desc\">\n\t\t<b>Parsing</b><br>\n\t\t   Turning sentences into trees\n\t\t</p>\n\t\t<br class=\"clear\"/>\n\t\t<p class=\"syllabus-week\">WEEK 5:</p>\n\t\t<p class=\"syllabus-desc\">\n\t\t<b>Interpreting</b><br>\n\t\t   Simulating programs\n\t\t</p>\n\t\t<br class=\"clear\"/>\n\t\t<p class=\"syllabus-week\">WEEK 6:</p>\n\t\t<p class=\"syllabus-desc\">\n\t\t<b>Building a Web Browser</b><br>\n\t\t   Interpreting HTML and JavaScript\n\t\t</p>\n\t\t<br class=\"clear\"/>\n\t\t<p class=\"syllabus-week\">WEEK 7:</p>\n\t\t<p class=\"syllabus-desc\">\n\t\t<b>Wrap-up</b><br>\n\t\t   Exam testing your knowledge\n\t\t</p>", "teaser": {"dotsub_id": null, "name": "teaser", "parent": "None", "transcript": null, "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1cg0LEgVNZWRpYRjC1DIM", "youtube_id": "cn83Tm1jNSo", "youtube_state": null, "path": "Media/830018", "type": "Media", "id": 830018}, "prereqs": "<p>\n    This course assumes previous programming experience, comparable to what is covered by the Udacity CS101 course.  \n\t</p>", "image_url": "/image/Course/cs262", "key": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "is_public": true, "course_id": "cs262", "path": "Course/cs262", "type": "Course", "id": "cs262", "description": "Learn about programming languages while building a web browser! You will understand JavaScript and HTML from the inside-out in this exciting class."}, "course_rev": {"unitLayout": [{"unit_key": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA"}, {"unit_key": "agpzfnVkYWNpdHl1cjMLEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAww"}], "name": "April 2012", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "state": 1, "key": "agpzfnVkYWNpdHl1cicLEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgw", "units": [{"name": "Unit 1", "parent": "agpzfnVkYWNpdHl1cicLEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgw", "type": "Unit", "evaluated": false, "closedAt": "", "nuggetLayout": [[{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiJJww"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjYgAUM"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiEVgw"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjZNgw"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjBuAIM"}, {"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjCPgw"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiRTgw"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBj5zwIM"}, {"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjyLgw"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjhXQw"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBih5gUM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiLlQYM"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiadQw"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiBfQw"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjJlAEM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjJ0wYM"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBj6VQw"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBi5lAEM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBihlgMM"}, {"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjKZQw"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjErwUM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiJpAEM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBia7wIM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjxqwEM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBj6xgUM"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiSTgw"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiTvAYM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjT_QUM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjshAEM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiKpAEM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjBtQMM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiRywEM"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjcNgw"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiTywEM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjS1gUM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiinAEM"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBj8VQw"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjzpQMM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjh2gEM"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjFPgw"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiB6wYM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBix2wYM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBix6gEM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiZ8gEM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjyqwEM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjUhgMM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjpgQIM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiJmwQM"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBj9VQw"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBj80gEM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiF-gEM"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBi6Fww"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiC-gEM"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjHPgw"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBic7wIM"}, {"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjNZQw"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiqtAYM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiSywEM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjbrQMM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiD-gEM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjeswEM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjl1AMM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBihmQIM"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiPVgw"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiRuQcM"}, {"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiUTgw"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjVjAEM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiy5AMM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiE-gEM"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjjXQw"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiJoQIM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjp8gYM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiC9wIM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjXjAEM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjk1wIM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBijnAEM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjTiQIM"}], [{"nugget_key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiTTgw"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjozgUM"}, {"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBi_lAEM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjopwUM"}], [{"nugget_key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiZ4wYM"}]], "availableAt": "", "key": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "path": "Course/cs262/CourseRev/apr2012/Unit/3001", "open": false, "id": 3001, "nuggets": [{"nuggetType": "lecture", "name": "Quoted Strings", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "4858b4e7-57b7-46dd-85dc-d694c4b5b01a", "name": "cs262_unit1_20_l_quoted-strings", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGPOrAQw", "youtube_id": "o8pJy8XSdRQ", "youtube_state": "done", "path": "Course/cs262/Media/22003", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nQuoted strings, that is, strings that are surrounded by double quotes, or the like,\n\n2\n00:00:04,000 --> 00:00:08,000\nare a tricky issue that comes up in both JavaScript and HTML.\n\n3\n00:00:08,000 --> 00:00:14,000\nLet's bring all of our regular expression power to bear to see about separating \n\n4\n00:00:14,000 --> 00:00:16,000\nquoted strings from other words.\n\n5\n00:00:16,000 --> 00:00:21,000\nHere I've drawn an evil quoted string that contains a bunch of double quotes.\n\n6\n00:00:21,000 --> 00:00:28,000\nWe really want to get to just the heart of it, just the contents and peel off \n\n7\n00:00:28,000 --> 00:00:29,000\nthese 2 double quotes at the end.\n\n8\n00:00:29,000 --> 00:00:32,000\nThere like the rind. I want to get to the core.\n\n9\n00:00:32,000 --> 00:00:36,000\nHowever, if I just repeatedly use string.find to look for double quotes,\n\n10\n00:00:36,000 --> 00:00:39,000\nI'll find this one, but also this one in the middle.\n\n11\n00:00:39,000 --> 00:00:41,000\nThis one in the middle, and this one in the end.\n\n12\n00:00:41,000 --> 00:00:45,000\nSo I might mistakenly think that it's 2 quoted strings--\n\n13\n00:00:45,000 --> 00:00:48,000\nI said, and nothing over here.\n\n14\n00:00:48,000 --> 00:00:50,000\nOh no! Find isn't good enough!\n\n15\n00:00:50,000 --> 00:00:54,000\nIn a shocking twist, we'll have to use regular expressions instead.\n\n16\n00:00:54,000 --> 00:00:59,000\nBut first, to make our job a little easier, let me introduce to you some new regular expressions.\n\n17\n00:00:59,000 --> 00:01:05,000\nThe first is the dot, or period, which matches any character except a new line,\n\n18\n00:01:05,000 --> 00:01:08,000\nor what you get when you press enter or return.\n\n19\n00:01:08,000 --> 00:01:15,000\nFor example, here I'm looking for any decimal digit [0 - 9] and then any character--\n\n20\n00:01:15,000 --> 00:01:18,000\nanything except a line break--and then another [0 - 9].\n\n21\n00:01:18,000 --> 00:01:22,000\nSo for example, this is a decimal digit. This is another decimal digit.\n\n22\n00:01:22,000 --> 00:01:24,000\nAnd the \"a\" between them is any character.\n\n23\n00:01:24,000 --> 00:01:29,000\nThis 2 is a decimal digit. The 2 between them is any character. This 2 is another decimal digit.\n\n24\n00:01:29,000 --> 00:01:34,000\nThis \"cc3\" doesn't qualify because this \"c\" is not in [0 - 9].\n\n25\n00:01:34,000 --> 00:01:39,000\nAnd one more--sometimes it's nice to be able to say anything except a digit\n\n26\n00:01:39,000 --> 00:01:42,000\nor anything except a number or anything except p. \n\n27\n00:01:42,000 --> 00:01:48,000\nHere we're looking for [0 - 9], followed by anything that's not \"a\" and also not \"b\".\n\n28\n00:01:48,000 --> 00:01:52,000\nSo here--oh! That immediately didn't work because the next thing was an \"a\",\n\n29\n00:01:52,000 --> 00:01:54,000\nand we're asking for not \"a\".\n\n30\n00:01:54,000 --> 00:02:00,000\nRight over here we've got a 1 and a space, and space isn't \"a\" or \"b\", so that looks good.\n\n31\n00:02:00,000 --> 00:02:05,000\nThen here we've got a 2 and a 2, and this second 2 is not \"a\" or \"b\", so that looks good.\n\n32\n00:02:05,000 --> 00:02:10,000\nHere we've got a 2 and a space, and this space is not \"a\" or \"b\", so that looks good.\n\n33\n00:02:10,000 --> 00:02:16,000\n\"C\" is not [0 - 9]. \"C\" is not [0 - 9], 3 is [0 - 9], but then we're at the end of the string.\n\n34\n00:02:16,000 --> 00:02:17,000\nSo that's it.\n\n", "id": 22003}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBi6Fww", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/3002", "type": "Nugget", "id": 3002}, {"nuggetType": "lecture", "name": "Building A Web Browser", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "cee4ff6b-ad2c-424c-8222-99369f42b47f", "name": "cs262_unit1_00_l_building-a-web-browser", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGKEfDA", "youtube_id": "Qr_7NpTHsrA", "youtube_state": "done", "path": "Course/cs262/Media/4001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\n[Wes:] Welcome to Programming Languages. I'm Wes Weimer.\n\n2\n00:00:04,000 --> 00:00:08,000\nTogether we're going to learn the theory and practice of programming languages,\n\n3\n00:00:08,000 --> 00:00:11,000\nculminating in the construction of a web browser.\n\n4\n00:00:11,000 --> 00:00:17,000\nOur web browser will accept as input HTML and JavaScript, the primary languages of the web,\n\n5\n00:00:17,000 --> 00:00:22,000\nand use that to produce an image of the web page.\n\n6\n00:00:22,000 --> 00:00:27,000\nYou may already be familiar with HTML, which describes the basics of web pages.\n\n7\n00:00:27,000 --> 00:00:32,000\nWe'll certainly go over it in this course later on, but you may be a less familiar with JavaScript,\n\n8\n00:00:32,000 --> 00:00:37,000\n which allows one to describe computations that take place on web pages.\n\n9\n00:00:37,000 --> 00:00:40,000\nThis gives us a lot of power and also a lot of flashy graphics.\n\n10\n00:00:40,000 --> 00:00:42,000\nLet's see some examples.\n\n11\n00:00:42,000 --> 00:00:45,000\nThis particular webpage, chosen more or less at random, \n\n12\n00:00:45,000 --> 00:00:51,000\nuses JavaScript to animate these tabs for its title bar at the top.\n\n13\n00:00:51,000 --> 00:00:54,000\nThis is a second example of a webpage that uses JavaScript,\n\n14\n00:00:54,000 --> 00:00:57,000\nboth here at the top for this sort of floating tool tip,\n\n15\n00:00:57,000 --> 00:01:02,000\nbut also down here at the bottom to animate the differences between these textual boxes.\n\n16\n00:01:02,000 --> 00:01:05,000\nIf we look at the source for one of these webpages, \n\n17\n00:01:05,000 --> 00:01:12,000\nwe can see that it contains both HTML and JavaScript right from the start.\n\n18\n00:01:12,000 --> 00:01:15,000\nLet me give you a brief overview, in pictures more or less, \n\n19\n00:01:15,000 --> 00:01:19,000\nof how this course and the overarching project will go.\n\n20\n00:01:19,000 --> 00:01:24,000\nWe start with the source to a webpage, which is in HTML and JavaScript.\n\n21\n00:01:24,000 --> 00:01:28,000\nOur next main step is to break that source into important words,\n\n22\n00:01:28,000 --> 00:01:32,000\njust like we could break and English sentence into important words.\n\n23\n00:01:32,000 --> 00:01:36,000\nThen we'll understand the structure of the words that we found.\n\n24\n00:01:36,000 --> 00:01:42,000\nFor example, focusing on this part down here, it may be easier to understand 1 plus 2 plus 3\n\n25\n00:01:42,000 --> 00:01:45,000\nas a tree, showing all of the computations.\n\n26\n00:01:45,000 --> 00:01:48,000\nThen finally we'll figure out the meaning of that structure.\n\n27\n00:01:48,000 --> 00:01:51,000\nFor example, in this case maybe all of that adds up to 6,\n\n28\n00:01:51,000 --> 00:01:54,000\nand that's what we'll display in our resulting webpage.\n\n29\n00:01:54,000 --> 00:01:58,000\nBuilding a web browser will be a lot of fun, but the overall goal of this course is not \n\n30\n00:01:58,000 --> 00:02:01,000\nactually to build a production quality browser,\n\n31\n00:02:01,000 --> 00:02:04,000\nbut instead to use the goal of building a browser as a way\n\n32\n00:02:04,000 --> 00:02:07,000\nof structuring our exploration of computer science.\n\n33\n00:02:07,000 --> 00:02:10,000\nLet's get started right here in step 1.\n\n", "id": 4001}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiJJww", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/5001", "type": "Nugget", "id": 5001}, {"nuggetType": "lecture", "name": "Selecting Substrings Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "a27dca85-bd5d-49ec-8190-0a8966510f76", "name": "cs262_unit1_02_s_selecting-substrings", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGPlVDA", "youtube_id": "kwlM46Ov5uI", "youtube_state": "done", "path": "Course/cs262/Media/11001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nLet's go through a possible answer together.\n\n2\n00:00:02,000 --> 00:00:04,000\nHere I've written out a candidate example.\n\n3\n00:00:04,000 --> 00:00:07,000\nLet's image that \"bell hooks\" is p and \"curer bell\" is q.\n\n4\n00:00:07,000 --> 00:00:11,000\nThe first thing we're going to do is find the index into p of the first space.\n\n5\n00:00:11,000 --> 00:00:18,000\nPindex space 0, 1, 2, 3, 4. This'll be 4 in our running example.\n\n6\n00:00:18,000 --> 00:00:25,000\nQindex--the location of this space in q might be different--0, 1, 2, 3, 4, 5.\n\n7\n00:00:25,000 --> 00:00:27,000\nIn fact in our example it is.\n\n8\n00:00:27,000 --> 00:00:30,000\nNow what I want to do is select out the first word in p.\n\n9\n00:00:30,000 --> 00:00:36,000\nI want everything from the beginning all the way up to, but not including, the space.\n\n10\n00:00:36,000 --> 00:00:40,000\nThis selection goes to the left as far as it can but does not include pindex,\n\n11\n00:00:40,000 --> 00:00:42,000\nso it will be \"bell.\"\n\n12\n00:00:42,000 --> 00:00:45,000\nI could also have put a 0 in here. That would have been exactly the same.\n\n13\n00:00:45,000 --> 00:00:48,000\nFor q I don't want to start at position 5.\n\n14\n00:00:48,000 --> 00:00:53,000\nI actually want to start at position 6, starting with the b and going to the end of the word.\n\n15\n00:00:53,000 --> 00:00:56,000\nThis is q's second word, which in our running example is also bell,\n\n16\n00:00:56,000 --> 00:00:59,000\nsince bell equals bell, we'll just return True.\n\n17\n00:00:59,000 --> 00:01:06,000\nCurer Bell was actually a pseudonym, a false name, adopted by Charlotte Bronte, an author.\n\n", "id": 11001}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjyLgw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/6002", "type": "Nugget", "id": 6002}, {"nuggetType": "lecture", "name": "Breaking Up Strings", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "952c7f1c-752f-4014-b41d-5572128894a6", "name": "cs262_unit1_01_q_breaking-up-strings", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGPEuDA", "youtube_id": "gXsQQ2RpIVY", "youtube_state": "done", "path": "Course/cs262/Media/6001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nWe want to break up strings like the source to a webpage into important words,\n\n2\n00:00:04,000 --> 00:00:07,000\nand we're going to use Python to do it.\n\n3\n00:00:07,000 --> 00:00:10,000\nWe're given as input part of a webpage like this--\n\n4\n00:00:10,000 --> 00:00:14,000\n\"Hello 1\" with some syntax over here on the left that we'll get to in a bit.\n\n5\n00:00:14,000 --> 00:00:19,000\nOne approach to breaking this up would be to use Python's string.find function\n\n6\n00:00:19,000 --> 00:00:25,000\nto find this space and then split up the string into everything to the right of the space\n\n7\n00:00:25,000 --> 00:00:27,000\nand everything to the left of the space.\n\n8\n00:00:27,000 --> 00:00:30,000\nYou may already be familiar with Python's string.find function \n\n9\n00:00:30,000 --> 00:00:33,000\nfrom previous experience with computer science.\n\n10\n00:00:33,000 --> 00:00:38,000\nBut if you're not, it's often described as finding a needle in a haystack.\n\n11\n00:00:38,000 --> 00:00:42,000\nFor example, let's say that I want to find the \"fun\" in \"Mifune Toshiro.\"\n\n12\n00:00:42,000 --> 00:00:46,000\nThis is our needle, and we're going to look for the first copy of it we can find \n\n13\n00:00:46,000 --> 00:00:51,000\nover here in the haystack string on the left, and there is some \"fun\" hidden in there.\n\n14\n00:00:51,000 --> 00:00:58,000\nThe answer we get back will be the string index of the beginning of the fun, which for us is 2.\n\n15\n00:00:58,000 --> 00:01:02,000\nYou may be wondering why this is 2 and not some other value like, say, 7.\n\n16\n00:01:02,000 --> 00:01:08,000\nRemember that Python strings--and, in fact, almost all Python collections start counting at zero.\n\n17\n00:01:08,000 --> 00:01:12,000\nThe \"m\" is at position zero, the \"i\" is at position 1, and the \"f\" is at position 2,\n\n18\n00:01:12,000 --> 00:01:14,000\nand that's where the fun starts.\n\n19\n00:01:14,000 --> 00:01:19,000\nToshiro Mifune is a Japanese actor, and one of his most famous roles is the bandit in Rashamon.\n\n20\n00:01:19,000 --> 00:01:23,000\nWell, we found the fun, so snap, the rest of the job's a game.\n\n21\n00:01:23,000 --> 00:01:25,000\nLet's see a few more examples of this.\n\n22\n00:01:25,000 --> 00:01:29,000\nWe want to find a space in \"Hello world,\" and there's one right here--\n\n23\n00:01:29,000 --> 00:01:34,000\nposition 0, 1, 2, 3, 4, 5. Our final answer is 5.\n\n24\n00:01:34,000 --> 00:01:37,000\nYou can also find a starting position.\n\n25\n00:01:37,000 --> 00:01:43,000\nHere, if we're trying to find 1 in \"1 + 1 = 2,\" the first occurrence can be found at position 0,\n\n26\n00:01:43,000 --> 00:01:48,000\nbut if we only start around position 2, then the answer we get will be 4.\n\n27\n00:01:48,000 --> 00:01:53,000\nIf the needle you're looking for does occur in your big base string\n\n28\n00:01:53,000 --> 00:01:58,000\nPython returns negative 1, which is out of range for the string, to indicate as much.\n\n29\n00:01:58,000 --> 00:02:03,000\nLet's review and test your knowledge of string.find with a quiz.\n\n30\n00:02:03,000 --> 00:02:06,000\nIn this class, quizzes are for your benefit. They check your understanding.\n\n31\n00:02:06,000 --> 00:02:10,000\nThey don't count for your grade in any way.\n\n32\n00:02:10,000 --> 00:02:13,000\nThey are not meant to be stressful, and you can try them as many times \n\n33\n00:02:13,000 --> 00:02:15,000\nas you like until you get the right answer.\n\n34\n00:02:15,000 --> 00:02:19,000\nHere I've written two Python expressions--       \"Ada Lovelace\" dot find space.\n\n35\n00:02:19,000 --> 00:02:21,000\nLet's say we're trying to break this up into words.\n\n36\n00:02:21,000 --> 00:02:25,000\nAnd \"Alan Turing\" dot find \"n\" starting at 4.\n\n37\n00:02:25,000 --> 00:02:29,000\nI'd like you to fill in each blank with the answer we would get from the Python interpreter.\n\n38\n00:02:29,000 --> 00:02:33,000\nYou can use Python if you'd like to get a better feel for how this is going to turn out,\n\n39\n00:02:33,000 --> 00:02:35,000\nbut you can also just try to solve it on your own \n\n40\n00:02:35,000 --> 00:02:38,000\nby thinking hard about the structure of the problem.\n\n", "id": 6001}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjZNgw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/7001", "type": "Nugget", "id": 7001}, {"nuggetType": "lecture", "name": "Fsm Evolution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "f075a0c5-8d43-4dd1-b41d-094e5b6ca779", "name": "cs262_unit1_12_qs_fsm-evolution", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGNqzAQw", "youtube_id": "AH-ZkvSTFv0", "youtube_state": "done", "path": "Course/cs262/Media/23002", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nNow that we know the basics of finite state machines,\n\n2\n00:00:02,000 --> 00:00:03,000\nlet's change them up.\n\n3\n00:00:03,000 --> 00:00:06,000\nSuppose I have this finite state machine from before.\n\n4\n00:00:06,000 --> 00:00:09,000\nIt matches a - z, followed by 0 - 9.\n\n5\n00:00:09,000 --> 00:00:17,000\nI want to change it into a new finite state machine that's going to accept [a - z] + [0 - 9].\n\n6\n00:00:17,000 --> 00:00:22,000\nThat is, 1 or more copies of a - z and then exactly 1 copy of 0 - 9.\n\n7\n00:00:22,000 --> 00:00:26,000\nWe're going to be able to do it by adding just 1 edge.\n\n8\n00:00:26,000 --> 00:00:28,000\nMy questions for you--fill in the blanks--\n\n9\n00:00:28,000 --> 00:00:31,000\nwhich state should get the edge by state number,\n\n10\n00:00:31,000 --> 00:00:34,000\nand what's the label for that edge going to be?\n\n", "id": 23002}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjcNgw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/7004", "type": "Nugget", "id": 7004}, {"nuggetType": "lecture", "name": "Breaking Up Strings Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "d9733bdd-22fc-4393-829b-f0d51ac49ffc", "name": "cs262_unit1_01_s_breaking-up-strings", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGME-DA", "youtube_id": "5R2T40i7X1I", "youtube_state": "done", "path": "Course/cs262/Media/8001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nLet's go through the answers together.\n\n2\n00:00:02,000 --> 00:00:06,000\nWe're looking for a space in \"Ada Lovelace\", and there is a space right here.\n\n3\n00:00:06,000 --> 00:00:11,000\nThis \"a\" is at position 0, \"d\" is at position 1, \"a\" is at position 2.\n\n4\n00:00:11,000 --> 00:00:13,000\nSo this space is at position 3.\n\n5\n00:00:13,000 --> 00:00:16,000\nNow we're looking for an \"n\" in \"Alan Turing\", and there are two.\n\n6\n00:00:16,000 --> 00:00:22,000\nThe first one is at position 3, but here we're asked to start from position 4,\n\n7\n00:00:22,000 --> 00:00:26,000\nso the one we'll get is this last \"n\" at position 9.\n\n8\n00:00:26,000 --> 00:00:29,000\nAda Lovelace is widely regarded as the first computer programmer.\n\n9\n00:00:29,000 --> 00:00:33,000\nIn fact, she wrote the first computer program for computing some mathematics\n\n10\n00:00:33,000 --> 00:00:36,000\nbefore computers themselves even really existed.\n\n11\n00:00:36,000 --> 00:00:38,000\nThey were just plans or blueprints.\n\n12\n00:00:38,000 --> 00:00:43,000\nSimilarly, Alan Turing is often regarded as one of the leaders or founders of computer science.\n\n13\n00:00:43,000 --> 00:00:47,000\nThe Nobel Prize in computer science is called the Turing Award.\n\n", "id": 8001}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjCPgw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/8002", "type": "Nugget", "id": 8002}, {"nuggetType": "lecture", "name": "Disjunction Construction", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "02e07603-1238-4718-8bc8-f46dcddc0ae2", "name": "cs262_unit1_15_p_disjunction-construction", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGMQ-DA", "youtube_id": "5PG8h4Mm-MI", "youtube_state": "done", "path": "Course/cs262/Media/8004", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nNow let's turn the tables a bit and attack the problem from the other direction.\n\n2\n00:00:04,000 --> 00:00:08,000\nThis time, I'd like you to use the interpreter, and you're going to create \n\n3\n00:00:08,000 --> 00:00:10,000\nyour own regular expression.\n\n4\n00:00:10,000 --> 00:00:14,000\nAssign to the variable regexp, a common abbreviation for regular expression,\n\n5\n00:00:14,000 --> 00:00:20,000\na regular expression that matches either the exact string ab--2 letters in ab--\n\n6\n00:00:20,000 --> 00:00:27,000\nor 1 or more digits. To help clarify this specification, I have 3 positive instances--\n\n7\n00:00:27,000 --> 00:00:31,000\nyou should match ab, 1, and 123--\n\n8\n00:00:31,000 --> 00:00:38,000\nand 3 negative instances--don't match a alone, don't match abc, and don't match abc 123.\n\n", "id": 8004}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjFPgw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/8005", "type": "Nugget", "id": 8005}, {"nuggetType": "lecture", "name": "Escaping The Escape", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "bfb6e95e-5264-4eed-b120-3851ca00f87b", "name": "cs262_unit1_22_p_escaping-the-escape", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGPSrAQw", "youtube_id": "Yz9JBwhlndk", "youtube_state": "done", "path": "Course/cs262/Media/22004", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:03,000\nLet's put our hard one knowledge of these new regular expressions \n\n2\n00:00:03,000 --> 00:00:08,000\nlike any character except new line or set compliment of what we've been talking about\n\n3\n00:00:08,000 --> 00:00:10,000\nto the test.\n\n4\n00:00:10,000 --> 00:00:14,000\nI'd like you to submit via the interpreter, assign to the variable regexp,\n\n5\n00:00:14,000 --> 00:00:20,000\na Python regular expression that matches double-quoted string literals \n\n6\n00:00:20,000 --> 00:00:25,000\nand--this is the sticker--allows for escaped double quotes.\n\n7\n00:00:25,000 --> 00:00:27,000\nLet me just jump over to the interpreter briefly to show you what I'm talking about,\n\n8\n00:00:27,000 --> 00:00:29,000\nand then we'll come back here.\n\n9\n00:00:29,000 --> 00:00:33,000\nIt turns out that there is 1 of those gritty details in this problem that makes life fun,\n\n10\n00:00:33,000 --> 00:00:35,000\nbut also complicated the first time.\n\n11\n00:00:35,000 --> 00:00:39,000\nThe sorts of strings that I want you to accept are like this one down here.\n\n12\n00:00:39,000 --> 00:00:46,000\n\"You say, and then there's a \\yes\\, I say, no.\n\n13\n00:00:46,000 --> 00:00:50,000\nWe've got \\no\\ and then it ends.\n\n14\n00:00:50,000 --> 00:00:55,000\nThis is a well-formed, well-balanced string literal with double quotes \n\n15\n00:00:55,000 --> 00:00:56,000\nand some escaped double quotes.\n\n16\n00:00:56,000 --> 00:01:02,000\nHowever, to get it to Python, remember that Python is going to treat the escaped sequences,\n\n17\n00:01:02,000 --> 00:01:05,000\nmeaning no literally the next thing.\n\n18\n00:01:05,000 --> 00:01:08,000\nBut what if you want to literally have a backslash?\n\n19\n00:01:08,000 --> 00:01:11,000\nThen you need to escape the escape sequence.\n\n20\n00:01:11,000 --> 00:01:13,000\nIt is turtles all the way down, my friends.\n\n21\n00:01:13,000 --> 00:01:16,000\nSo if you want to do some testing on your procedure,\n\n22\n00:01:16,000 --> 00:01:20,000\nhere this string 1, this is what you'd have to enter into Python\n\n23\n00:01:20,000 --> 00:01:24,000\nin order to get it to be the sort of string we're looking for.\n\n24\n00:01:24,000 --> 00:01:29,000\nHere I started with single quotes, and then I've double escaped this backslash,\n\n25\n00:01:29,000 --> 00:01:31,000\nthen the double quotes, double escape again.\n\n26\n00:01:31,000 --> 00:01:35,000\nHere I've added 2 more, just to make this extra clear.\n\n27\n00:01:35,000 --> 00:01:40,000\nAll 3 of these are positive examples--whoops! I'm so wrong!\n\n28\n00:01:40,000 --> 00:01:44,000\n I have forgotten the closing double quote at the end of '\"I say, \\\\\"hello.\\\\\"'.\n\n29\n00:01:44,000 --> 00:01:47,000\nThis is a negative example.\n\n30\n00:01:47,000 --> 00:01:51,000\nLet's go fix it. There we go. Add in another quote.\n\n31\n00:01:51,000 --> 00:01:55,000\nNow all 3 of these are positive examples of the sorts of strings you'd want to match.\n\n32\n00:01:55,000 --> 00:01:58,000\nYou say, yes. I say, no.\n\n33\n00:01:58,000 --> 00:02:00,000\nI do realize that there should be a quote here, \n\n34\n00:02:00,000 --> 00:02:03,000\nbut I've intentionally left out the apostrophe in don't,\n\n35\n00:02:03,000 --> 00:02:07,000\nso as not to confuse the issue since we're already talking about quoted strings.\n\n36\n00:02:07,000 --> 00:02:11,000\nSo here just to remind you, I've written out a positive example and a negative example.\n\n37\n00:02:11,000 --> 00:02:15,000\nOn the left is what you'd have to say to Python and on the right is what it means.\n\n38\n00:02:15,000 --> 00:02:19,000\nAnd the big hints are that you'll probably want to escape the double quotes and the backslash,\n\n39\n00:02:19,000 --> 00:02:21,000\njust like we did here.\n\n40\n00:02:21,000 --> 00:02:26,000\nYou may want to consider having parenthesis nested inside other parenthesis.\n\n41\n00:02:26,000 --> 00:02:28,000\nThis one's tricky. Good luck!\n\n", "id": 22004}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjHPgw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/8007", "type": "Nugget", "id": 8007}, {"nuggetType": "lecture", "name": "Selecting Substrings", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "ac06f34d-df0c-4635-a3fe-112fbff7db0d", "name": "cs262_unit1_02_p_selecting-substrings", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGKlGDA", "youtube_id": "rX6OGi3izK8", "youtube_state": "done", "path": "Course/cs262/Media/9001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:05,000\nNow we know how to find positions, sometimes called \"indices,\" in strings.\n\n2\n00:00:05,000 --> 00:00:10,000\nWhat we want to do is chop up those strings into substrings.\n\n3\n00:00:10,000 --> 00:00:13,000\nOnce I know where the spaces are, I can start splitting a sentence into words.\n\n4\n00:00:13,000 --> 00:00:17,000\nThe Python syntax for this is to put square brackets after the string,\n\n5\n00:00:17,000 --> 00:00:23,000\nand the interpretation is \"I want to get this substring that starts at this first number\n\n6\n00:00:23,000 --> 00:00:27,000\nand goes up to, but not including, this last number.\n\n7\n00:00:27,000 --> 00:00:32,000\nHere if I'm starting at 1 and going up to but not including 2, I'll get the \"e\" and the \"l\",\n\n8\n00:00:32,000 --> 00:00:34,000\nand that's exactly what we'd get in Python.\n\n9\n00:00:34,000 --> 00:00:38,000\nYou can also leave out one of these numbers specifiers.\n\n10\n00:00:38,000 --> 00:00:42,000\nLeaving it blank means go as far as possible in that direction.\n\n11\n00:00:42,000 --> 00:00:47,000\nHere we're starting at position 1 and going all the way to the right so we get \"ello.\"\n\n12\n00:00:47,000 --> 00:00:50,000\nNow that we know how to find strings and how to chomp them up,\n\n13\n00:00:50,000 --> 00:00:54,000\nlet's combine that together and write a Python procedure.\n\n14\n00:00:54,000 --> 00:00:56,000\nLet's say that you're given two strings, \n\n15\n00:00:56,000 --> 00:01:01,000\neach of which itself contains two words separated by a space.\n\n16\n00:01:01,000 --> 00:01:07,000\nThese strings might be bell space hooks, grace space hopper, or alonzo space church.\n\n17\n00:01:07,000 --> 00:01:13,000\nI'd like you to write a Python procedure called myfirst_yoursecond that takes two arguments,\n\n18\n00:01:13,000 --> 00:01:20,000\np and q, and returns true if the first word in p equals the second word in q.\n\n19\n00:01:20,000 --> 00:01:26,000\nFor examples, myfirst_yoursecond of \"bell hooks\" and \"curer bell\" would return True,\n\n20\n00:01:26,000 --> 00:01:30,000\nbecause the first word here matches up with the second word there.\n\n21\n00:01:30,000 --> 00:01:33,000\nSubmit it via the interpreter.\n\n", "id": 9001}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiRTgw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/10001", "type": "Nugget", "id": 10001}, {"nuggetType": "lecture", "name": "One Or More", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "f17db195-19bc-4616-b95a-a34b360364e7", "name": "cs262_unit1_09_q_one-or-more", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGNmzAQw", "youtube_id": "-ooaJAZwtrk", "youtube_state": "done", "path": "Course/cs262/Media/23001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nIt's time to introduce a new regular expression--plus.\n\n2\n00:00:04,000 --> 00:00:09,000\nThis is really handy when we want to match one or more of something.\n\n3\n00:00:09,000 --> 00:00:12,000\nThis is a very concise way of listing, actually, an infinite number of possibilities.\n\n4\n00:00:12,000 --> 00:00:20,000\nIf I write the regular expression \"a\" followed by a plus, it matches \"a,\" \"aa,\" \"aaa,\" \"aaaa.\"\n\n5\n00:00:20,000 --> 00:00:26,000\nThe plus looks back to the previous regular expression and changes the meaning.\n\n6\n00:00:26,000 --> 00:00:33,000\nInstead of just matching that once, you match it once or more--as many times as you'd like.\n\n7\n00:00:33,000 --> 00:00:40,000\nHere I've shown another example. We're looking for 0 through 1 repeated one or more times.\n\n8\n00:00:40,000 --> 00:00:44,000\nThe interpretation here is every time you repeat you can make a different choice.\n\n9\n00:00:44,000 --> 00:00:51,000\nThis matches \"0\" and \"1,\" \"00\" and \"11,\" but also \"01.\" \n\n10\n00:00:51,000 --> 00:00:54,000\nThis required us to pick a 0 the first time and a 1 the second time.\n\n11\n00:00:54,000 --> 00:00:56,000\nThat's totally fine with the plus.\n\n12\n00:00:56,000 --> 00:00:58,000\n\"1010\" is a favorite year of mine.\n\n13\n00:00:58,000 --> 00:01:01,000\nIt's about when Murasaksi Shikibu wrote The Tale of Genji.\n\n14\n00:01:01,000 --> 00:01:06,000\nShe is often credited with writing the first novel--the first psychological novel,\n\n15\n00:01:06,000 --> 00:01:08,000\nalthough this is the subject of some dispute.\n\n16\n00:01:08,000 --> 00:01:12,000\nThere is a minor bit of ambiguity I need to clear up with this plus.\n\n17\n00:01:12,000 --> 00:01:18,000\nLet's say that we're looking for numbers 0 through 9 plus in the string \"13 from 1 in 1776.\"\n\n18\n00:01:18,000 --> 00:01:22,000\nOne possible answer is 13, 1, and 1776,\n\n19\n00:01:22,000 --> 00:01:24,000\nbut this plus just means 1 or more.\n\n20\n00:01:24,000 --> 00:01:27,000\nIs there anything that says that I have to match them all at the same time\n\n21\n00:01:27,000 --> 00:01:33,000\nor could I break up 1776 into four different one-letter strings.\n\n22\n00:01:33,000 --> 00:01:37,000\nIt turns out that there is a rule in regular expressions called \"maximal munch,\"\n\n23\n00:01:37,000 --> 00:01:40,000\nwhich says that a regular expression should consume, or eat, or match\n\n24\n00:01:40,000 --> 00:01:44,000\nthe biggest string it can and not smaller parts.\n\n25\n00:01:44,000 --> 00:01:48,000\nSo we and Python and other people studying regular expressions are going to get this answer:\n\n26\n00:01:48,000 --> 00:01:56,000\n13, 1, 1776, because 1776 is the maximal munch we can get here for 0 through 9 plus.\n\n27\n00:01:56,000 --> 00:01:59,000\nDon't stop early. Go all the way.\n\n28\n00:01:59,000 --> 00:02:03,000\nAll right. Let's get a little more practice with compound regular expression matching,\n\n29\n00:02:03,000 --> 00:02:05,000\nincluding the plus.\n\n30\n00:02:05,000 --> 00:02:10,000\nDown here I've written a regular expression dot findall expression in Python\n\n31\n00:02:10,000 --> 00:02:12,000\nand a bunch of possible answers.\n\n32\n00:02:12,000 --> 00:02:18,000\nI'd like you to check the ones that could be elements of the return value of this Python expression.\n\n33\n00:02:18,000 --> 00:02:23,000\nWe're looking for 0 through 9 followed by--oh, what does this mean?\n\n34\n00:02:23,000 --> 00:02:25,000\nI haven't shown this to you yet.\n\n35\n00:02:25,000 --> 00:02:27,000\nWe just have open brackets, a space, and a closed bracket.\n\n36\n00:02:27,000 --> 00:02:30,000\nThat means just match space.\n\n37\n00:02:30,000 --> 00:02:34,000\nThen finally 0 through 9 plus.\n\n38\n00:02:34,000 --> 00:02:37,000\nRemember the plus only applies to this last 0 through 9.\n\n39\n00:02:37,000 --> 00:02:41,000\nWe're looking for all of these in that torture string I made up earlier.\n\n40\n00:02:41,000 --> 00:02:44,000\nLet's try it out.\n\n", "id": 23001}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiSTgw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/10002", "type": "Nugget", "id": 10002}, {"nuggetType": "lecture", "name": "Nondet To Det", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "48f95ef6-65c8-4e91-9943-6272e54682a2", "name": "cs262_unit1_32_q_nondet-to-det", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGN02DA", "youtube_id": "KNxbmhyvSVQ", "youtube_state": "done", "path": "Course/cs262/Media/7005", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nLet's do one more bit of practice\n\n2\n00:00:02,000 --> 00:00:06,000\nconverting non-deterministic machines to deterministic ones.\n\n3\n00:00:06,000 --> 00:00:09,000\nHere I've written a non-deterministic machine.\n\n4\n00:00:09,000 --> 00:00:11,000\nIt has ambiguity.\n\n5\n00:00:11,000 --> 00:00:14,000\nRight in state 1 there are 2 ways to go on a.\n\n6\n00:00:14,000 --> 00:00:16,000\nIt also has epsilon transitions,\n\n7\n00:00:16,000 --> 00:00:20,000\nand I'll start making its deterministic equivalent down here.\n\n8\n00:00:20,000 --> 00:00:23,000\nWell, when we enter the non-deterministic machine,\n\n9\n00:00:23,000 --> 00:00:27,000\nwe could only be in state 1, but after that we could see an a,\n\n10\n00:00:27,000 --> 00:00:31,000\nand if I see an a I could be in 2, 4, \n\n11\n00:00:31,000 --> 00:00:34,000\nor I could take the free epsilon transition to 5,\n\n12\n00:00:34,000 --> 00:00:38,000\nor I could keep going and take the free epsilon transition to 6.\n\n13\n00:00:38,000 --> 00:00:40,000\nI'll label my new state 2456 \n\n14\n00:00:40,000 --> 00:00:42,000\nbecause it keeps track of everywhere that I could have my fingers\n\n15\n00:00:42,000 --> 00:00:45,000\nif I'm simulating this non-deterministic machine.\n\n16\n00:00:45,000 --> 00:00:48,000\nNow, should this state be an accepting state or not?\n\n17\n00:00:48,000 --> 00:00:52,000\nWell, remember that a finite state machine accepts if there's any path\n\n18\n00:00:52,000 --> 00:00:56,000\nto an accepting state, and 6 is one of our accepting states.\n\n19\n00:00:56,000 --> 00:00:59,000\nBecause the original machine could accept a, \n\n20\n00:00:59,000 --> 00:01:03,000\na, epsilon, epsilon, win,  we want our new machine to also accept a.\n\n21\n00:01:03,000 --> 00:01:05,000\nA, win.\n\n22\n00:01:05,000 --> 00:01:10,000\nIn my converted world, the state accepts if any of its corresponding \n\n23\n00:01:10,000 --> 00:01:13,000\noriginal states also accept.\n\n24\n00:01:13,000 --> 00:01:17,000\nLet's say that I'm in either 2, 4, 5, or 6 and I see a c.\n\n25\n00:01:17,000 --> 00:01:20,000\nIf I'm in 2 and I see a c, I fall off the world.\n\n26\n00:01:20,000 --> 00:01:22,000\nIf I'm in 4, fall off the world.\n\n27\n00:01:22,000 --> 00:01:24,000\n5, I go to 6, looking good.\n\n28\n00:01:24,000 --> 00:01:27,000\n6, fall off the world.\n\n29\n00:01:27,000 --> 00:01:31,000\nHere if I was in 2, 4, 5, or 6 and I see a c,\n\n30\n00:01:31,000 --> 00:01:36,000\nI end up just in state 6, and that's definitely an accepting state.\n\n31\n00:01:36,000 --> 00:01:39,000\nNow, there's some other ways to get out of 2, 4, 5, and 6,\n\n32\n00:01:39,000 --> 00:01:42,000\nand when we do, we might be in states 2 or 3.\n\n33\n00:01:42,000 --> 00:01:45,000\nSince 3 is an accepting state up there, \n\n34\n00:01:45,000 --> 00:01:48,000\n2 or 3 is an accepting state down here.\n\n35\n00:01:48,000 --> 00:01:52,000\nIf I'm in 2 or 3, on a b from 2 I go to 3,\n\n36\n00:01:52,000 --> 00:01:57,000\nand c I'd fall off the world, so we'd end up in state 3.\n\n37\n00:01:57,000 --> 00:01:59,000\nIf I'm in 2 or 3 and I see a c,\n\n38\n00:01:59,000 --> 00:02:02,000\nI must really have been in state 3, and I stay in state 3,\n\n39\n00:02:02,000 --> 00:02:07,000\nso either on b or c we end up in just state 3,\n\n40\n00:02:07,000 --> 00:02:09,000\nwhich is also an accepting state.\n\n41\n00:02:09,000 --> 00:02:13,000\nAnd if I'm in state 3, there's a self-loop back to state 3.\n\n42\n00:02:13,000 --> 00:02:17,000\nNow, I've filled out almost all of this deterministic equivalent.\n\n43\n00:02:17,000 --> 00:02:20,000\nBut I forgot to label an edge.\n\n44\n00:02:20,000 --> 00:02:22,000\nHelp me out.\n\n45\n00:02:22,000 --> 00:02:24,000\nAs the quiz, what should the label for this edge be\n\n46\n00:02:24,000 --> 00:02:28,000\nso that this deterministic equivalent and this non-deterministic machine\n\n47\n00:02:28,000 --> 00:02:30,000\naccept exactly the same language?\n\n", "id": 7005}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiTTgw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/10003", "type": "Nugget", "id": 10003}, {"nuggetType": "lecture", "name": "More FSM Encoding", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "None", "name": "26_s_more-fsm-encoding.mp4", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": "rejected: Duplicate video", "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGMOsBgw", "youtube_id": "pPN-g2-9KGY", "youtube_state": "failed", "path": "Course/cs262/Media/104003", "transcript": null, "id": 104003}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiUTgw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/10004", "type": "Nugget", "id": 10004}, {"nuggetType": "lecture", "name": "Import Re", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "5a8a7f93-b4b1-4611-836a-8d25e044a388", "name": "cs262_unit1_06_l_import-re", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGNs2DA", "youtube_id": "TIYW7LafkeM", "youtube_state": "done", "path": "Course/cs262/Media/7003", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nIndustrial software is often so big that it doesn't all fit on one page,\n\n2\n00:00:04,000 --> 00:00:08,000\nso people have to break it up into chunks just like a book is broken up into chapters\n\n3\n00:00:08,000 --> 00:00:12,000\nor the body of human knowledge is broken up into many books.\n\n4\n00:00:12,000 --> 00:00:17,000\nIn computer science, a module is a repository or a library of code--\n\n5\n00:00:17,000 --> 00:00:19,000\nfunctions and data that do useful things.\n\n6\n00:00:19,000 --> 00:00:22,000\nIn Python, import brings in a module.\n\n7\n00:00:22,000 --> 00:00:25,000\nIt turns out that there is already a bunch of functions\n\n8\n00:00:25,000 --> 00:00:29,000\nrelated to regular expressions. We won't have to reinvent the wheel.\n\n9\n00:00:29,000 --> 00:00:35,000\nWe can just import them into our own Python programs and get their benefits for free.\n\n10\n00:00:35,000 --> 00:00:41,000\nPython's regular expression module is called, imaginatively enough, \"re\"--regular expressions.\n\n11\n00:00:41,000 --> 00:00:45,000\nAt the beginning of a Python program, just write \"import space re\"\n\n12\n00:00:45,000 --> 00:00:48,000\nand then you'll have access to all of the regular expression functions.\n\n13\n00:00:48,000 --> 00:00:50,000\nI'm going to show them to you in just a minute.\n\n14\n00:00:50,000 --> 00:00:54,000\nIf we're going to write down regular expressions in Python, we need to know what they look like.\n\n15\n00:00:54,000 --> 00:00:57,000\nPython regular expressions look just like strings.\n\n16\n00:00:57,000 --> 00:01:01,000\nThey start with double quotes or single quotes, and they have contents,\n\n17\n00:01:01,000 --> 00:01:05,000\nexcept that to separate regular expressions from strings \n\n18\n00:01:05,000 --> 00:01:10,000\nregular expressions begin with a lowercase \"r\" outside of the double quotes.\n\n19\n00:01:10,000 --> 00:01:16,000\nUp here this is a--zero, one, two, three, four--a five-character string 0 through 9.\n\n20\n00:01:16,000 --> 00:01:19,000\nThis one down here that begins with an \"r\" is a regular expression\n\n21\n00:01:19,000 --> 00:01:23,000\nthat matches 10 different one-letter strings.\n\n22\n00:01:23,000 --> 00:01:26,000\nWriting regular expressions is a creative process.\n\n23\n00:01:26,000 --> 00:01:28,000\nYou the programmer have to do it.\n\n24\n00:01:28,000 --> 00:01:32,000\nI'm using \"creative\" here in the same way that people often describe mathematics as elegant.\n\n25\n00:01:32,000 --> 00:01:36,000\nJust as there are many different equations that could get you the number 4--\n\n26\n00:01:36,000 --> 00:01:41,000\n2 plus 2, 1 plus 3, 8 divided by 2, absolute value of the square root of 16--\n\n27\n00:01:41,000 --> 00:01:45,000\nin fact, and infinite number--there are often an infinite number of regular expressions \n\n28\n00:01:45,000 --> 00:01:47,000\nthat could serve a purpose.\n\n29\n00:01:47,000 --> 00:01:50,000\nPicking the right one, the small one, the simple one, the concise one, the elegant one,\n\n30\n00:01:50,000 --> 00:01:54,000\nrequires creativity. It's a skill. It's something you'll learn in this class.\n\n31\n00:01:54,000 --> 00:01:57,000\nLet's say you've written a regular expression, though--like this one.\n\n32\n00:01:57,000 --> 00:01:59,000\nNow we need to use it.\n\n33\n00:01:59,000 --> 00:02:03,000\nOne of the most common functions involving regular expressions is findall.\n\n34\n00:02:03,000 --> 00:02:10,000\nIt takes a regular expression and a string and returns a list of all of the substrings\n\n35\n00:02:10,000 --> 00:02:12,000\nthat match that regular expression.\n\n36\n00:02:12,000 --> 00:02:17,000\nHere if we're looking for single letter strings that are between 0 and 9,\n\n37\n00:02:17,000 --> 00:02:21,000\nthe 1 matches, the plus does not, the 2 matches, the equals does not, \n\n38\n00:02:21,000 --> 00:02:24,000\nthe equals does not, and the 3 matches.\n\n39\n00:02:24,000 --> 00:02:27,000\nThe return value of re.findall \n\n40\n00:02:27,000 --> 00:02:32,000\nis a list--1, 2, 3--of all of the substrings that match the regular expression.\n\n41\n00:02:32,000 --> 00:02:34,000\nThe list could be empty if you didn't actually match anything.\n\n42\n00:02:34,000 --> 00:02:38,000\nThis \"re\" means it comes from the regular expression library.\n\n43\n00:02:38,000 --> 00:02:41,000\nWe really need that import statement at the beginning for this to work.\n\n44\n00:02:41,000 --> 00:02:45,000\nIn this example, I'm using the same haystack string--\"1+2==3\"--\n\n45\n00:02:45,000 --> 00:02:47,000\nbut I'm using a different regular expression.\n\n46\n00:02:47,000 --> 00:02:50,000\nThis one only matches two single-letter strings.\n\n47\n00:02:50,000 --> 00:02:56,000\nWe'll get out 1 and 2. These two match. The 3 does not, because it's not between 1 and 2.\n\n48\n00:02:56,000 --> 00:02:58,000\nIt's not specified or matched by this regular expression.\n\n49\n00:02:58,000 --> 00:03:01,000\nThis last example is a little more tricky.\n\n50\n00:03:01,000 --> 00:03:03,000\nWe're looking for the letters a through c,\n\n51\n00:03:03,000 --> 00:03:07,000\nbut if you look carefully, these are the lowercase letters a and c.\n\n52\n00:03:07,000 --> 00:03:11,000\nSo even though this \"B\" is very tempting--this capital \"B\" in \"Barbara,\"\n\n53\n00:03:11,000 --> 00:03:14,000\nit's not between lowercase a and lowercase c.\n\n54\n00:03:14,000 --> 00:03:20,000\nWe'll match this a, b, a, a, and then there's nothing over here in \"Liskov.\"\n\n55\n00:03:20,000 --> 00:03:24,000\nBarbara Liskov is a well-known computer scientist, famous for her word in \n\n56\n00:03:24,000 --> 00:03:27,000\nobject-oriented programming and systems programming.\n\n57\n00:03:27,000 --> 00:03:30,000\nAmong other things she invented the language Clu, \n\n58\n00:03:30,000 --> 00:03:33,000\nwhich I'm showing here with a bit of a magnifying lens.\n\n59\n00:03:33,000 --> 00:03:36,000\nShe received the Turing Award--the highest honor is computer science.\n\n", "id": 7003}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBj6VQw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/11002", "type": "Nugget", "id": 11002}, {"nuggetType": "lecture", "name": "Disjunction In Fsms", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "030ea23f-6f77-42aa-b059-0808cfd06aa8", "name": "cs262_unit1_14_q_disjunction-in-fsms", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGPtVDA", "youtube_id": "gfypOoc8sXE", "youtube_state": "done", "path": "Course/cs262/Media/11003", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nLet's test our knowledge of this notion of disjunction or choice or options\n\n2\n00:00:04,000 --> 00:00:06,000\nin finite state machines.\n\n3\n00:00:06,000 --> 00:00:09,000\nHere I've drawn a potentially familiar finite state machine,\n\n4\n00:00:09,000 --> 00:00:12,000\nand what I'd like you to do is check each box that corresponds to a string\n\n5\n00:00:12,000 --> 00:00:17,000\nthat is accepted by this finite state machine exactly and fully.\n\n6\n00:00:17,000 --> 00:00:21,000\nFSM stands for finite state machine. Try it out.\n\n", "id": 11003}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBj8VQw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/11004", "type": "Nugget", "id": 11004}, {"nuggetType": "lecture", "name": "Re Challenges", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "ea879b5c-c4bc-4f9c-babf-debb09bf573b", "name": "cs262_unit1_19_p_re-challenges", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGNyzAQw", "youtube_id": "kyS963wr0Vk", "youtube_state": "done", "path": "Course/cs262/Media/23004", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:03,000\nLet's try our hand at crafting another regular expression.\n\n2\n00:00:03,000 --> 00:00:05,000\nIt's a creative activity. It's fun stuff.\n\n3\n00:00:05,000 --> 00:00:07,000\nAnd this one is designed to be a bit tricky.\n\n4\n00:00:07,000 --> 00:00:11,000\nI'm going to ask you to write a regular expression that matches \n\n5\n00:00:11,000 --> 00:00:15,000\nsingle-argument mathematical functions.\n\n6\n00:00:15,000 --> 00:00:17,000\nLet me be more specific about that.\n\n7\n00:00:17,000 --> 00:00:22,000\nFirst, the function name is a lowercase word made up of 1 or more lowercase letters, [a - z].\n\n8\n00:00:22,000 --> 00:00:27,000\nThe function argument should be a number made up of 1 or more digits, [0 - 9].\n\n9\n00:00:27,000 --> 00:00:33,000\nAnd there may, optionally, be spaces before and/or after the argument.\n\n10\n00:00:33,000 --> 00:00:37,000\nSo here you've got a function name that's lowercase letters--cosign--c-o-s.\n\n11\n00:00:37,000 --> 00:00:42,000\nIt has parenthesis, and then it has a single argument that's a number.\n\n12\n00:00:42,000 --> 00:00:48,000\nHere we've got the same thing, but I've got these spaces before and after the argument.\n\n13\n00:00:48,000 --> 00:00:49,000\nThese 2 are not matched. \n\n14\n00:00:49,000 --> 00:00:53,000\nThis one has a space between the function name and the parenthesis.\n\n15\n00:00:53,000 --> 00:00:55,000\nFor this particular exercise, that's not allowed.\n\n16\n00:00:55,000 --> 00:00:58,000\nWe're only allowing spaces just before and just after the number.\n\n17\n00:00:58,000 --> 00:01:03,000\nThis one is square root of x, but we're looking for functions that have numeric arguments,\n\n18\n00:01:03,000 --> 00:01:04,000\nnot word arguments.\n\n19\n00:01:04,000 --> 00:01:09,000\nSubmit via the interpreter, a regular expression matching this specification.\n\n20\n00:01:09,000 --> 00:01:14,000\nAs a hint, you may find that you have to escape the opening and closing parenthesis\n\n21\n00:01:14,000 --> 00:01:16,000\nto make sure that they're treated correctly.\n\n", "id": 23004}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBj9VQw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/11005", "type": "Nugget", "id": 11005}, {"nuggetType": "lecture", "name": "Mozilla Field Trip", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "80ec0726-5c3a-4e9c-bb96-d3e958c4ab8a", "name": "cs262_unit1_38_l_mozilla-field-trip", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGMnWBQw", "youtube_id": "QpRyCcVInrM", "youtube_state": "done", "path": "Course/cs262/Media/93001", "transcript": "\ufeff", "id": 93001}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiEVgw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/11012", "type": "Nugget", "id": 11012}, {"nuggetType": "lecture", "name": "More FSM Encoding", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "None", "name": "26_p_more-fsm-encoding.mp4", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGIP3Agw", "youtube_id": "RFFZ4dS6jUQ", "youtube_state": "processing", "path": "Course/cs262/Media/48003", "transcript": null, "id": 48003}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiPVgw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/11023", "type": "Nugget", "id": 11023}, {"nuggetType": "lecture", "name": "Split", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "c9184377-50ac-432a-81f0-6d397d51acca", "name": "cs262_unit1_03_q_split", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGKIfDA", "youtube_id": "7vyYEQQKI0w", "youtube_state": "done", "path": "Course/cs262/Media/4002", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nSplitting up words by spaces is such a common task in computer science\n\n2\n00:00:04,000 --> 00:00:09,000\nthat Python has a built-in function, string.split(), that does just that.\n\n3\n00:00:09,000 --> 00:00:13,000\nFor example, suppose we take one of Charlotte Bronte's books as a string\n\n4\n00:00:13,000 --> 00:00:15,000\nand we call split on it.\n\n5\n00:00:15,000 --> 00:00:18,000\nWe'll get out a list where each element of the list corresponds \n\n6\n00:00:18,000 --> 00:00:22,000\nto one of the words in this string separated by spaces.\n\n7\n00:00:22,000 --> 00:00:27,000\nThis space here leads us directly to this comma, separating these list elements.\n\n8\n00:00:27,000 --> 00:00:30,000\nLet's take a moment now to get a little more practice with this new approach\n\n9\n00:00:30,000 --> 00:00:32,000\n to splitting by whitespace.\n\n10\n00:00:32,000 --> 00:00:38,000\nWhitespace is just a more formal name for some series of spaces or tabs.\n\n11\n00:00:38,000 --> 00:00:42,000\nHere I've written three Python expressions, each one of which is a constant string.\n\n12\n00:00:42,000 --> 00:00:44,000\nWe're calling split on it.\n\n13\n00:00:44,000 --> 00:00:49,000\nI'd like you to fill in each box with the number of elements in the list returned\n\n14\n00:00:49,000 --> 00:00:51,000\nby the split expression.\n\n15\n00:00:51,000 --> 00:00:55,000\nYou can use the interpreter if you like, but try to reason it out no your own.\n\n", "id": 4002}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjhXQw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/12001", "type": "Nugget", "id": 12001}, {"nuggetType": "lecture", "name": "Epsilon And Ambiguity", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "5274cd7a-1181-4c86-9fdd-1c6965e64f54", "name": "cs262_unit1_28_l_epsilon-and-ambiguity", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGJryAQw", "youtube_id": "-NrFWRVJy3Y", "youtube_state": "done", "path": "Course/cs262/Media/31002", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:03,000\nIt turns out that Python's regular expression module\n\n2\n00:00:03,000 --> 00:00:07,000\nactually uses something very similar to FSM sim under the hood.\n\n3\n00:00:07,000 --> 00:00:09,000\nYou  just take the regular expression, \n\n4\n00:00:09,000 --> 00:00:12,000\nturn it into a finite-state machine, which you've done forwards and backwards\n\n5\n00:00:12,000 --> 00:00:17,000\nmany times, and then check with a simple recursive procedure\n\n6\n00:00:17,000 --> 00:00:20,000\nto see if the finite-state machine accepts a string.\n\n7\n00:00:20,000 --> 00:00:25,000\nHowever, our simulation did not handle epsilon transitions or ambiguity,\n\n8\n00:00:25,000 --> 00:00:29,000\nand what I mean by ambiguity is what if there are 2 outgoing edges labeled a?\n\n9\n00:00:29,000 --> 00:00:32,000\nLet's say one of them leads to an accepting state, and one of them doesn't.\n\n10\n00:00:32,000 --> 00:00:34,000\nWhat should we do?\n\n11\n00:00:34,000 --> 00:00:36,000\nWell, there is a formal definition for this kind of ambiguity.\n\n12\n00:00:36,000 --> 00:00:38,000\nHowever, it's not going to solve our problems.\n\n13\n00:00:38,000 --> 00:00:41,000\nWe see that a finite-state machine accepts a string s\n\n14\n00:00:41,000 --> 00:00:46,000\nif there exists even one path from the start state\n\n15\n00:00:46,000 --> 00:00:49,000\nto any accepting state that follows s.\n\n16\n00:00:49,000 --> 00:00:52,000\nThis finite-state machine accepts a\n\n17\n00:00:52,000 --> 00:00:55,000\nbecause there's one way to do it where a causes you\n\n18\n00:00:55,000 --> 00:00:57,000\nto end up in an accepting state.\n\n19\n00:00:57,000 --> 00:01:00,000\nIf you like,  you can say that finite-state machines are generous.\n\n20\n00:01:00,000 --> 00:01:03,000\nIf there's any way to accept, we will make that work.\n\n21\n00:01:03,000 --> 00:01:06,000\nHowever, our finite-state machine simulation\n\n22\n00:01:06,000 --> 00:01:08,000\ndidn't code that up, so we're going to have to return \n\n23\n00:01:08,000 --> 00:01:10,000\nto both of these issues.\n\n", "id": 31002}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjjXQw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/12003", "type": "Nugget", "id": 12003}, {"nuggetType": "lecture", "name": "Findall Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "a450ad98-f4e5-4e51-8103-c038d1b7a88f", "name": "cs262_unit1_07_s_findall", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGKGcAQw", "youtube_id": "GI4EiWBbtqg", "youtube_state": "done", "path": "Course/cs262/Media/20001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:06,000\nWe're looking for single letter strings, 0 through 9, in Mir Taqi 1723--\n\n2\n00:00:06,000 --> 00:00:09,000\nnothing, nothing, yes, yes, yes, yes.\n\n3\n00:00:09,000 --> 00:00:14,000\nThis 1, 7, 2, and 3 are four separate one-letter strings.\n\n4\n00:00:14,000 --> 00:00:19,000\nOver here we're looking for capital letters A through Z in Mir Dard 1721.\n\n5\n00:00:19,000 --> 00:00:24,000\nThis capital M matches. These are lowercase, so they don't. Capital D does. M. D.\n\n6\n00:00:24,000 --> 00:00:31,000\nDown here we're looking for 0 through 9 in 11 minus 7 equals 4--1, 1, 7, 4.\n\n7\n00:00:31,000 --> 00:00:36,000\nMir Taqi and Mir Dard are often regarded as two of the four pillars of Urdu poetry.\n\n8\n00:00:36,000 --> 00:00:39,000\nCheck it out if you get the chance.\n\n", "id": 20001}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjKZQw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/13002", "type": "Nugget", "id": 13002}, {"nuggetType": "lecture", "name": "Escaping The Escape Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "3276b1e9-c20a-4cae-813a-314e7a5c7455", "name": "cs262_unit1_22_s_escaping-the-escape", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGLmRAgw", "youtube_id": "fYJ6BfXLxb0", "youtube_state": "done", "path": "Course/cs262/Media/35001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nLet's go through this one in parts.\n\n2\n00:00:02,000 --> 00:00:08,000\nAny regular expression starts with r' or r\".\n\n3\n00:00:08,000 --> 00:00:11,000\nI'm going to use the single quotes this time so that I won't have to escape\n\n4\n00:00:11,000 --> 00:00:12,000\nquite as many of these.\n\n5\n00:00:12,000 --> 00:00:16,000\nThen we want to match the blue \" here at the beginning,\n\n6\n00:00:16,000 --> 00:00:19,000\nand somewhere way at the end, we'll want to match the closing one,\n\n7\n00:00:19,000 --> 00:00:21,000\nand that will be the end of our regular expression.\n\n8\n00:00:21,000 --> 00:00:23,000\nSo now we just have to think of what goes in here in the middle,\n\n9\n00:00:23,000 --> 00:00:26,000\nand this may not be enough room. I  may have to erase it and write it again.\n\n10\n00:00:26,000 --> 00:00:30,000\nNow whatever it is, it's going to be 0 or more of something,\n\n11\n00:00:30,000 --> 00:00:35,000\nand as we're going across the string, there's sort of backslashes, \n\n12\n00:00:35,000 --> 00:00:40,000\nwhich are important, and everything else, which is not so important.\n\n13\n00:00:40,000 --> 00:00:43,000\nSo if there's any character that's not a backslash,\n\n14\n00:00:43,000 --> 00:00:45,000\nand here I'm escaping the backslash,\n\n15\n00:00:45,000 --> 00:00:48,000\nwe can just read right over it--that's no problem inside of our string--\n\n16\n00:00:48,000 --> 00:00:54,000\nor you could actually have an escape sequence, like this \\\".\n\n17\n00:00:54,000 --> 00:01:01,000\nThat looks like a literal backslash, followed by anything, and then it's done.\n\n18\n00:01:01,000 --> 00:01:03,000\nSo let me just diagram this a little more.\n\n19\n00:01:03,000 --> 00:01:09,000\nSay this opening quote is 1, that matches things like this opening quote in the string.\n\n20\n00:01:09,000 --> 00:01:12,000\nThen in here, we have anything that's not a backslash--that's 2.\n\n21\n00:01:12,000 --> 00:01:16,000\nThat's I-space-say-s-a-y-comma, \n\n22\n00:01:16,000 --> 00:01:18,000\nbut then eventually we do get to a backslash.\n\n23\n00:01:18,000 --> 00:01:23,000\nOver here, we have a 2-character sequence that's a backslash followed by a dot.\n\n24\n00:01:23,000 --> 00:01:27,000\nThese 2 characters--the backslash, followed by the quote--they are 3,\n\n25\n00:01:27,000 --> 00:01:31,000\nand then we're back to matching 2's--h, e, l, l, o, dot.\n\n26\n00:01:31,000 --> 00:01:36,000\nNow we have another backslash and a quote, so these 2 together will be another 3,\n\n27\n00:01:36,000 --> 00:01:39,000\nand then this part at the end is number 4.\n\n28\n00:01:39,000 --> 00:01:42,000\nSo I have 0 or more copies of my string body.\n\n29\n00:01:42,000 --> 00:01:47,000\nThe elements of my string body are either normal characters \n\n30\n00:01:47,000 --> 00:01:49,000\nor 2-character escape sequences.\n\n31\n00:01:49,000 --> 00:01:52,000\nAll of this looks like 3 characters. It's really just 2.\n\n32\n00:01:52,000 --> 00:01:55,000\nI have to escape the backslash.\n\n33\n00:01:55,000 --> 00:01:59,000\nAs a minor aside, after the Beatles and Sound of Music examples from above,\n\n34\n00:01:59,000 --> 00:02:02,000\nyou may not be surprised to know that a number of English songs \n\n35\n00:02:02,000 --> 00:02:12,000\nof enduring popularity--ABC 123, BINGO--seem to have a regular expression sort of feel.\n\n36\n00:02:12,000 --> 00:02:16,000\nRepetition is very common in songs, and you get the same thing out of it\n\n37\n00:02:16,000 --> 00:02:18,000\nthat you get out of a regular expression,\n\n38\n00:02:18,000 --> 00:02:22,000\na concise notation versus in choruses, but then when you expand it out,\n\n39\n00:02:22,000 --> 00:02:24,000\nit takes a long time to sing.\n\n40\n00:02:24,000 --> 00:02:29,000\nHowever, there is 1 song that is actually too complicated for regular expressions--\n\n41\n00:02:29,000 --> 00:02:32,000\nthe dreaded 99 Bottles of Beer on the Wall.\n\n42\n00:02:32,000 --> 00:02:34,000\nIf you actually want the counting to work out correctly--\n\n43\n00:02:34,000 --> 00:02:39,000\n99 to 98 to 97--we can't fit it in a regular expression framework.\n\n44\n00:02:39,000 --> 00:02:44,000\nWe'll have to return to that later, and eventually we'll be smart enough to sing this song.\n\n45\n00:02:44,000 --> 00:02:48,000\nFor more info on this, Don Knuth, the computer scientist has written an essay\n\n46\n00:02:48,000 --> 00:02:49,000\non the complexity of songs.\n\n", "id": 35001}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjNZQw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/13005", "type": "Nugget", "id": 13005}, {"nuggetType": "lecture", "name": "Regular Expressions", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "2692f937-8732-490e-b1f5-7b562f4bb60a", "name": "cs262_unit1_04_l_regular-expressions", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGJl1DA", "youtube_id": "tWzBTc3K4o0", "youtube_state": "done", "path": "Course/cs262/Media/15001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:06,000\nThose last two examples--\"July-August 1842\" and \"6*9==42\"-- suggest that we need more \n\n2\n00:00:06,000 --> 00:00:10,000\ncontrol over splitting strings, because we might want to split on things other than spaces,\n\n3\n00:00:10,000 --> 00:00:12,000\nlike hyphens or punctuation.\n\n4\n00:00:12,000 --> 00:00:20,000\nI'm going to introduce a tool that will help us do just that--a tool called \"regular expressions.\"\n\n5\n00:00:20,000 --> 00:00:23,000\nSuppose we want to find all the numbers in a string.\n\n6\n00:00:23,000 --> 00:00:30,000\nWe could make 10 different calls to string.find, look for 1, look for 2, look for 3.\n\n7\n00:00:30,000 --> 00:00:33,000\nWe don't know what digit the number begins with, so we might have to try all of these,\n\n8\n00:00:33,000 --> 00:00:36,000\nbut that could get really tedious really fast.\n\n9\n00:00:36,000 --> 00:00:39,000\nInstead we're going to use this new technique \n\n10\n00:00:39,000 --> 00:00:42,000\nthat I'm just about to teach you--regular expressions.\n\n11\n00:00:42,000 --> 00:00:46,000\nThe word regular has special meaning in mathematics and computer science theory,\n\n12\n00:00:46,000 --> 00:00:52,000\nbut for now it just means simple strings, and expression is just a concise notation.\n\n13\n00:00:52,000 --> 00:00:56,000\nYou may have already seen this in some math classes, but not thought about it in this manner.\n\n14\n00:00:56,000 --> 00:01:00,000\nIf I write a mathematical expression, like x is equal to the square root of 4 \n\n15\n00:01:00,000 --> 00:01:06,000\nor 5 is less than x is less than 9, each one of these admits or corresponds\n\n16\n00:01:06,000 --> 00:01:09,000\nto some possible values for x.\n\n17\n00:01:09,000 --> 00:01:14,000\nFor example, if x is between 5 and 9 then it could be 6 or 7 or 8.\n\n18\n00:01:14,000 --> 00:01:17,000\nAll of those are good. All of those satisfy this mathematical equation.\n\n19\n00:01:17,000 --> 00:01:20,000\nAll of these match this mathematical equation.\n\n20\n00:01:20,000 --> 00:01:23,000\nSimilarly, we often think of the square root of 4 as being just 2, \n\n21\n00:01:23,000 --> 00:01:27,000\nbut actually negative 2 works just as well--              -2 times -2 is 4.\n\n22\n00:01:27,000 --> 00:01:33,000\nThese mathematical equations are concise notations for a possibly large set of values,\n\n23\n00:01:33,000 --> 00:01:35,000\nespecially if I do something like this.\n\n24\n00:01:35,000 --> 00:01:39,000\nThere are a large number of possibilities--51, 51, all the way up to 89--\n\n25\n00:01:39,000 --> 00:01:42,000\nand just writing this out took much less room.\n\n26\n00:01:42,000 --> 00:01:47,000\nJust as mathematical expressions are very concise and let us match or describe \n\n27\n00:01:47,000 --> 00:01:50,000\na large number of integers or numbers, \n\n28\n00:01:50,000 --> 00:01:53,000\nregular expressions are going to be very concise and let us\n\n29\n00:01:53,000 --> 00:01:56,000\ndescribe a large number of simple strings.\n\n30\n00:01:56,000 --> 00:01:59,000\nHere is our first regular expression.\n\n31\n00:01:59,000 --> 00:02:03,000\nBracket 1 hypen 3 closed bracket.\n\n32\n00:02:03,000 --> 00:02:07,000\nThis is associated with the three strings 1, 2, and 3.\n\n33\n00:02:07,000 --> 00:02:13,000\nFormally we say that a regular expression like this matches or denotes all of these three strings.\n\n34\n00:02:13,000 --> 00:02:19,000\nThe basic idea here is there is some symbol on the left and some symbol on the right,\n\n35\n00:02:19,000 --> 00:02:24,000\nand this regular expression matches each one of those plus everything in between.\n\n36\n00:02:24,000 --> 00:02:29,000\nFor example, the regular expression 4 hyphen 8 matches 4, 5, 6, 7, 8,\n\n37\n00:02:29,000 --> 00:02:35,000\nand the regular expression A through B matches the string a and the string b.\n\n38\n00:02:35,000 --> 00:02:41,000\nPerhaps surprisingly, regular expressions are very popular and very useful online\n\n39\n00:02:41,000 --> 00:02:43,000\nand in computing in general.\n\n40\n00:02:43,000 --> 00:02:47,000\nCredit cards, phone numbers, addresses, e-mail addresses--\n\n41\n00:02:47,000 --> 00:02:50,000\nthese are all handled by regular expressions on websites \n\n42\n00:02:50,000 --> 00:02:54,000\nyou've probably all ready used under the hood. Let me show you a compelling example.\n\n43\n00:02:54,000 --> 00:02:58,000\nHere I have the form from the U.S. State Department for applying for a U.S. passport.\n\n44\n00:02:58,000 --> 00:03:04,000\nRegular expressions are very common when you want to enter structured data or structured strings.\n\n45\n00:03:04,000 --> 00:03:09,000\nFor example, over here they regular that your birth date be specified as \n\n46\n00:03:09,000 --> 00:03:13,000\ntwo digits, two more digits, and four more digits corresponding the month, the day, or the year.\n\n47\n00:03:13,000 --> 00:03:19,000\nBy contrast, your place of birth is more likely to include letters rather than numbers.\n\n48\n00:03:19,000 --> 00:03:24,000\nA U.S. social security number involves three numbers, two more numbers, \n\n49\n00:03:24,000 --> 00:03:28,000\nand then four more numbers sometimes separated by a hyphen or a blank.\n\n50\n00:03:28,000 --> 00:03:32,000\nAn email address has to have this special @ character in it.\n\n51\n00:03:32,000 --> 00:03:34,000\nRegular expressions can help us do that.\n\n52\n00:03:34,000 --> 00:03:38,000\nThen an American phone number also has some number of digits broken up into various groups.\n\n53\n00:03:38,000 --> 00:03:44,000\nA billing address might have letters and numbers and number signs combined arbitrarily.\n\n54\n00:03:44,000 --> 00:03:48,000\nRegular expressions are going to allow us to make sense of this type of data\n\n55\n00:03:48,000 --> 00:03:51,000\nand also process it when we see it on web pages.\n\n", "id": 15001}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiadQw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/15002", "type": "Nugget", "id": 15002}, {"nuggetType": "lecture", "name": "Single Digits", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "85570f48-fa45-41ba-a3c6-faec61125888", "name": "cs262_unit1_05_q_single-digits", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGNo2DA", "youtube_id": "LWcUMhTHYLA", "youtube_state": "done", "path": "Course/cs262/Media/7002", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nLet's practice a bit more with regular expressions.\n\n2\n00:00:02,000 --> 00:00:06,000\nI'm going to write out a bunch of strings, and I want you to check all of them--\n\n3\n00:00:06,000 --> 00:00:11,000\nthere may be multiple--that exactly match 0 through 9, the regular expression.\n\n4\n00:00:11,000 --> 00:00:13,000\nDown here I've written seven strings. \n\n5\n00:00:13,000 --> 00:00:17,000\nCheck each one that matches the regular expression 0 through 9.\n\n", "id": 7002}, "key": "agpzfnVkYWNpdHl1cj8LEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiBfQw", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/16001", "type": "Nugget", "id": 16001}, {"nuggetType": "lecture", "name": "Finite State Machines", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "31cdc668-1dc6-4b0d-83f7-8fe529552be9", "name": "cs262_unit1_10_l_finite-state-machines", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGMM-DA", "youtube_id": "kXkd0qtJfpQ", "youtube_state": "done", "path": "Course/cs262/Media/8003", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:03,000\nWe want to do even more with regular expressions,\n\n2\n00:00:03,000 --> 00:00:06,000\nsuch as matching a word or a number.\n\n3\n00:00:06,000 --> 00:00:11,000\nTo do this, we're going to introduce a visual representation for regular expressions\n\n4\n00:00:11,000 --> 00:00:15,000\nthat actually shows exactly what's going on behind the scenes,\n\n5\n00:00:15,000 --> 00:00:17,000\nand then we're going to follow along in Python.\n\n6\n00:00:17,000 --> 00:00:22,000\nSuppose we have the regular expression [0 - 9] + % sign.\n\n7\n00:00:22,000 --> 00:00:27,000\nAny character like this that just appears on its own is matched directly,\n\n8\n00:00:27,000 --> 00:00:34,000\nso this catches strings like 30%, 99%, 2% and various other things we might find\n\n9\n00:00:34,000 --> 00:00:37,000\ndescribing sales or the fat content of milk.\n\n10\n00:00:37,000 --> 00:00:42,000\nHere I've drawn a finite state machine, a visual representation of this regular expression.\n\n11\n00:00:42,000 --> 00:00:46,000\nOften there's an arrow coming out of nowhere on the left that's not connected \n\n12\n00:00:46,000 --> 00:00:47,000\nto the rest of the picture.\n\n13\n00:00:47,000 --> 00:00:50,000\nThat indicates where we start.\n\n14\n00:00:50,000 --> 00:00:53,000\nThese 3 circles are states. \n\n15\n00:00:53,000 --> 00:00:56,000\nThey represent what we're up to when we're matching a string \n\n16\n00:00:56,000 --> 00:00:58,000\nagainst the regular expression--\n\n17\n00:00:58,000 --> 00:01:02,000\nwhat configuration we're in, what our current state of mind is, what we've seen so far.\n\n18\n00:01:02,000 --> 00:01:05,000\nI've labeled my states 1, 2, and 3.\n\n19\n00:01:05,000 --> 00:01:11,000\nThese other arrows are called edges or transitions.\n\n20\n00:01:11,000 --> 00:01:14,000\nThey tell us when to move from 1 state to another.\n\n21\n00:01:14,000 --> 00:01:20,000\nI start in state 1, and if I see a 0 - 9, I move over to state 2.\n\n22\n00:01:20,000 --> 00:01:25,000\nThis 0 - 9 is the label associated with this edge.\n\n23\n00:01:25,000 --> 00:01:29,000\nFinally, you'll notice that 1 of my states has a double circle.\n\n24\n00:01:29,000 --> 00:01:30,000\nThat's an accepting state.\n\n25\n00:01:30,000 --> 00:01:34,000\nIf we end up in an accepting state at the end of the input, \n\n26\n00:01:34,000 --> 00:01:37,000\nthis finite state machine matches the given string.\n\n27\n00:01:37,000 --> 00:01:40,000\nLet's trace through what happens on input 23%.\n\n28\n00:01:40,000 --> 00:01:44,000\nWe start in the start state, and the character we see is a 2,\n\n29\n00:01:44,000 --> 00:01:46,000\nso we follow this edge to state 2.\n\n30\n00:01:46,000 --> 00:01:50,000\nNow the next thing we see is a 3, so we follow this edge back to state 2.\n\n31\n00:01:50,000 --> 00:01:53,000\nThese are sometimes called self-loops.\n\n32\n00:01:53,000 --> 00:01:55,000\nIt's a loop that takes me back to right where I started.\n\n33\n00:01:55,000 --> 00:02:00,000\nNow we see the % sign, and we end up in state 3, which is an accepting state,\n\n34\n00:02:00,000 --> 00:02:07,000\nso our finite state machine accepts this string '23%' just like our regular expression would.\n\n35\n00:02:07,000 --> 00:02:09,000\nLet's try just the string '2'.\n\n36\n00:02:09,000 --> 00:02:13,000\nWe start in the start state. We see a 2, so we move over here, and then we're done.\n\n37\n00:02:13,000 --> 00:02:17,000\nWe ran out of input, but we're not in an accepting state.\n\n38\n00:02:17,000 --> 00:02:22,000\nOur finite state machine rejects this just like our regular expression would.\n\n39\n00:02:22,000 --> 00:02:25,000\nFinally, let's consider the string '2x'.\n\n40\n00:02:25,000 --> 00:02:29,000\nWe start here in state 1. We see a 2, so we go over to state 2.\n\n41\n00:02:29,000 --> 00:02:37,000\nThen we see an x, and there's no outgoing edge from state 2 on an x, \n\n42\n00:02:37,000 --> 00:02:39,000\nso we fall off the finite state machine and die.\n\n43\n00:02:39,000 --> 00:02:46,000\nThis is very sad, and when this happens our finite state machine does not accept the string,\n\n44\n00:02:46,000 --> 00:02:48,000\njust like the regular expression would not.\n\n", "id": 8003}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjshAEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/17004", "type": "Nugget", "id": 17004}, {"nuggetType": "lecture", "name": "Mis Msf", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "cfd5aff6-51b5-4b8f-ad6c-1ec5d6cb1df6", "name": "cs262_unit1_27_p_mis-msf", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGNKJAgw", "youtube_id": "PaIaxRcgF28", "youtube_state": "done", "path": "Course/cs262/Media/34002", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nSo now let's look at the problem another way,\n\n2\n00:00:02,000 --> 00:00:04,000\nin reverse.\n\n3\n00:00:04,000 --> 00:00:06,000\nSuppose this time that I give you\n\n4\n00:00:06,000 --> 00:00:09,000\nthe encoding of the finite-state machine.\n\n5\n00:00:09,000 --> 00:00:13,000\nI give you the accepting states, just 6, and  also all of the edges.\n\n6\n00:00:13,000 --> 00:00:16,000\nWhat I would like you to do is provide me with not 1 \n\n7\n00:00:16,000 --> 00:00:21,000\nbut 2 strings that are accepted by this finite-state machine,\n\n8\n00:00:21,000 --> 00:00:23,000\nstarting in state 1, but they have to be different,\n\n9\n00:00:23,000 --> 00:00:26,000\nso apply all of your knowledge, but trace it in reverse.\n\n10\n00:00:26,000 --> 00:00:30,000\nWhat would a string have to be in order to get to state 6?\n\n", "id": 34002}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjVjAEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/18005", "type": "Nugget", "id": 18005}, {"nuggetType": "lecture", "name": "Inverting The Problem", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "3a193508-fdb0-41cb-abd4-2fc7e01a08c9", "name": "cs262_unit1_30_q_inverting-the-problem", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGNaMAQw", "youtube_id": "Jqqh6cY0sI0", "youtube_state": "done", "path": "Course/cs262/Media/18006", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nAll right, let's practice this again,\n\n2\n00:00:02,000 --> 00:00:05,000\nbut this time, we've flipped the problem around.\n\n3\n00:00:05,000 --> 00:00:07,000\nI've drawn the finite-state machine\n\n4\n00:00:07,000 --> 00:00:10,000\naccepting that phone number language that we were just dealing with\n\n5\n00:00:10,000 --> 00:00:12,000\nin the last problem.\n\n6\n00:00:12,000 --> 00:00:16,000\nHowever, I have left the label for the edge between 4 and 5 blank.\n\n7\n00:00:16,000 --> 00:00:18,000\nYour mission is to fill it in.\n\n8\n00:00:18,000 --> 00:00:21,000\nWhat should this edge label be so that this finite-state machine\n\n9\n00:00:21,000 --> 00:00:23,000\naccepts those phone numbers?\n\n", "id": 18006}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjXjAEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/18007", "type": "Nugget", "id": 18007}, {"nuggetType": "lecture", "name": "Findall", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "ded4515e-c28e-40b3-85c1-4c4a4bc02615", "name": "cs262_unit1_07_q_findall", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGKMfDA", "youtube_id": "K5w13CHYyaQ", "youtube_state": "done", "path": "Course/cs262/Media/4003", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nLet's make sure we're all on the same page about these simple regular expressions\n\n2\n00:00:04,000 --> 00:00:08,000\nand the \"findall\" function in Python that allows us to manipulate them.\n\n3\n00:00:08,000 --> 00:00:13,000\nI've written out three Python expressions involving re.findall\n\n4\n00:00:13,000 --> 00:00:18,000\nthat returns a list of substrings that match the given regular expression.\n\n5\n00:00:18,000 --> 00:00:21,000\nWhat I'd like you to do is for each of those lists \n\n6\n00:00:21,000 --> 00:00:25,000\nwrite out the elements in the list in the correct order.\n\n7\n00:00:25,000 --> 00:00:30,000\nFill in the boxes with the elements of the return values of the findall expressions.\n\n", "id": 4003}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBi5lAEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/19001", "type": "Nugget", "id": 19001}, {"nuggetType": "lecture", "name": "Nondet To Det Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "7b6fe8c3-a112-4ce7-be4b-13c969dc7672", "name": "cs262_unit1_32_s_nondet-to-det", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGPGoAgw", "youtube_id": "Nt4oPX7X1QE", "youtube_state": "done", "path": "Course/cs262/Media/38001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:03,000\nWell, let's make ourselves a little scratch room and work it out.\n\n2\n00:00:03,000 --> 00:00:08,000\nThere are only 1, 2, 3 letters, a, b, and c involved,\n\n3\n00:00:08,000 --> 00:00:12,000\nso let's take a look at each one by one, see if it fits.\n\n4\n00:00:12,000 --> 00:00:16,000\nSuppose I was in state 2456 and I saw an a.\n\n5\n00:00:16,000 --> 00:00:20,000\nIf I'm in 2 and I see an a I die, 4 and I see an a I die,\n\n6\n00:00:20,000 --> 00:00:23,000\n5 and I see an a I die, 6 and I see an a I die.\n\n7\n00:00:23,000 --> 00:00:25,000\nThat's not good.\n\n8\n00:00:25,000 --> 00:00:30,000\n2456 on a goes to failure.\n\n9\n00:00:30,000 --> 00:00:32,000\nIt does not go to 23.\n\n10\n00:00:32,000 --> 00:00:34,000\nAll right, well, what if I see a b?\n\n11\n00:00:34,000 --> 00:00:37,000\nIf I'm in 2 and I see a b, I go to 3. That looks pretty good.\n\n12\n00:00:37,000 --> 00:00:39,000\n4 and I see a b I die.\n\n13\n00:00:39,000 --> 00:00:41,000\n5 and I see a b I go to 2.\n\n14\n00:00:41,000 --> 00:00:43,000\n6 and I see a b I die.\n\n15\n00:00:43,000 --> 00:00:46,000\nOh, b took us to exactly 2 and 3.\n\n16\n00:00:46,000 --> 00:00:50,000\n2456 on b went to 2 and 3.\n\n17\n00:00:50,000 --> 00:00:54,000\nBut let's just finish checking up on c just in case we missed something.\n\n18\n00:00:54,000 --> 00:00:56,000\nI'm in 2456.\n\n19\n00:00:56,000 --> 00:00:59,000\n2 on a c goes nowhere.\n\n20\n00:00:59,000 --> 00:01:01,000\n4 on a c goes nowhere.\n\n21\n00:01:01,000 --> 00:01:03,000\n5 on a c goes to 6,\n\n22\n00:01:03,000 --> 00:01:08,000\nand 6 on a c goes nowhere, so 2456\n\n23\n00:01:08,000 --> 00:01:10,000\non a c goes to 6.\n\n24\n00:01:10,000 --> 00:01:13,000\nActually, we already have that edge, 2456 on a c goes to 6,\n\n25\n00:01:13,000 --> 00:01:16,000\nand since this machine is deterministic, we only want 1 \n\n26\n00:01:16,000 --> 00:01:18,000\noutgoing edge here labeled c.\n\n27\n00:01:18,000 --> 00:01:20,000\nIt looks like b was our winner.\n\n28\n00:01:20,000 --> 00:01:22,000\nThe label for this edge is b.\n\n29\n00:01:22,000 --> 00:01:24,000\nNow, this is not a proof,\n\n30\n00:01:24,000 --> 00:01:27,000\nbut it just so happens that any non-deterministic machine\n\n31\n00:01:27,000 --> 00:01:30,000\ncan be converted to a deterministic machine \n\n32\n00:01:30,000 --> 00:01:32,000\nusing exactly the same steps.\n\n", "id": 38001}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBi_lAEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/19007", "type": "Nugget", "id": 19007}, {"nuggetType": "quiz", "name": "Single Digits", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjJlAEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/19017", "type": "Nugget", "id": 19017}, {"nuggetType": "lecture", "name": "Disjunction", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "a0050063-841b-45cf-8968-d1cf8c0bc512", "name": "cs262_unit1_13_l_disjunction", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGMtlDA", "youtube_id": "c5ZBDWOrndU", "youtube_state": "done", "path": "Course/cs262/Media/13003", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nConsider this spiffy, new finite state machine.\n\n2\n00:00:02,000 --> 00:00:14,000\nIt accepts both 1 or more letters like word--w-o-r-d--and also 1 or more digits--1, 2, 3.\n\n3\n00:00:14,000 --> 00:00:20,000\nIn fact, there's a sense in which it accepts either [a - z]+ or [0 - 9]+.\n\n4\n00:00:20,000 --> 00:00:24,000\nNote its 2 accepting states. Such power!\n\n5\n00:00:24,000 --> 00:00:27,000\nCan we do the same thing with regular expressions?\n\n6\n00:00:27,000 --> 00:00:31,000\nIt turns out we can with a new regular expression operator, \n\n7\n00:00:31,000 --> 00:00:34,000\na nubitive syntax in regular expressions that I'm going to teach you.\n\n8\n00:00:34,000 --> 00:00:39,000\nThis vertical bar means I match either the thing on the left or the thing on the right.\n\n9\n00:00:39,000 --> 00:00:44,000\nIt's formally called 'disjunction' sometimes, but we can just read it as 'or'.\n\n10\n00:00:44,000 --> 00:00:48,000\nMatch [a - z]+ or [0 - 9]+.\n\n11\n00:00:48,000 --> 00:00:55,000\nFor example, let's say we want to find all matches of lowercase [a - z]+ or [0 - 9]+ \n\n12\n00:00:55,000 --> 00:00:58,000\nin \"Goethe 1749\".\n\n13\n00:00:58,000 --> 00:01:01,000\nWe'll get both 'oethe' and '1749'.\n\n14\n00:01:01,000 --> 00:01:04,000\nWe don't get the capital G because we asked for lowercase letters over here.\n\n15\n00:01:04,000 --> 00:01:08,000\nOne of Goethe's most famous works is Faust, in which an old man makes \n\n16\n00:01:08,000 --> 00:01:14,000\na literal deal with the devil in an incredible surprise move. It does not go particularly well.\n\n17\n00:01:14,000 --> 00:01:18,000\nAnd in fact, the phrase Faustian bargain has entered the modern English lexicon\n\n18\n00:01:18,000 --> 00:01:22,000\nmeaning a deal that you really don't want to make or where you're giving up too much\n\n19\n00:01:22,000 --> 00:01:23,000\nto get something.\n\n20\n00:01:23,000 --> 00:01:30,000\nWhile we're here, our old friend regular expression [0 - 2] is really just 0/1/2.\n\n21\n00:01:30,000 --> 00:01:35,000\nSo I could write out [a - z] as 26 different choices, but that's not very concise.\n\n", "id": 13003}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiinAEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/20002", "type": "Nugget", "id": 20002}, {"nuggetType": "lecture", "name": "Inverting The Problem Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "5746adc4-6147-4e1e-ac50-369f95c29ec4", "name": "cs262_unit1_30_s_inverting-the-problem", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGKKZAgw", "youtube_id": "5COo_yyCE5A", "youtube_state": "done", "path": "Course/cs262/Media/36002", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nLet's do some simple tests.\n\n2\n00:00:02,000 --> 00:00:06,000\nWe want to be able to get things like 1, 2, 3, 4\n\n3\n00:00:06,000 --> 00:00:09,000\nand also 12-34.\n\n4\n00:00:09,000 --> 00:00:11,000\nLet's try the first one.\n\n5\n00:00:11,000 --> 00:00:15,000\n1, 2, 3, 4, we win.\n\n6\n00:00:15,000 --> 00:00:17,000\nOh, no problem there.\n\n7\n00:00:17,000 --> 00:00:20,000\nHow about this one, 12-34?\n\n8\n00:00:20,000 --> 00:00:25,000\nWell, 1, 2--I can't take the hyphen here.\n\n9\n00:00:25,000 --> 00:00:29,000\nBut I could take this epsilon transition for free and then take the hyphen.\n\n10\n00:00:29,000 --> 00:00:31,000\nThat sounds good.\n\n11\n00:00:31,000 --> 00:00:34,000\n Now I'm in state 4, and I see a 3.\n\n12\n00:00:34,000 --> 00:00:39,000\nSo probably there should be some sort of digit label on this edge.\n\n13\n00:00:39,000 --> 00:00:42,000\n3, 4, and then back here, and I accept.\n\n14\n00:00:42,000 --> 00:00:46,000\nJust to check our work, let's do something a little more complicated.\n\n15\n00:00:46,000 --> 00:00:51,000\n1, 2, 3, hyphen, 3, 4.\n\n16\n00:00:51,000 --> 00:00:55,000\nFree, free again, \n\n17\n00:00:55,000 --> 00:00:59,000\nhyphen, 5, 6, free again, accepted.\n\n18\n00:00:59,000 --> 00:01:01,000\nExcellent.\n\n", "id": 36002}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBijnAEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/20003", "type": "Nugget", "id": 20003}, {"nuggetType": "lecture", "name": "Concatenation", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "d48ce1cd-7371-4856-908d-a21d8bfbf496", "name": "cs262_unit1_08_q_concatenation", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGKQfDA", "youtube_id": "6LjfyFUzKag", "youtube_state": "done", "path": "Course/cs262/Media/4004", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nNow that we've mastered single character regular expressions,\n\n2\n00:00:04,000 --> 00:00:06,000\nlet's look into gluing them together.\n\n3\n00:00:06,000 --> 00:00:11,000\nWe're going to need to find important bits of punctuation like slash greater than\n\n4\n00:00:11,000 --> 00:00:16,000\n or equals equals to reason about JavaScript and HTML and thus write our web browser.\n\n5\n00:00:16,000 --> 00:00:20,000\nThus we really need the ability to concatenate or put right next to each other \n\n6\n00:00:20,000 --> 00:00:23,000\nin repeat regular expressions.\n\n7\n00:00:23,000 --> 00:00:26,000\nWell, with regular expressions that's actually as simple as just writing\n\n8\n00:00:26,000 --> 00:00:29,000\ntwo regular expressions right next to each other.\n\n9\n00:00:29,000 --> 00:00:36,000\nThis matches the string a1, a2, b1, b2, c1, and c2--six strings in all.\n\n10\n00:00:36,000 --> 00:00:41,000\nIn each one, the first letter comes in the first regular expression,\n\n11\n00:00:41,000 --> 00:00:47,000\nand the second letters, 1 or 2, matches the second part of the regular expression.\n\n12\n00:00:47,000 --> 00:00:53,000\nWe've concatenated a through c and 1 through 2 together to match more complicated strings.\n\n13\n00:00:53,000 --> 00:00:56,000\nYou may have noticed that we suddenly had quite a few strings\n\n14\n00:00:56,000 --> 00:00:58,000\nfrom a relatively small regular expression.\n\n15\n00:00:58,000 --> 00:01:01,000\nIn fact, if we 0 through 9 next to 0 through 9,\n\n16\n00:01:01,000 --> 00:01:05,000\nthere are a huge number of strings that we would match--100 in total.\n\n17\n00:01:05,000 --> 00:01:09,000\nJust as this matches 10 and this matches 10 when you put them together,\n\n18\n00:01:09,000 --> 00:01:11,000\nyou match 10-squared strings.\n\n19\n00:01:11,000 --> 00:01:15,000\nSo let's look for a two-digit number in the string July 28, 1921.\n\n20\n00:01:15,000 --> 00:01:18,000\nHere is a two-digit number, here is a two-digit number, and here is another one.\n\n21\n00:01:18,000 --> 00:01:25,000\nWe'll end up getting 28, 18, and 21.\n\n22\n00:01:25,000 --> 00:01:29,000\nNow I'm looking for two-digit numbers in 12345--12 is a two-digit number, \n\n23\n00:01:29,000 --> 00:01:33,000\n34 is a two-digit number, but 5 actually does not qualify.\n\n24\n00:01:33,000 --> 00:01:39,000\nThis regular expression requires that both subparts be matched.\n\n25\n00:01:39,000 --> 00:01:44,000\nJuly 28, 1821 is a good day for Peruvian Independence.\n\n26\n00:01:44,000 --> 00:01:48,000\nLet's brush up on matching these compound regular expressions.\n\n27\n00:01:48,000 --> 00:01:51,000\nDown here I've written a Python fragment\n\n28\n00:01:51,000 --> 00:01:54,000\nor Python program involving re.findall.\n\n29\n00:01:54,000 --> 00:02:00,000\nWe're looking for a through Z followed by 0 through 9 in this artificially constructed string\n\n30\n00:02:00,000 --> 00:02:05,000\ndesigned to be a bit tricky--a1 space 2b space cc3 space 44d.\n\n31\n00:02:05,000 --> 00:02:09,000\nI'm going to write out a bunch of possible answers, and I want you to tell me--\n\n32\n00:02:09,000 --> 00:02:14,000\ncheck all that apply which of the following are elements of the return value of this expression.\n\n33\n00:02:14,000 --> 00:02:16,000\nHere I've written nine possibilities. \n\n34\n00:02:16,000 --> 00:02:20,000\nCheck each one that's a member of the list that's return by this Python expression.\n\n", "id": 4004}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiJpAEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/21001", "type": "Nugget", "id": 21001}, {"nuggetType": "lecture", "name": "Accepting States", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "9100afba-3728-4ab3-9e3a-dc12b38d3a51", "name": "cs262_unit1_11_q_accepting-states", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGMG7AQw", "youtube_id": "4lQpyZM2mmg", "youtube_state": "done", "path": "Course/cs262/Media/24001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:03,000\nLet's explore a bit more in this brave new world of finite state machines.\n\n2\n00:00:03,000 --> 00:00:08,000\nOver here, I've drawn a different finite state machine, again with 3 states.\n\n3\n00:00:08,000 --> 00:00:11,000\nI'm going to draw some possible strings down here,\n\n4\n00:00:11,000 --> 00:00:15,000\nand I want you to check each one that would be accepted by this finite state machine.\n\n5\n00:00:15,000 --> 00:00:19,000\nSo in this multiple multiple-choice quiz, mark each one of these that's accepted \n\n6\n00:00:19,000 --> 00:00:20,000\nby this finite state machine.\n\n", "id": 24001}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiKpAEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/21002", "type": "Nugget", "id": 21002}, {"nuggetType": "lecture", "name": "Concatenation Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "db7bbfef-b5d4-4789-ba60-5026c934baf8", "name": "cs262_unit1_08_s_concatenation", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGJt1DA", "youtube_id": "ryzjSzGI8jA", "youtube_state": "done", "path": "Course/cs262/Media/15003", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nFor one of these things to be in the return value, two things have to be true.\n\n2\n00:00:04,000 --> 00:00:08,000\nFirst, it has to actually match this regular expression.\n\n3\n00:00:08,000 --> 00:00:11,000\nSecond, it has to be in this string.\n\n4\n00:00:11,000 --> 00:00:14,000\nSo a1 does match this regular expression.\n\n5\n00:00:14,000 --> 00:00:20,000\nWe're looking for things like a1, a2, b1, b2, c1, etc.\n\n6\n00:00:20,000 --> 00:00:23,000\nThere's actually an a1 in this string. So, yes.\n\n7\n00:00:23,000 --> 00:00:27,000\n2b does not match this regular expression.\n\n8\n00:00:27,000 --> 00:00:33,000\nFor this particular regular expression, the first letter always has to be a letter and not a digit.\n\n9\n00:00:33,000 --> 00:00:36,000\nThis doesn't work out. B2 looks very promising.\n\n10\n00:00:36,000 --> 00:00:42,000\nIt's one of the strings we would match, except that it's not actually found in our haystack string.\n\n11\n00:00:42,000 --> 00:00:44,000\nIt can't be part of the return value.\n\n12\n00:00:44,000 --> 00:00:48,000\nCc doesn't match, because we're looking for things like a1, b1, c1\n\n13\n00:00:48,000 --> 00:00:52,000\nthat have a digit in the second position. This is not a digit.\n\n14\n00:00:52,000 --> 00:00:56,000\nCc3 does not match because it's three characters long \n\n15\n00:00:56,000 --> 00:00:58,000\nand we're looking for strings that are two characters long.\n\n16\n00:00:58,000 --> 00:01:02,000\n44 doesn't match, because it doesn't start with a through z.\n\n17\n00:01:02,000 --> 00:01:08,000\nD4 looks very good. It's the sort of thing we would match from this regular expression,\n\n18\n00:01:08,000 --> 00:01:11,000\nbut it's not actually in our haystack string.\n\n19\n00:01:11,000 --> 00:01:13,000\nInstead we have 44d.\n\n20\n00:01:13,000 --> 00:01:16,000\nThe empty string--this was a bit of a ringer or distracter thrown in--\n\n21\n00:01:16,000 --> 00:01:20,000\ndoesn't match our regular expression. It's too short.\n\n22\n00:01:20,000 --> 00:01:24,000\nIt's zero characters long, and we're matching things that are two characters long.\n\n23\n00:01:24,000 --> 00:01:31,000\nBut finally c3 matches our regular expression and it's present in the string, so yes.\n\n", "id": 15003}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjxqwEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/22001", "type": "Nugget", "id": 22001}, {"nuggetType": "lecture", "name": "Hyphenation", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "d4feec9f-415b-4af3-8bb1-2b903b86af46", "name": "cs262_unit1_18_p_hyphenation", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGIH6AQw", "youtube_id": "HVXWJv9EUy8", "youtube_state": "done", "path": "Course/cs262/Media/32001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nSo now that you have a large number of tools in your regular expression tool belt.\n\n2\n00:00:04,000 --> 00:00:07,000\nLet's put it together and build a new regular expression.\n\n3\n00:00:07,000 --> 00:00:09,000\nI'd like you to submit via the interpreter.\n\n4\n00:00:09,000 --> 00:00:15,000\nAssign to the variable regexp, a Python regular expression that matches lowercase words--\n\n5\n00:00:15,000 --> 00:00:22,000\nletters (a - z) or singly-hypenated lowercase words.\n\n6\n00:00:22,000 --> 00:00:23,000\nLet me show you what that means.\n\n7\n00:00:23,000 --> 00:00:30,000\nSo we could have just a word like html or a hyphenated word like well-liked.\n\n8\n00:00:30,000 --> 00:00:36,000\nBut we don't want doubly-hyphenated words like a-b-c or 2 hypens in a row,\n\n9\n00:00:36,000 --> 00:00:38,000\njust these 2 options.\n\n10\n00:00:38,000 --> 00:00:41,000\nAnd it's worth noting that it may not be possible to get this perfect yet.\n\n11\n00:00:41,000 --> 00:00:44,000\nNot all problems are solvable. Just do your best.\n\n", "id": 32001}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjyqwEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/22002", "type": "Nugget", "id": 22002}, {"nuggetType": "lecture", "name": "Fsm Interpretation", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "0474a050-3040-4457-92dd-3dbd840fea7e", "name": "cs262_unit1_25_p_fsm-interpretation", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGN2zAQw", "youtube_id": "AOwsMm2u_lU", "youtube_state": "done", "path": "Course/cs262/Media/23005", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nSo now let's really prove the power of our finite state machine interpreter\n\n2\n00:00:04,000 --> 00:00:07,000\nby showing that we could figure out any finite state machine.\n\n3\n00:00:07,000 --> 00:00:13,000\nYou should submit, via the interpreter, values for edges and accepting those 2 key variables\n\n4\n00:00:13,000 --> 00:00:17,000\nthat encode the regular expression \"q*\"--\n\n5\n00:00:17,000 --> 00:00:22,000\nso the empty string, \"q\", \"qq\".\n\n6\n00:00:22,000 --> 00:00:25,000\nFor convenience, name your start state 1.\n\n", "id": 23005}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjeswEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/23006", "type": "Nugget", "id": 23006}, {"nuggetType": "lecture", "name": "Accepting States Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "f38514f4-e10b-4967-a50b-38f6b30ac28f", "name": "cs262_unit1_11_s_accepting-states", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGKnDAQw", "youtube_id": "_5C-5Vo0Ztg", "youtube_state": "done", "path": "Course/cs262/Media/25001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nWell, let's go try them out.\n\n2\n00:00:02,000 --> 00:00:05,000\nThis \"put your finger on the state method\" is actually pretty much how you do it. \n\n3\n00:00:05,000 --> 00:00:07,000\nYou start here in the start state, and then we see an a, \n\n4\n00:00:07,000 --> 00:00:09,000\nso we move over here.\n\n5\n00:00:09,000 --> 00:00:11,000\nWe see a 1. We move over here.\n\n6\n00:00:11,000 --> 00:00:15,000\nWe're out of input in an accepting state. This totally works!\n\n7\n00:00:15,000 --> 00:00:16,000\nHow about 'aa'?\n\n8\n00:00:16,000 --> 00:00:19,000\nWe start in state 1. We see an a. Great! We move to state 2.\n\n9\n00:00:19,000 --> 00:00:23,000\nWe see the next a--oh! We fall off the finite state machine and die. No such luck.\n\n10\n00:00:23,000 --> 00:00:31,000\n'2b'--we start here in state 1. We see a 2. We immediately fall off and die. Not very good.\n\n11\n00:00:31,000 --> 00:00:36,000\nThe empty string--we start in state 1. We don't go anywhere because we're out of input.\n\n12\n00:00:36,000 --> 00:00:42,000\nBut state 1 is not an accepting state, so we don't accept this string.\n\n13\n00:00:42,000 --> 00:00:48,000\n'cc3'--start here in state 1. We see a c. We go to state 2. We see another c. We fall off.\n\n14\n00:00:48,000 --> 00:00:53,000\n'44d'--we start here in state 1. We see a 4. We fall off immediately.\n\n15\n00:00:53,000 --> 00:00:56,000\nIn fact, only 'a1' matched out of all of these.\n\n", "id": 25001}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiRywEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/26001", "type": "Nugget", "id": 26001}, {"nuggetType": "lecture", "name": "Fsm Simulator", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "bc32c789-5884-4e7e-a48c-549150dd7bc2", "name": "cs262_unit1_24_p_fsm-simulator", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGLJtDA", "youtube_id": "EHvrBD8nY1A", "youtube_state": "done", "path": "Course/cs262/Media/14002", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nWith all of that in mind, let's encode our finite state machine in Python.\n\n2\n00:00:04,000 --> 00:00:08,000\nHere I've redrawn our finite state machine for \"a+1+\",\n\n3\n00:00:08,000 --> 00:00:12,000\nand we said before that we were going to make the edges a mapping or a dictionary.\n\n4\n00:00:12,000 --> 00:00:20,000\nWell, one of our edges is at state 1 on 'a.' State 1 on input 'a' goes to state 2.\n\n5\n00:00:20,000 --> 00:00:24,000\nAnd another one is at state 2 on 'a' stays in state 2.\n\n6\n00:00:24,000 --> 00:00:25,000\nThat's our self-loop. \n\n7\n00:00:25,000 --> 00:00:29,000\nIf we were on state 2 and we see a 1, we go to state 3.\n\n8\n00:00:29,000 --> 00:00:32,000\nState 3 on 1 stays the same.\n\n9\n00:00:32,000 --> 00:00:33,000\nLet me just highlight one of these.\n\n10\n00:00:33,000 --> 00:00:42,000\nThis particular edge from 2 to 3 on 1 corresponds to this entry in our edges mapping.\n\n11\n00:00:42,000 --> 00:00:45,000\nI also need to know which states are the accepting states.\n\n12\n00:00:45,000 --> 00:00:48,000\nPreviously, I denoted that by drawing double lines,\n\n13\n00:00:48,000 --> 00:00:50,000\nbut again we can't pass a picture into Python, so I'll just make a list \n\n14\n00:00:50,000 --> 00:00:52,000\nof all the things it accepts.\n\n15\n00:00:52,000 --> 00:00:54,000\nThen actually that's it.\n\n16\n00:00:54,000 --> 00:00:56,000\nYou'd think we'd need a list of nodes, but you're going to see that we're actually \n\n17\n00:00:56,000 --> 00:01:01,000\nable to finesse it because all the nodes we really care about\n\n18\n00:01:01,000 --> 00:01:03,000\nalready appear in this edges listing.\n\n19\n00:01:03,000 --> 00:01:06,000\nSo here we are writing our finite state machine simulator,\n\n20\n00:01:06,000 --> 00:01:10,000\nand this is actually super exciting because it previews one of the concepts\n\n21\n00:01:10,000 --> 00:01:13,000\nthat we're going to have later in the course--interpreting another program.\n\n22\n00:01:13,000 --> 00:01:16,000\nIt's like the junior grade version of it, even this will be a lot of fun.\n\n23\n00:01:16,000 --> 00:01:22,000\nSo together, we're going to write a procedure called fsmsim for FSM simulation,\n\n24\n00:01:22,000 --> 00:01:24,000\nfinite state machine simulator.\n\n25\n00:01:24,000 --> 00:01:30,000\nYou pass in the input string, the start state or the current state, the edges, \n\n26\n00:01:30,000 --> 00:01:34,000\nand the accepting states, and it returns true if that string is accepted \n\n27\n00:01:34,000 --> 00:01:36,000\nby the finite state machine and false otherwise.\n\n28\n00:01:36,000 --> 00:01:38,000\nWe'll do it together.\n\n29\n00:01:38,000 --> 00:01:43,000\nSubmit via the interpreter--I'll write the first half of this procedure with you.\n\n30\n00:01:43,000 --> 00:01:46,000\nSo let's get started on our finite state machine simulation quiz.\n\n31\n00:01:46,000 --> 00:01:51,000\nHere I'm just recopying the edges definition so that we'll have a test input to work with.\n\n32\n00:01:51,000 --> 00:01:55,000\nThese 2--the edges and the accepting state--correspond to the regular expression \n\n33\n00:01:55,000 --> 00:02:00,000\n\"a+1+\", and now we're going to define our procedure, finite state machine simulator\n\n34\n00:02:00,000 --> 00:02:05,000\ngiven a string, the current state, the edges--these ones up here--and the accepting state.\n\n35\n00:02:05,000 --> 00:02:06,000\nWhat do we do?\n\n36\n00:02:06,000 --> 00:02:10,000\nWell, one possibility is that we're already at the end of the input,\n\n37\n00:02:10,000 --> 00:02:14,000\nat which point we should just check to see if our current state is an accepting state or not.\n\n38\n00:02:14,000 --> 00:02:18,000\nIf we're at the end of the input and we are state 3, then we return true.\n\n39\n00:02:18,000 --> 00:02:20,000\nOtherwise, we should be returning false.\n\n40\n00:02:20,000 --> 00:02:26,000\nIf the string isn't empty, then I can get the current letter as the 0th position from the string.\n\n41\n00:02:26,000 --> 00:02:27,000\nAnd now, here's your part.\n\n42\n00:02:27,000 --> 00:02:30,000\nWe know the current input letter we're looking at,\n\n43\n00:02:30,000 --> 00:02:33,000\nthe current state we're in, all of the edges are available to us-- \n\n44\n00:02:33,000 --> 00:02:36,000\nyou fill out the rest of this code.\n\n45\n00:02:36,000 --> 00:02:37,000\nHere's a hint. \n\n46\n00:02:37,000 --> 00:02:42,000\nFind out if there's a valid edge leaving from this state on this letter.\n\n47\n00:02:42,000 --> 00:02:45,000\nIf there is, you should take that edge and keep walking.\n\n48\n00:02:45,000 --> 00:02:49,000\nIf there is not, we fall off the end of the finite state machine and die,\n\n49\n00:02:49,000 --> 00:02:50,000\nso you should return false.\n\n50\n00:02:50,000 --> 00:02:54,000\nAnd the big hint for you is recursion, which is always the hint in computer science\n\n51\n00:02:54,000 --> 00:02:56,000\nbecause it's the secret of all power and knowledge in the universe.\n\n52\n00:02:56,000 --> 00:02:58,000\nRecursion, use it. \n\n53\n00:02:58,000 --> 00:03:00,000\nOh, and I can't even spell it!\n\n54\n00:03:00,000 --> 00:03:03,000\nAlright, recursion. You should use it and spell it correctly, unlike me.\n\n", "id": 14002}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiSywEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/26002", "type": "Nugget", "id": 26002}, {"nuggetType": "snippetQuiz", "name": "Fsm Evolution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiTywEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/26003", "type": "Nugget", "id": 26003}, {"nuggetType": "program", "name": "Re Challenges", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBj80gEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/27004", "suppliedCode": "# RE Challenges\n\n# Assign to the variable regexp a Python regular expression that matches single-\n# argument mathematical functions.\n\n# The function name is a lowercase word (a-z), the function argument must be a\n# number (0-9), and there may optionally be spaces before and/or after the\n# argument.\n\n# Hint: You may need to escape the ( and ).\n\nimport re\n\nregexp = r\"\"\n\n# regexp matches:\n\n#print re.findall(regexp,\"cos(0)\") == [\"cos(0)\"]\n#>>> True\n\n#print re.findall(regexp,\"sqrt(   2     )\") == [\"sqrt(   2     )\"]\n#>>> True\n\n\n# regexp does not match:\n\n#print re.findall(regexp,\"cos     (0)\") != [\"cos     (0)\"]\n#>>> True\n\n#print re.findall(regexp,\"sqrt(x)\") != [\"sqrt(x)\"]\n#>>> True\n\n\n        ", "type": "Nugget", "id": 27004}, {"nuggetType": "lecture", "name": "Disjunction In Fsms Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "0d812279-2159-4747-9cef-1ae1df2b9d64", "name": "cs262_unit1_14_s_disjunction-in-fsms", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGMxlDA", "youtube_id": "EoDb8MoTb7M", "youtube_state": "done", "path": "Course/cs262/Media/13004", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:07,000\nWell, it turns out that this finite state machine accepts [a - z]+ or [0 - 9]+,\n\n2\n00:00:07,000 --> 00:00:10,000\nbut we don't need to know that to answer the question.\n\n3\n00:00:10,000 --> 00:00:11,000\nWe can just start at the start state.\n\n4\n00:00:11,000 --> 00:00:16,000\nWe see an 'a'. We end up in state 2, and state 2 is an accepting state, so we accept.\n\n5\n00:00:16,000 --> 00:00:19,000\nThe empty string--we come in here in state 1, and we don't go anywhere\n\n6\n00:00:19,000 --> 00:00:20,000\nbecause we're out of input.\n\n7\n00:00:20,000 --> 00:00:23,000\nState 1 is not an accepting state, so, no.\n\n8\n00:00:23,000 --> 00:00:27,000\n'Havel 1936' starts with an uppercase H. \n\n9\n00:00:27,000 --> 00:00:29,000\nWe actually don't have any outgoing edges on uppercase H,\n\n10\n00:00:29,000 --> 00:00:33,000\nso we fall off immediately and do not accept.\n\n11\n00:00:33,000 --> 00:00:37,000\nLowercase 'havel 2011'--that's just looking good.\n\n12\n00:00:37,000 --> 00:00:42,000\nh-a-v-e-l, and we're still in state 2, and then we see the 2, \n\n13\n00:00:42,000 --> 00:00:50,000\nand now we fall off because this accepts either words or numbers, but not combinations.\n\n14\n00:00:50,000 --> 00:00:56,000\nThen finally '1993'--1-9-9-3. Yes!\n\n15\n00:00:56,000 --> 00:01:03,000\nVaclav Havel was a Czech writer/intellectual and the first president of the Czech Republic\n\n16\n00:01:03,000 --> 00:01:04,000\nin 1993.\n\n", "id": 13004}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjh2gEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/28001", "type": "Nugget", "id": 28001}, {"nuggetType": "lecture", "name": "Options", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "63332b6e-eaa8-4ae3-9d89-b600ae9db7f4", "name": "cs262_unit1_16_l_options", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGMniAQw", "youtube_id": "la0XV03NkrI", "youtube_state": "done", "path": "Course/cs262/Media/29001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:03,000\nSo now we have a way with regular expressions to choose\n\n2\n00:00:03,000 --> 00:00:05,000\neither a or b.\n\n3\n00:00:05,000 --> 00:00:08,000\nAnother very common choice is to choose between\n\n4\n00:00:08,000 --> 00:00:09,000\na or nothing\n\n5\n00:00:10,000 --> 00:00:12,000\nThat is, to have a part of a string that's optional.\n\n6\n00:00:12,000 --> 00:00:15,000\nFor example, when you're writing out numbers, it's possible\n\n7\n00:00:15,000 --> 00:00:18,000\n to put a negative sign at the begining of a number.\n\n8\n00:00:18,000 --> 00:00:21,000\nBut you don't need to, depends on which number your trying to get across.\n\n9\n00:00:22,000 --> 00:00:27,000\nHere I've drawn a finite state machine that accepts numbers with no leading negative sign\n\n10\n00:00:27,000 --> 00:00:29,000\nand numbers with leading negative sign.\n\n11\n00:00:30,000 --> 00:00:31,000\nLets see how it goes.\n\n12\n00:00:31,000 --> 00:00:37,000\nFor something like 1,2,3, we start here. 1,2,3, and we're in state 4, which accepts.\n\n13\n00:00:37,000 --> 00:00:43,000\nFor something like -57--negative, 5, 7--we're in state 3, which accepts.\n\n14\n00:00:43,000 --> 00:00:46,000\nBut you may have noticed quite a bit of duplication\n\n15\n00:00:46,000 --> 00:00:48,000\nin this finite state machine.\n\n16\n00:00:48,000 --> 00:00:51,000\nThese two red areas are the same. \n\n17\n00:00:51,000 --> 00:00:55,000\nIt's an edge labeled 0 - 9, an accepting state with a self-loop labeled 0 - 9.\n\n18\n00:00:55,000 --> 00:00:58,000\nAnd one of the things we really wanted was to be concise.\n\n19\n00:00:58,000 --> 00:01:04,000\nSo conceptually, it might be simpler to have an edge that somehow consumes no input.\n\n20\n00:01:04,000 --> 00:01:08,000\nThis new finite state machine will still accept 1, 2, 3.\n\n21\n00:01:08,000 --> 00:01:12,000\nHere we start in state 1. I don't consume anything and move to state 2.\n\n22\n00:01:12,000 --> 00:01:15,000\nAnd then it's 1, 2, 3, and we accept.\n\n23\n00:01:15,000 --> 00:01:20,000\n-57, I take the negative, 5, 7, and then we accept.\n\n24\n00:01:20,000 --> 00:01:24,000\nWe have a particular convention for indicating that an edge accepts no input.\n\n25\n00:01:24,000 --> 00:01:26,000\nWe use the Greek letter Epsilon.\n\n26\n00:01:26,000 --> 00:01:30,000\nYou can either think of Epsilon as meaning \"consume no input\" \n\n27\n00:01:30,000 --> 00:01:34,000\nwhen you go across this edge, or you can think of it as referring to \"the empty string\",\n\n28\n00:01:34,000 --> 00:01:37,000\nat which point you can consume the empty string all you want,\n\n29\n00:01:37,000 --> 00:01:41,000\nbut since it's of size 0, it doesn't effect what you're trying to recognize.\n\n30\n00:01:41,000 --> 00:01:44,000\nThis idea of using this Greek letter--this is totally arbitrary.\n\n31\n00:01:44,000 --> 00:01:46,000\nThis is just an artificial convention.\n\n32\n00:01:46,000 --> 00:01:49,000\nBut it's a commonly used one, so it's worth knowing.\n\n33\n00:01:49,000 --> 00:01:52,000\nContinuing our theme that anything that can be done in finite state machines\n\n34\n00:01:52,000 --> 00:01:57,000\ncan be done in regular expressions and vice versa--we'll firm that up later on.\n\n35\n00:01:57,000 --> 00:02:01,000\nI'm going to give you a new regular expression--the question mark,\n\n36\n00:02:01,000 --> 00:02:09,000\nwhich we typically read as optional or the previous thing 0 or 1 times.\n\n37\n00:02:09,000 --> 00:02:14,000\nIn that way, it's a lot like plus, which was the previous thing 1 or more times.\n\n38\n00:02:14,000 --> 00:02:19,000\nSo I might write a regular expression that accepts numbers that may optionally \n\n39\n00:02:19,000 --> 00:02:20,000\nhave a leading negative sign.\n\n40\n00:02:20,000 --> 00:02:24,000\nThis negative sign may be present 1 time or 0 times.\n\n41\n00:02:24,000 --> 00:02:25,000\nIt can be there or not.\n\n42\n00:02:25,000 --> 00:02:27,000\nWe definitely need the [0 - 9]+.\n\n43\n00:02:27,000 --> 00:02:34,000\nAnd the string we're looking for this needle in is \"1861 - 1941 R. Tagore\".\n\n44\n00:02:34,000 --> 00:02:38,000\nAnd on this particular input, we will find 2 substrings that match.\n\n45\n00:02:38,000 --> 00:02:42,000\n1861 matches without the leading negative sign,\n\n46\n00:02:42,000 --> 00:02:47,000\nand - 1941 matches with the leading negative sign.\n\n47\n00:02:47,000 --> 00:02:51,000\nRabindranath Tagore is a Nobel Prize winning Bengali poet,\n\n48\n00:02:51,000 --> 00:02:55,000\nperhaps best known for his work, Where the Mind is Without Fear.\n\n", "id": 29001}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBix6gEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/30001", "type": "Nugget", "id": 30001}, {"nuggetType": "lecture", "name": "Escape Sequences", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "fe85400e-9c1d-4ff5-b7c2-a4a4fb5d0bb6", "name": "cs262_unit1_17_l_escape-sequences", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGLqUAQw", "youtube_id": "bIVVz0Zidgk", "youtube_state": "done", "path": "Course/cs262/Media/19002", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:03,000\nJust as we can get a lot of use out of + for 1 or more copies,\n\n2\n00:00:03,000 --> 00:00:07,000\nsometimes it's nice to have 0 or more copies.\n\n3\n00:00:07,000 --> 00:00:11,000\nSo we'll introduce the star regular expression for that.\n\n4\n00:00:11,000 --> 00:00:13,000\nYou can convert between the 2 of them.\n\n5\n00:00:13,000 --> 00:00:18,000\nIf you wanted 1 or more copies of a, you could have a, followed by 0 or more copies of a.\n\n6\n00:00:18,000 --> 00:00:22,000\nSome classes or texts will teach the star first and then move on to the plus.\n\n7\n00:00:22,000 --> 00:00:26,000\nWe teach the plus first because it's more common for specifying Python and Javascript.\n\n8\n00:00:26,000 --> 00:00:31,000\nSo now, the plus, the star, the question mark, the open square brackets, \n\n9\n00:00:31,000 --> 00:00:34,000\nthe closed square brackets--they all mean something special in regular expressions.\n\n10\n00:00:34,000 --> 00:00:37,000\nThey help us to note sets of strings.\n\n11\n00:00:37,000 --> 00:00:40,000\nWhat if the string I want to match is actually just a + sign.\n\n12\n00:00:40,000 --> 00:00:44,000\nHow do it do it if + means 1 or more copies of what came before?\n\n13\n00:00:44,000 --> 00:00:47,000\nWe need some way of saying, \"No, no--I really mean it!\n\n14\n00:00:47,000 --> 00:00:50,000\nActually +, not 1 or more, just +.\"\n\n15\n00:00:50,000 --> 00:00:54,000\nWe're going to solve this by using something called escape sequences,\n\n16\n00:00:54,000 --> 00:00:58,000\nbut before I get into them, let's introduce them by way of analogy.\n\n17\n00:00:58,000 --> 00:01:03,000\nIn Python, you can declare a string using double quotes or single quotes.\n\n18\n00:01:03,000 --> 00:01:08,000\nSo if you want to have a constant string that reads, P & P is Jane's book.\n\n19\n00:01:08,000 --> 00:01:11,000\nIf you use single quotes, Python will get confused because you have 1 here,\n\n20\n00:01:11,000 --> 00:01:16,000\n1 here, and 1 there, and it will think your string ends at the \"e\" in Jane.\n\n21\n00:01:16,000 --> 00:01:18,000\nNo problem, you say?\n\n22\n00:01:18,000 --> 00:01:21,000\nI will just use double quotes.That's what they're there for.\n\n23\n00:01:21,000 --> 00:01:25,000\nBut what if you want to include quoted dialogue in your string?\n\n24\n00:01:25,000 --> 00:01:30,000\nSo now I want to say, \"I said, P & P is Jane's book.\"\n\n25\n00:01:30,000 --> 00:01:34,000\nSo now I'm using both the single quote and the double quote for their actual meanings.\n\n26\n00:01:34,000 --> 00:01:36,000\nWhat do I put on the side?\n\n27\n00:01:36,000 --> 00:01:41,000\nWell, Python will actually let you bypass this by using triple quotes,\n\n28\n00:01:41,000 --> 00:01:43,000\nbut what if I really wanted to have triple quotes in the middle too?\n\n29\n00:01:43,000 --> 00:01:45,000\nWe can't do this forever.\n\n30\n00:01:45,000 --> 00:01:50,000\nWell, it turns out that if I just put a backward slash, a backslash, in front of a quote\n\n31\n00:01:50,000 --> 00:01:52,000\nor a double quote or whatnot,\n\n32\n00:01:52,000 --> 00:01:58,000\nPython will treat it as being part of this string and not as being the end of the string.\n\n33\n00:01:58,000 --> 00:02:02,000\nWe're escaping out of treating quotes as string delimiters,\n\n34\n00:02:02,000 --> 00:02:05,000\nso this is Python's way of saying, no, no, I really mean it.\n\n35\n00:02:05,000 --> 00:02:06,000\nI actually have a quote there.\n\n36\n00:02:06,000 --> 00:02:09,000\nNow when you actually go to write this down in Python, \n\n37\n00:02:09,000 --> 00:02:11,000\nyou may not get different colors or different fonts,\n\n38\n00:02:11,000 --> 00:02:13,000\nso this maybe a little hard to read,\n\n39\n00:02:13,000 --> 00:02:14,000\nbut it does work.\n\n40\n00:02:14,000 --> 00:02:20,000\nI can use these escape sequences to literally write down a special character.\n\n41\n00:02:20,000 --> 00:02:27,000\nThe backslash is sometimes called an escape character and the 2 of these together\n\n42\n00:02:27,000 --> 00:02:30,000\nare an escape sequence, a sequence of characters that are treated as if it were\n\n43\n00:02:30,000 --> 00:02:33,000\njust the double quotes, just a single quote.\n\n44\n00:02:33,000 --> 00:02:35,000\nNote that Python is throwing away this backslash.\n\n45\n00:02:35,000 --> 00:02:37,000\nYou won't actually see it.\n\n46\n00:02:37,000 --> 00:02:40,000\nJust to show you how this sort of thing plays out in Python,\n\n47\n00:02:40,000 --> 00:02:44,000\nI've written down 2 different versions of P & P is Jane's book--\n\n48\n00:02:44,000 --> 00:02:47,000\none using double quotes and one using an escape sequence.\n\n49\n00:02:47,000 --> 00:02:51,000\nWe're going to print out both of their values and then check to see if they're actually equal.\n\n50\n00:02:51,000 --> 00:02:53,000\nAnd in fact, they are.\n\n51\n00:02:53,000 --> 00:02:55,000\nEven though we entered them slightly differently,\n\n52\n00:02:55,000 --> 00:03:00,000\nPython treats them both the same internally and indicates that they're equal.\n\n53\n00:03:00,000 --> 00:03:02,000\nHere's 1 more example of this.\n\n54\n00:03:02,000 --> 00:03:05,000\nThis time with a double quote being escaped twice.\n\n55\n00:03:05,000 --> 00:03:09,000\nAnd again, the 2 strings are equal under the hood as Python deals with them.\n\n56\n00:03:09,000 --> 00:03:13,000\nIt turns out that we can do the same thing in regular expressions.\n\n57\n00:03:13,000 --> 00:03:16,000\nSuppose you want to find the string '++'.\n\n58\n00:03:16,000 --> 00:03:23,000\nThis regular expression \"\\+\\+\" has 2 escape sequences,\n\n59\n00:03:23,000 --> 00:03:26,000\nand it finds only the string '++'.\n\n", "id": 19002}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiZ8gEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/31001", "type": "Nugget", "id": 31001}, {"nuggetType": "lecture", "name": "Structure", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "857d8a89-2f5f-46a5-8067-99a643e6cbeb", "name": "cs262_unit1_21_l_structure", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGNGJAgw", "youtube_id": "P-Wwjj1S4cE", "youtube_state": "done", "path": "Course/cs262/Media/34001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nIn mathematics, when an expression gets complicated, we can add parenthesis\n\n2\n00:00:04,000 --> 00:00:13,000\nto show structure or grouping--(x - 3) x 5 is different than x - (3 x 5).\n\n3\n00:00:13,000 --> 00:00:16,000\nPython regular expressions have similar parenthesis,\n\n4\n00:00:16,000 --> 00:00:18,000\nbut they're written a litttle differently.\n\n5\n00:00:18,000 --> 00:00:21,000\nThe closing parenthesis looks just the same,\n\n6\n00:00:21,000 --> 00:00:27,000\nbut the opening parenthesis--the version you'll be using in this class--is 3 characters--\n\n7\n00:00:27,000 --> 00:00:28,000\n(?:    ).\n\n8\n00:00:28,000 --> 00:00:30,000\nThere's a simple example.\n\n9\n00:00:30,000 --> 00:00:35,000\nThis regular expression makes a group around xyz and then this whole thing\n\n10\n00:00:35,000 --> 00:00:37,000\ncan be repeated 1 or more times,\n\n11\n00:00:37,000 --> 00:00:42,000\nso some strings are xyz, xyzxyz, and so on.\n\n12\n00:00:42,000 --> 00:00:46,000\nSuppose we want to find words made up of combinations of musical notes.\n\n13\n00:00:46,000 --> 00:00:51,000\nIn Western music, the notes are often given names--do, re, mi, fa, so, la, ti--\n\n14\n00:00:51,000 --> 00:00:55,000\nand you could put them together in various combinations--re, fa, fa--do, do, re--\n\n15\n00:00:55,000 --> 00:00:56,000\nstuff like that.\n\n16\n00:00:56,000 --> 00:01:01,000\nLet's say we want to recognize words that are made up of these syllables in order,\n\n17\n00:01:01,000 --> 00:01:04,000\nor these syllables not in order but in any combination.\n\n18\n00:01:04,000 --> 00:01:06,000\nSo we set out to try it.\n\n19\n00:01:06,000 --> 00:01:09,000\nWe can have a bunch of do's or a bunch of re's or a bunch of mi's.\n\n20\n00:01:09,000 --> 00:01:16,000\nLet's say we're looking for all of the matching strings in mimi, rere, midore, doo-wop,\n\n21\n00:01:16,000 --> 00:01:18,000\nand we want to see which ones we get.\n\n22\n00:01:18,000 --> 00:01:25,000\nWe'd like to get mimi as 1, rere as another, midore, and then maybe do,\n\n23\n00:01:25,000 --> 00:01:26,000\njust sort of as a corner case,\n\n24\n00:01:26,000 --> 00:01:27,000\nbut mostly these 3,\n\n25\n00:01:27,000 --> 00:01:30,000\nbut we will be unpleasantly surprised.\n\n26\n00:01:30,000 --> 00:01:35,000\nWe would really expect something like mi+ to get mimi.\n\n27\n00:01:35,000 --> 00:01:37,000\nMaximum munch rule, why have you betrayed us?\n\n28\n00:01:37,000 --> 00:01:41,000\nIf you look over here, you'll see that actually everyone of these little musical syllables--\n\n29\n00:01:41,000 --> 00:01:45,000\n'mi', 'mi', 're', 're', 'mi', 'do', 're'--seem to come out separately. \n\n30\n00:01:45,000 --> 00:01:50,000\nWhy? Well, if you think about it, in the regular expression 'mi+\", \n\n31\n00:01:50,000 --> 00:01:58,000\nthe plus only effects the \"i\", so really this is getting mi, mii, miii--\n\n32\n00:01:58,000 --> 00:02:02,000\nan entire virtue of selfishness--rather than the thing that we wanted.\n\n33\n00:02:02,000 --> 00:02:09,000\nYou can actually see this over here at the end where do+ got us doo from doo-wop.\n\n34\n00:02:09,000 --> 00:02:14,000\nSo here, the + isn't applying to the right thing, isn't binding correctly.\n\n35\n00:02:14,000 --> 00:02:16,000\nThis isn't quite the right way to do it.\n\n36\n00:02:16,000 --> 00:02:18,000\nThis, however, is.\n\n37\n00:02:18,000 --> 00:02:22,000\nNote our use of the parenthesis in regular expressions--\n\n38\n00:02:22,000 --> 00:02:27,000\n(?:--marks the beginning of such a group--),\n\n39\n00:02:27,000 --> 00:02:30,000\nand then here in the middle we have do/re/mi.\n\n40\n00:02:30,000 --> 00:02:32,000\nAnything inside this group can be repeated 1 or more times.\n\n41\n00:02:32,000 --> 00:02:35,000\nThis gets us just the answer we were looking for.\n\n42\n00:02:35,000 --> 00:02:40,000\nFor a more thorough investigation of musical notes and the associated words,\n\n43\n00:02:40,000 --> 00:02:42,000\nI recommend The Sound of Music,\n\n44\n00:02:42,000 --> 00:02:47,000\nbut it's also worth pointing out that a very popular computer musical format or interface\n\n45\n00:02:47,000 --> 00:02:51,000\nM-I-D-I--MIDI, the musical instrument digital interface used for recording \n\n46\n00:02:51,000 --> 00:02:58,000\nthings like pianos or synthesizers or drum sets, is more or less exactly what we've seen here.\n\n47\n00:02:58,000 --> 00:03:02,000\nBasically, a list of notes and modifiers and combinations over and over again.\n\n48\n00:03:02,000 --> 00:03:07,000\nBy contrast, formats like MP3 or other audio compression approaches for recording voice,\n\n49\n00:03:07,000 --> 00:03:12,000\ndo not follow this general pattern, or at least they don't look like they do at first blush.\n\n", "id": 34001}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiC-gEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/32002", "type": "Nugget", "id": 32002}, {"nuggetType": "lecture", "name": "Fsm Simulator Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "b90e871b-f0ee-45d7-af29-533c6b06e89f", "name": "cs262_unit1_24_s_fsm-simulator", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGNSMAQw", "youtube_id": "NuaTSxUBSCY", "youtube_state": "done", "path": "Course/cs262/Media/18004", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nAlright, let's go through a possible answer together.\n\n2\n00:00:02,000 --> 00:00:06,000\nTo see if there's an outgoing edge, we'll just check to see if the \n\n3\n00:00:06,000 --> 00:00:08,000\ntuple (current, letter) is in edges.\n\n4\n00:00:08,000 --> 00:00:13,000\nIf so, our destination state can be obtained by just looking up \n\n5\n00:00:13,000 --> 00:00:15,000\nthe tuple (current, letter) in edges.\n\n6\n00:00:15,000 --> 00:00:19,000\nWe've already processed letter, the 0th element of string,\n\n7\n00:00:19,000 --> 00:00:24,000\nso we want to peel off the 0th character, retaining only the rest of them.\n\n8\n00:00:24,000 --> 00:00:29,000\nFor example, if the input was \"aaa111\", we've used the \"a\",\n\n9\n00:00:29,000 --> 00:00:31,000\nso now we want it to be just \"aa111\".\n\n10\n00:00:31,000 --> 00:00:36,000\nNow we just call ourselves recursively, call finite state machine simulation \n\n11\n00:00:36,000 --> 00:00:39,000\non the remaining string, starting from the destination node,\n\n12\n00:00:39,000 --> 00:00:42,000\nand the edges and accepting states are unchanged.\n\n13\n00:00:42,000 --> 00:00:45,000\nOtherwise, we fall off the finite state machine and return false.\n\n14\n00:00:45,000 --> 00:00:48,000\nAlright. The moment of truth.\n\n15\n00:00:48,000 --> 00:00:50,000\nWe want to print out this answer.\n\n16\n00:00:50,000 --> 00:00:56,000\nOh! Just as we expected, \"aaa111\" is accepted by this string.\n\n17\n00:00:56,000 --> 00:00:59,000\nWhat if I try to mix it up and make it something like \"a1a1a1\"?\n\n18\n00:00:59,000 --> 00:01:02,000\nThis should not be accepted by our finite state machine,\n\n19\n00:01:02,000 --> 00:01:05,000\nand it is not. The output changes to false.\n\n20\n00:01:05,000 --> 00:01:07,000\nHow about the empty string? Is that accepted?\n\n21\n00:01:07,000 --> 00:01:11,000\nIt's not because we're looking for \"a+1+\" so this should also be false.\n\n22\n00:01:11,000 --> 00:01:15,000\nAnd it is, but how about the smallest string we do accept, \"a1\"?\n\n23\n00:01:15,000 --> 00:01:18,000\nThat one is accepted. Great!\n\n24\n00:01:18,000 --> 00:01:22,000\nSo we can check any finite state machine to see if it accepts a string.\n\n25\n00:01:22,000 --> 00:01:24,000\nYou may have noticed as we were going through it, \n\n26\n00:01:24,000 --> 00:01:26,000\nthat edges and accepting never change.\n\n27\n00:01:26,000 --> 00:01:28,000\nI defined them once at the beginning of the file.\n\n28\n00:01:28,000 --> 00:01:35,000\nSo our finite state machine simulator is really just recursive in the input and the current state,\n\n29\n00:01:35,000 --> 00:01:38,000\nand that matches our intuition because those are the 2 fingers I was using \n\n30\n00:01:38,000 --> 00:01:40,000\nto work it out on paper.\n\n", "id": 18004}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiD-gEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/32003", "type": "Nugget", "id": 32003}, {"nuggetType": "lecture", "name": "Mis Msf Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "3e7efb1c-1859-4417-a984-a6f30363db90", "name": "cs262_unit1_27_s_mis-msf", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGLsXDA", "youtube_id": "-rCexC2MM7U", "youtube_state": "done", "path": "Course/cs262/Media/3003", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nAs always, I find the easiest way to answer such a question \n\n2\n00:00:04,000 --> 00:00:06,000\nis to draw the finite-state machine.\n\n3\n00:00:06,000 --> 00:00:09,000\nWe come in in state 1, and on a we go to state 2.\n\n4\n00:00:09,000 --> 00:00:12,000\nAnd on b we go to state 3,\n\n5\n00:00:12,000 --> 00:00:15,000\nand then from state 2 on c\n\n6\n00:00:15,000 --> 00:00:18,000\nwe go to 4, and state 3 on d we go to 5,\n\n7\n00:00:18,000 --> 00:00:22,000\nand 5 on e goes back to 2, and 5 on f \n\n8\n00:00:22,000 --> 00:00:26,000\ngoes to state 6, and 5 on g\n\n9\n00:00:26,000 --> 00:00:30,000\ngoes all the way back here to 1, and our only accepting state is 6.\n\n10\n00:00:30,000 --> 00:00:32,000\nWell, how can we get to state 6?\n\n11\n00:00:32,000 --> 00:00:35,000\nIf we go up here to the right,\n\n12\n00:00:35,000 --> 00:00:38,000\nthis is like the place of no return.\n\n13\n00:00:38,000 --> 00:00:41,000\nWe go here, and then there's no way to ever get back down or get to 6,\n\n14\n00:00:41,000 --> 00:00:43,000\nso we don't want to go to 4.\n\n15\n00:00:43,000 --> 00:00:45,000\nWe don't want to get to 2. \n\n16\n00:00:45,000 --> 00:00:49,000\nHow about instead if we go 1, 3, 5, 6 or b, d, f?\n\n17\n00:00:49,000 --> 00:00:51,000\nBut now I need to give another string \n\n18\n00:00:51,000 --> 00:00:54,000\nthat's different but that's also accepted.\n\n19\n00:00:54,000 --> 00:00:56,000\nOne way to do that would be to take this\n\n20\n00:00:56,000 --> 00:01:01,000\ngo to start back loop here, pass go, start again.\n\n21\n00:01:01,000 --> 00:01:04,000\n1, 3, 5, 1, 3, 5, 6. \n\n22\n00:01:04,000 --> 00:01:08,000\nSo b, d, g, b, d, f.\n\n23\n00:01:08,000 --> 00:01:11,000\nThose are 2 strings that are both accepted but that are different.\n\n24\n00:01:11,000 --> 00:01:16,000\nAnd if you are feeling exotic, you could actually have gone around these loops more times.\n\n25\n00:01:16,000 --> 00:01:20,000\nYou can add b, d, g, b, d, g, b, d, g at the beginning as often as you'd like\n\n26\n00:01:20,000 --> 00:01:22,000\nand make longer and longer strings.\n\n", "id": 3003}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiE-gEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/32004", "type": "Nugget", "id": 32004}, {"nuggetType": "lecture", "name": "Re Challenges Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "1e87c9a2-9803-431b-a729-20ea315c5eec", "name": "cs262_unit1_19_s_re-challenges", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGP5VDA", "youtube_id": "VNQbdDFXj4o", "youtube_state": "done", "path": "Course/cs262/Media/11006", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nWell, let's go through 1 possible answer together.\n\n2\n00:00:02,000 --> 00:00:05,000\nWe're assigning to the variable, regexp, a regular expression.\n\n3\n00:00:05,000 --> 00:00:07,000\nThose start with r and then double quotes.\n\n4\n00:00:07,000 --> 00:00:13,000\nThe first thing I want to do is match the function name. That will be [a - z]+.\n\n5\n00:00:13,000 --> 00:00:17,000\nNow I want to match immediately an opening parenthesis.\n\n6\n00:00:17,000 --> 00:00:20,000\nI will escape that opening parenthesis just to make sure that it works.\n\n7\n00:00:20,000 --> 00:00:24,000\nNow I can possibly have spaces or not, \n\n8\n00:00:24,000 --> 00:00:27,000\nso I could have 0 or more spaces, so I'll leave a space\n\n9\n00:00:27,000 --> 00:00:29,000\nand then put a star.\n\n10\n00:00:29,000 --> 00:00:33,000\nThe star will refer back to the space, and we can have 0 or more of these.\n\n11\n00:00:33,000 --> 00:00:36,000\nThen there's a numerical argument--1 or more digits--\n\n12\n00:00:36,000 --> 00:00:40,000\nand then more space, 0 or more, more spaces.\n\n13\n00:00:40,000 --> 00:00:44,000\nI close off the parenthesis, escaping the closed parenthesis just to make sure.\n\n14\n00:00:44,000 --> 00:00:48,000\nNow I'm done, and this regular expression works well in practice.\n\n", "id": 11006}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiF-gEM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/32005", "type": "Nugget", "id": 32005}, {"nuggetType": "lecture", "name": "Hyphenation Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "cae767ea-a367-4ff1-8b10-648079d33c4d", "name": "cs262_unit1_18_s_hyphenation", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGNuzAQw", "youtube_id": "T1_zUnGrnLM", "youtube_state": "done", "path": "Course/cs262/Media/23003", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nHere's a pretty good answer.\n\n2\n00:00:02,000 --> 00:00:08,000\nWe definitely want to match single words and then you can possibly have 1 hypen\n\n3\n00:00:08,000 --> 00:00:09,000\nand then you can have more letters if you like.\n\n4\n00:00:09,000 --> 00:00:14,000\nThis regular expression definitely matches well-liked.\n\n5\n00:00:14,000 --> 00:00:18,000\nIt also matches html--maybe the h, t, and m will match the first part, \n\n6\n00:00:18,000 --> 00:00:20,000\nand the l will match the second part.\n\n7\n00:00:20,000 --> 00:00:25,000\nIt definitely rejects a-b-c and a--b.\n\n8\n00:00:25,000 --> 00:00:29,000\nHowever, 1 problem with this regular expression is that it does not accept \n\n9\n00:00:29,000 --> 00:00:32,000\nsingle letter words like \"a\" or \"i\". \n\n10\n00:00:32,000 --> 00:00:35,000\nTo see why, just look at these 2 plus signs.\n\n11\n00:00:35,000 --> 00:00:38,000\nThis requires 1 or more letters here and 1 or more letters there,\n\n12\n00:00:38,000 --> 00:00:40,000\nThat's at least 2 letters.\n\n13\n00:00:40,000 --> 00:00:45,000\nWe might be tempted to fix it up by making 1 of these a star,\n\n14\n00:00:45,000 --> 00:00:49,000\nbut now we mistakenly accept things like just \"-a\".\n\n15\n00:00:49,000 --> 00:00:52,000\nNo letters here, the hypen, and then some more letters--\n\n16\n00:00:52,000 --> 00:00:54,000\nwell, that didn't work.\n\n17\n00:00:54,000 --> 00:00:55,000\nWhat if I try to make the other one a star?\n\n18\n00:00:55,000 --> 00:01:00,000\nWell, dual problem--now we'll mistakenly accept things like \"a-\".\n\n19\n00:01:00,000 --> 00:01:02,000\nWell, this is a bit of a challenge.\n\n20\n00:01:02,000 --> 00:01:08,000\nWhat we really want is for this hypen and the second word to be grouped together,\n\n21\n00:01:08,000 --> 00:01:10,000\nand either they're both there or they're not.\n\n22\n00:01:10,000 --> 00:01:16,000\nIt's as if I really want this question mark to apply to both the hyphen \n\n23\n00:01:16,000 --> 00:01:18,000\nand also the [a - z]+.\n\n24\n00:01:18,000 --> 00:01:22,000\nWe don't know how to do that yet, but you'll get a chance after we've learned how\n\n25\n00:01:22,000 --> 00:01:24,000\nto fix this up in the homework.\n\n", "id": 23003}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjpgQIM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/33001", "type": "Nugget", "id": 33001}, {"nuggetType": "lecture", "name": "Nondeterminism", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "c48aab30-21c5-43a3-b81f-e46bb172328d", "name": "cs262_unit1_31_l_nondeterminism", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGMg-DA", "youtube_id": "WpupPllKczo", "youtube_state": "done", "path": "Course/cs262/Media/8008", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nThese easy-to-write FSMs that we've been using\n\n2\n00:00:04,000 --> 00:00:07,000\nthat involve epsilon transitions or ambiguity--\n\n3\n00:00:07,000 --> 00:00:11,000\nremember, ambiguity means that I can go to 2 different places on the same input--\n\n4\n00:00:11,000 --> 00:00:16,000\nare formerly known as non-deterministic finite state machines.\n\n5\n00:00:16,000 --> 00:00:19,000\nNon-deterministic here just means that you may not know exactly\n\n6\n00:00:19,000 --> 00:00:21,000\nwhere to go or where to put your finger.\n\n7\n00:00:21,000 --> 00:00:24,000\nIt's not lock-step. You have choices.\n\n8\n00:00:24,000 --> 00:00:26,000\nYou have freedom.\n\n9\n00:00:26,000 --> 00:00:29,000\nA lock-step FSM with no epsilon transitions\n\n10\n00:00:29,000 --> 00:00:34,000\nand no ambiguity by contrast is called a deterministic finite state machine.\n\n11\n00:00:34,000 --> 00:00:36,000\nEverything is determined from the start.\n\n12\n00:00:36,000 --> 00:00:38,000\nGiven the finite state machine and the input, you always know\n\n13\n00:00:38,000 --> 00:00:40,000\nexactly what will happen.\n\n14\n00:00:40,000 --> 00:00:43,000\nOur finite state machine simulation procedure can handle\n\n15\n00:00:43,000 --> 00:00:46,000\ndeterministic finite state machines.\n\n16\n00:00:46,000 --> 00:00:49,000\nThat makes them really useful for implementing regular expressions\n\n17\n00:00:49,000 --> 00:00:51,000\nunder the hood.\n\n18\n00:00:51,000 --> 00:00:55,000\nLet me just show you an example of this non-determinism just to drive it home.\n\n19\n00:00:55,000 --> 00:00:57,000\nSuppose we were back here in this previous finite state machine,\n\n20\n00:00:57,000 --> 00:01:00,000\nbut now the input is 1-23.\n\n21\n00:01:00,000 --> 00:01:02,000\nWhere are we?\n\n22\n00:01:02,000 --> 00:01:05,000\nWe started here, and on a 1 we went here,\n\n23\n00:01:05,000 --> 00:01:08,000\nand then I guess if we're supposed to stay alive and there's a hyphen,\n\n24\n00:01:08,000 --> 00:01:11,000\nwe must have gone here and taken the hyphen.\n\n25\n00:01:11,000 --> 00:01:14,000\nAnd now there's a 2, but now this is really not obvious.\n\n26\n00:01:14,000 --> 00:01:17,000\nI could stay here on this self-loop for a 3,\n\n27\n00:01:17,000 --> 00:01:20,000\nor I could have gone back on this free epsilon transition\n\n28\n00:01:20,000 --> 00:01:25,000\nand done the self-loop here on a 3, so I could be in state 2 or state 5.\n\n29\n00:01:25,000 --> 00:01:28,000\nSince there isn't one single answer for where I could be,\n\n30\n00:01:28,000 --> 00:01:30,000\nthis is non-deterministic.\n\n31\n00:01:30,000 --> 00:01:34,000\nAs a bit of a fun aside, this notion of determinism\n\n32\n00:01:34,000 --> 00:01:39,000\nor non-determinism can be related to the question of free will in philosophy. \n\n33\n00:01:39,000 --> 00:01:42,000\nCan we actually make independent choices?\n\n34\n00:01:42,000 --> 00:01:45,000\nOr is everything preordained by the current state of the world\n\n35\n00:01:45,000 --> 00:01:51,000\nand forces acting on it, like a lock-step game of billiards or snooker or pool?\n\n36\n00:01:51,000 --> 00:01:53,000\nSome philosophers will approach this by suggesting that we have \n\n37\n00:01:53,000 --> 00:01:57,000\nthe illusion of free will--that's a disconcerting thought--\n\n38\n00:01:57,000 --> 00:02:00,000\nwhich is handy for describing subjective experience.\n\n39\n00:02:00,000 --> 00:02:02,000\nWe certainly often feel like we have free will.\n\n40\n00:02:02,000 --> 00:02:05,000\nRegardless of what's going on in the real world,\n\n41\n00:02:05,000 --> 00:02:07,000\nwe're going to see that something similar holds \n\n42\n00:02:07,000 --> 00:02:09,000\nfor finite state machines.\n\n43\n00:02:09,000 --> 00:02:12,000\nAlthough non-deterministic finite state machines look like they have\n\n44\n00:02:12,000 --> 00:02:14,000\nmuch more power and much more freedom,\n\n45\n00:02:14,000 --> 00:02:17,000\nanything that could be done with them could also be done\n\n46\n00:02:17,000 --> 00:02:19,000\nin our deterministic billiard ball world.\n\n47\n00:02:19,000 --> 00:02:23,000\nIn fact, you can watch me suck free will out of this world right now.\n\n48\n00:02:23,000 --> 00:02:26,000\nEvery non-deterministic finite state machine\n\n49\n00:02:26,000 --> 00:02:29,000\nhas a corresponding deterministic finite state machine\n\n50\n00:02:29,000 --> 00:02:33,000\nthat accepts exactly the same strings.\n\n51\n00:02:33,000 --> 00:02:37,000\nNon-deterministic finite state machines are not any more powerful\n\n52\n00:02:37,000 --> 00:02:39,000\nthan deterministic finite state machines.\n\n53\n00:02:39,000 --> 00:02:42,000\nThey're just more convenient.\n\n54\n00:02:42,000 --> 00:02:44,000\nIt's easier to write them down.\n\n55\n00:02:44,000 --> 00:02:46,000\nLet's see an example of this extraordinary claim.\n\n56\n00:02:46,000 --> 00:02:48,000\nSuppose we have this regular expression.\n\n57\n00:02:48,000 --> 00:02:51,000\nThere are only 2 strings in the language of this regular expression,\n\n58\n00:02:51,000 --> 00:02:55,000\nbut here I've drawn out a very elaborate finite state machine for it\n\n59\n00:02:55,000 --> 00:02:57,000\nthat has epsilon transitions coming out the wazoo. \n\n60\n00:02:57,000 --> 00:03:00,000\nThis is very non-deterministic. \n\n61\n00:03:00,000 --> 00:03:03,000\nWe definitely need to see an a, but then here these 2 epsilon transitions\n\n62\n00:03:03,000 --> 00:03:05,000\nrepresent the explicit choice.\n\n63\n00:03:05,000 --> 00:03:08,000\nDo I do the b, or do I skip over it?\n\n64\n00:03:08,000 --> 00:03:10,000\nOn the top road, we need to see the b.\n\n65\n00:03:10,000 --> 00:03:13,000\nOn the bottom road, we skip entirely past it.\n\n66\n00:03:13,000 --> 00:03:15,000\nAnd then in any event, we need to see the c.\n\n67\n00:03:15,000 --> 00:03:19,000\nI'm now going to write a deterministic finite state machine\n\n68\n00:03:19,000 --> 00:03:22,000\nthat does exactly the same thing, and I'm going to hint at\n\n69\n00:03:22,000 --> 00:03:24,000\nhow this conversion works.\n\n70\n00:03:24,000 --> 00:03:26,000\nWe'll see this again in just a minute.\n\n71\n00:03:26,000 --> 00:03:29,000\nAfter I see an a, I could be in 2, \n\n72\n00:03:29,000 --> 00:03:31,000\nor I could take the epsilon to 3.\n\n73\n00:03:31,000 --> 00:03:33,000\nI could have taken the epsilon down here to 6\n\n74\n00:03:33,000 --> 00:03:36,000\nor all the way over to 4, so there are 4 places\n\n75\n00:03:36,000 --> 00:03:38,000\nI could be in.\n\n76\n00:03:38,000 --> 00:03:40,000\nThat's a lot of fingers.\n\n77\n00:03:40,000 --> 00:03:44,000\nI'll just record all of them as the name for my new state, 2364.\n\n78\n00:03:44,000 --> 00:03:49,000\nFrom here, if I see a b and I survive--remember, finite state machines work\n\n79\n00:03:49,000 --> 00:03:54,000\nif there's any path that gets to the end--it must have been that I was in state 3,\n\n80\n00:03:54,000 --> 00:03:57,000\nat which point now I'm just in state 4.\n\n81\n00:03:57,000 --> 00:04:03,000\nBy contrast, if I was back here and I saw a c,\n\n82\n00:04:03,000 --> 00:04:06,000\nit must have been that I was in state 4, and now I'm in state 5.\n\n83\n00:04:06,000 --> 00:04:10,000\nAnd then finally, if I'm in state 4 and I see a c,\n\n84\n00:04:10,000 --> 00:04:13,000\nI end up here, so this deterministic finite state machine\n\n85\n00:04:13,000 --> 00:04:17,000\naccepts the same language as the one above.\n\n86\n00:04:17,000 --> 00:04:20,000\nThe 2 strings, a, b, c, and a, c\n\n87\n00:04:20,000 --> 00:04:23,000\nare both in it, but it does not have\n\n88\n00:04:23,000 --> 00:04:25,000\nepsilon transitions or ambiguity.\n\n89\n00:04:25,000 --> 00:04:29,000\nIn any particular node, there are never 2 edges going out labeled a,\n\n90\n00:04:29,000 --> 00:04:31,000\nand there are never epsilon transitions.\n\n91\n00:04:31,000 --> 00:04:34,000\nLet's see another example of how this works.\n\n92\n00:04:34,000 --> 00:04:37,000\nAgain, I'm going to build a deterministic machine\n\n93\n00:04:37,000 --> 00:04:40,000\nwhere every state in the deterministic machine\n\n94\n00:04:40,000 --> 00:04:44,000\ncorresponds to a set of states\n\n95\n00:04:44,000 --> 00:04:46,000\nin the non-deterministic one.\n\n96\n00:04:46,000 --> 00:04:50,000\nAgain, to restate that, you give me a non-deterministic machine,\n\n97\n00:04:50,000 --> 00:04:53,000\nI'm going to build you a deterministic machine d\n\n98\n00:04:53,000 --> 00:04:57,000\nthat accepts the same language, and the way I'll do it is \n\n99\n00:04:57,000 --> 00:05:01,000\nevery state in d is going to correspond to a set of states\n\n100\n00:05:01,000 --> 00:05:04,000\nin the non-deterministic machine you gave me.\n\n", "id": 8008}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjTiQIM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/34003", "type": "Nugget", "id": 34003}, {"nuggetType": "lecture", "name": "Fsm Interpretation Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "0640b908-012b-4dc9-b74c-472b2d9e7997", "name": "cs262_unit1_25_s_fsm-interpretation", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGLqRAgw", "youtube_id": "1mHmI4Wbdko", "youtube_state": "done", "path": "Course/cs262/Media/35002", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nWell, let's go through one way to do it together.\n\n2\n00:00:02,000 --> 00:00:05,000\nI find it helpful to draw the finite state machine first.\n\n3\n00:00:05,000 --> 00:00:07,000\nSo here's my start state. We'll call it 1.\n\n4\n00:00:07,000 --> 00:00:12,000\nAnd because \"q * \" accepts the empty string, it also has to be an accepting state,\n\n5\n00:00:12,000 --> 00:00:17,000\nbut I can see any number of q's that I like and still accept,\n\n6\n00:00:17,000 --> 00:00:22,000\nso it looks like we've got 1 state, 1 edge, and our state is also an accepting state.\n\n7\n00:00:22,000 --> 00:00:26,000\nSo just to show that this program really works, we're going to run it in the interpreter.\n\n8\n00:00:26,000 --> 00:00:30,000\nOver here, I have defined edges, just as we suggested.\n\n9\n00:00:30,000 --> 00:00:32,000\nIn state 1 on a 'q', you loop back to state 1.\n\n10\n00:00:32,000 --> 00:00:36,000\nState 1 is our start state, and it's also our accepting state.\n\n11\n00:00:36,000 --> 00:00:41,000\nLet's try out our simulation on a bunch of q's, the empty string, and a bunch of q's \n\n12\n00:00:41,000 --> 00:00:42,000\nwith an evil interloper.\n\n13\n00:00:42,000 --> 00:00:47,000\nWe've got this 'A' hiding here. This should be true. True. False.\n\n14\n00:00:47,000 --> 00:00:48,000\nOh, and it is.\n\n15\n00:00:48,000 --> 00:00:51,000\nSo our finite state machine simulator matches our intuition exactly.\n\n", "id": 35002}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBihmQIM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/36001", "type": "Nugget", "id": 36001}, {"nuggetType": "lecture", "name": "Phone It In", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "8808389d-2ff4-4e2a-8553-e26266783265", "name": "cs262_unit1_29_p_phone-it-in", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGOCzAQw", "youtube_id": "k9cg24x1IYI", "youtube_state": "done", "path": "Course/cs262/Media/23008", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nSuppose we want to use regular expressions\n\n2\n00:00:02,000 --> 00:00:04,000\nto recognize phone numbers with or without hyphens.\n\n3\n00:00:04,000 --> 00:00:07,000\nThis is super common in electronic commerce.\n\n4\n00:00:07,000 --> 00:00:11,000\nHere I  have 2 positive examples from the American phone system,\n\n5\n00:00:11,000 --> 00:00:14,000\n123-4567 and 1234567.\n\n6\n00:00:14,000 --> 00:00:17,000\nBut we want our business to be international, \n\n7\n00:00:17,000 --> 00:00:19,000\nso we also want to accept numbers in other formats,\n\n8\n00:00:19,000 --> 00:00:24,000\nlike these French telephone numbers, which have 5 groups of 2\n\n9\n00:00:24,000 --> 00:00:27,000\nif they're separated by hyphens or just 10 digits otherwise.\n\n10\n00:00:27,000 --> 00:00:32,000\nAnd in general, we want to allow any number of groups of any non-empty size\n\n11\n00:00:32,000 --> 00:00:36,000\nseparated by 1 hyphen where each group is 0 through 9+.\n\n12\n00:00:36,000 --> 00:00:40,000\nAnd my hint is you should remember to accept a super small phone number\n\n13\n00:00:40,000 --> 00:00:44,000\nlike 5--presumably from many years ago when there weren't that many phones--\n\n14\n00:00:44,000 --> 00:00:48,000\nbut do not accept -6 because there is nothing on the left of the hyphen.\n\n15\n00:00:48,000 --> 00:00:51,000\nThis problem is tricky, and you should submit via the interpreter\n\n16\n00:00:51,000 --> 00:00:56,000\nby defining a variable called regexp that encodes this.\n\n", "id": 23008}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiJoQIM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/37001", "type": "Nugget", "id": 37001}, {"nuggetType": "quiz", "name": "Breaking Up Strings", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjBuAIM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/40001", "type": "Nugget", "id": 40001}, {"nuggetType": "program", "name": "Selecting Substrings", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBj5zwIM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/43001", "suppliedCode": "# Selecting Substrings : Writing a Python Procedure\n\n# Let p and q each be strings containing two words separated by a space.\n\n# Examples:\n#    \"bell hooks\"\n#    \"grace hopper\"\n#    \"alonzo church\"\n\n# Write a procedure called myfirst_yoursecond(p,q) that returns True if the\n# first word in p equals the second word in q. Return False otherwise.\n\ndef myfirst_yoursecond(p,q):\n\n\n\n\n\n#print myfirst_yoursecond(\"bell hooks\", \"curer bell\")\n#>>> True\n\n", "type": "Nugget", "id": 43001}, {"nuggetType": "quiz", "name": "Inverting The Problem", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjk1wIM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/44004", "type": "Nugget", "id": 44004}, {"nuggetType": "quiz", "name": "Concatenation", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBia7wIM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/47002", "type": "Nugget", "id": 47002}, {"nuggetType": "program", "name": "Escaping The Escape", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBic7wIM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/47004", "suppliedCode": "# Tricky REs with ^ and \\\n\n# Assign to regexp a regular expression for double-quoted string literals that\n# allows for escaped double quotes.\n\n# Hint: Escape \" and \\\n# Hint: (?: (?: ) )\n\nimport re\n\nregexp = r''\n\n# regexp matches:\n\n#print re.findall(regexp,'\"I say, \\\\\"hello.\\\\\"\"') == ['\"I say, \\\\\"hello.\\\\\"\"']\n#>>> True\n\n\n# regexp does not match:\n\n#print re.findall(regexp,'\"\\\\\"') != ['\"\\\\\"']\n#>>> True\n\n", "type": "Nugget", "id": 47004}, {"nuggetType": "lecture", "name": "Phone It In Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "f3df9fd3-2505-43c2-bd53-f2a02c2194ce", "name": "cs262_unit1_29_s_phone-it-in", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGLNtDA", "youtube_id": "BsJZFxgYZpU", "youtube_state": "done", "path": "Course/cs262/Media/14003", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nWell, let's take a few stabs at it.\n\n2\n00:00:02,000 --> 00:00:04,000\nIt seems like we definitely want 0 through 9+\n\n3\n00:00:04,000 --> 00:00:06,000\nto get the first part of any phone number.\n\n4\n00:00:06,000 --> 00:00:08,000\nWhat about this regular expression?\n\n5\n00:00:08,000 --> 00:00:13,000\nWe have 0 through 9+, and then as many times as you like\n\n6\n00:00:13,000 --> 00:00:17,000\nwe have a hyphen, and then 0 through 9+ again\n\n7\n00:00:17,000 --> 00:00:19,000\nas kind of a group.\n\n8\n00:00:19,000 --> 00:00:21,000\nThis actually works quite well.\n\n9\n00:00:21,000 --> 00:00:23,000\nHowever, if we were to put a star here instead of a +,\n\n10\n00:00:23,000 --> 00:00:26,000\nthis one accepts -6 by just skipping this part\n\n11\n00:00:26,000 --> 00:00:30,000\nand doing this part once, -6, and then we're done.\n\n12\n00:00:30,000 --> 00:00:32,000\nWe don't like this.\n\n13\n00:00:32,000 --> 00:00:36,000\nAnd as we've mentioned, regular expressions admit room for creativity.\n\n14\n00:00:36,000 --> 00:00:38,000\nWhat if I want to do this interesting grouping at the beginning?\n\n15\n00:00:38,000 --> 00:00:44,000\nWhat if I say you can have as many of the 08-78-88- things as you want\n\n16\n00:00:44,000 --> 00:00:47,000\nas long as you end with some final numbers?\n\n17\n00:00:47,000 --> 00:00:49,000\nThis one also works.\n\n18\n00:00:49,000 --> 00:00:52,000\nYou may remember the hyphenated word problem we had from before.\n\n19\n00:00:52,000 --> 00:00:55,000\nThis hyphenated phone number problem is actually quite similar,\n\n20\n00:00:55,000 --> 00:00:58,000\nbut now that we know how to do grouping \n\n21\n00:00:58,000 --> 00:01:00,000\nwith parentheses, it's much easier to solve.\n\n", "id": 14003}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiC9wIM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/48002", "type": "Nugget", "id": 48002}, {"nuggetType": "lecture", "name": "More Fsm Encoding", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "None", "name": "26_s_more-fsm-encoding.mp4", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": "rejected: Duplicate video", "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGMOsBgw", "youtube_id": "pPN-g2-9KGY", "youtube_state": "failed", "path": "Course/cs262/Media/104003", "transcript": null, "id": 104003}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiF9wIM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/48005", "type": "Nugget", "id": 48005}, {"nuggetType": "program", "name": "Hyphenation", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjUhgMM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/50004", "suppliedCode": "# Regexp Details and Challenges\n\nimport re\n\n# Assign to the variable regexp a Python regular expression that matches\n# lowercase words (a-z) or singly-hyphenated lowercase words.\n\n# Hint: It may not be possible to get correctly - do your best!\n\nregexp = r\"\"\n\n\n# regexp matches:\n\n#print re.findall(regexp,\"well-liked\") == [\"well-liked\"]\n#>>> True\n\n#print re.findall(regexp,\"html\") == [\"html\"]\n#>>> True\n\n\n# regexp does not match:\n\n#print re.findall(regexp,\"a-b-c\") != [\"a-b-c\"]\n#>>> True\n\n#print re.findall(regexp,\"a--b\") != [\"a--b\"]\n#>>> True\n", "type": "Nugget", "id": 50004}, {"nuggetType": "quiz", "name": "Findall", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBihlgMM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/52001", "type": "Nugget", "id": 52001}, {"nuggetType": "quiz", "name": "Disjunction In Fsms", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjzpQMM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/54003", "type": "Nugget", "id": 54003}, {"nuggetType": "program", "name": "Fsm Simulator", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjbrQMM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/55003", "suppliedCode": "# FSM Simulation\n\nedges = {(1, 'a') : 2,\n         (2, 'a') : 2,\n         (2, '1') : 3,\n         (3, '1') : 3}\n\naccepting = [3]\n\ndef fsmsim(string, current, edges, accepting):\n    if string == \"\":\n        return current in accepting\n    else:\n        letter = string[0]\n        # QUIZ: You fill this out!\n        # Is there a valid edge?\n        # If so, take it.\n        # If not, return False.\n        # Hint: recursion.\n\n\n#print fsmsim(\"aaa111\",1,edges,accepting)\n# >>> True\n", "type": "Nugget", "id": 55003}, {"nuggetType": "quiz", "name": "Accepting States", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjBtQMM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/56001", "type": "Nugget", "id": 56001}, {"nuggetType": "program", "name": "Fsm Interpretation", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjl1AMM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/60005", "suppliedCode": "# FSM Interpretation\n\n# Define edges and accepting to encode r\"q*\". Name your start state 1.\n\nedges = {}\n\naccepting = []\n\n\ndef fsmsim(string, current, edges, accepting):\n    if string == \"\":\n        return current in accepting\n    else:\n        letter = string[0]\n        if (current, letter) in edges:\n            destination = edges[(current, letter)]\n            remaining_string = string[1:]\n            return fsmsim(remaining_string, destination, edges, accepting)\n        else:\n            return False\n\n\nprint fsmsim(\"\",1,edges,accepting)\n# >>> True\n\nprint fsmsim(\"q\",1,edges,accepting)\n# >>> True\n\nprint fsmsim(\"qq\",1,edges,accepting)\n# >>> True\n\nprint fsmsim(\"p\",1,edges,accepting)\n# >>> False\n", "type": "Nugget", "id": 60005}, {"nuggetType": "program", "name": "Mis Msf", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiy5AMM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/62002", "suppliedCode": "# FSM Interpretation\n\n# Provide s1 and s2 that are both accepted, but s1 != s2.\n\ns1 = \"\"\n\ns2 = \"\"\n\n\nedges = {(1,'a') : 2,\n         (1,'b') : 3,\n         (2,'c') : 4,\n         (3,'d') : 5,\n         (5,'c') : 2,\n         (5,'f') : 6,\n         (5,'g') : 1}\n\naccepting = [6]\n\n\ndef fsmsim(string, current, edges, accepting):\n    if string == \"\":\n        return current in accepting\n    else:\n        letter = string[0]\n        if (current, letter) in edges:\n            destination = edges[(current, letter)]\n            remaining_string = string[1:]\n            return fsmsim(remaining_string, destination, edges, accepting)\n        else:\n            return False\n\n\n#print fsmsim(s1,1,edges,accepting)\n# >>> True\n\n#print fsmsim(s2,1,edges,accepting)\n# >>> True\n\n#print s1 != s2\n# >>> True", "type": "Nugget", "id": 62002}, {"nuggetType": "lecture", "name": "Conclusion", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "9abf0153-a609-457e-b9bf-66502115e584", "name": "cs262_unit1_35_l_end", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGLZtDA", "youtube_id": "TmYmRt8wnEg", "youtube_state": "done", "path": "Course/cs262/Media/14006", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nWe've just finished learning about sets of strings,\n\n2\n00:00:04,000 --> 00:00:09,000\nregular languages, regular expressions, and finite state machines,\n\n3\n00:00:09,000 --> 00:00:12,000\na beautiful formalism and a lovely way of implementing it\n\n4\n00:00:12,000 --> 00:00:14,000\nin actual Python.\n\n5\n00:00:14,000 --> 00:00:18,000\nThis idea, this tool of regular expressions\n\n6\n00:00:18,000 --> 00:00:22,000\nspecifying sets of strings is a really powerful\n\n7\n00:00:22,000 --> 00:00:25,000\nand really expressive way of writing quite a few programs.\n\n8\n00:00:25,000 --> 00:00:28,000\nWe're going to see this come up later on in everything from\n\n9\n00:00:28,000 --> 00:00:32,000\nmail to web servers to web browsers\n\n10\n00:00:32,000 --> 00:00:36,000\nto writing our interpreter for JavaScript and HTML.\n\n11\n00:00:36,000 --> 00:00:38,000\nYou've learned quite a bit in Unit 1, and I'm really hoping \n\n12\n00:00:38,000 --> 00:00:42,000\nthat you'll stick with me and learn even more in Unit 2.\n\n", "id": 14006}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBi5iwQM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/67001", "type": "Nugget", "id": 67001}, {"nuggetType": "lecture", "name": "Tricky", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "8510fb6b-6d5b-48ca-a75a-479d73b8909a", "name": "cs262_unit1_36_l_tricky", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGJXFAww", "youtube_id": "3vBaYk7f2Ro", "youtube_state": "done", "path": "Course/cs262/Media/58005", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:03,000\nSo as we saw, this quiz was particularly tricky.\n\n2\n00:00:03,000 --> 00:00:06,000\nIt wasn't obvious how to work out the right answer.\n\n3\n00:00:06,000 --> 00:00:08,000\nWe're really interested in supporting phone numbers from \n\n4\n00:00:08,000 --> 00:00:11,000\na bunch of different countries or formats, but we're really only interested\n\n5\n00:00:11,000 --> 00:00:15,000\nin that hyphen if it's followed by more digits.\n\n6\n00:00:15,000 --> 00:00:18,000\nConceptually, you might think \"Wow, I really want to group \n\n7\n00:00:18,000 --> 00:00:23,000\nthe hyphen and the digits together and then have either all of them or none of them.\"\n\n8\n00:00:23,000 --> 00:00:26,000\nWe don't know how to do that just yet, but we will in a few more minutes,\n\n9\n00:00:26,000 --> 00:00:30,000\nand then you'll get a chance to show off your mastery in the homework.\n\n", "id": 58005}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiJmwQM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/69001", "type": "Nugget", "id": 69001}, {"nuggetType": "lecture", "name": "Conclusion", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "9abf0153-a609-457e-b9bf-66502115e584", "name": "cs262_unit1_35_l_end", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGLZtDA", "youtube_id": "TmYmRt8wnEg", "youtube_state": "done", "path": "Course/cs262/Media/14006", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nWe've just finished learning about sets of strings,\n\n2\n00:00:04,000 --> 00:00:09,000\nregular languages, regular expressions, and finite state machines,\n\n3\n00:00:09,000 --> 00:00:12,000\na beautiful formalism and a lovely way of implementing it\n\n4\n00:00:12,000 --> 00:00:14,000\nin actual Python.\n\n5\n00:00:14,000 --> 00:00:18,000\nThis idea, this tool of regular expressions\n\n6\n00:00:18,000 --> 00:00:22,000\nspecifying sets of strings is a really powerful\n\n7\n00:00:22,000 --> 00:00:25,000\nand really expressive way of writing quite a few programs.\n\n8\n00:00:25,000 --> 00:00:28,000\nWe're going to see this come up later on in everything from\n\n9\n00:00:28,000 --> 00:00:32,000\nmail to web servers to web browsers\n\n10\n00:00:32,000 --> 00:00:36,000\nto writing our interpreter for JavaScript and HTML.\n\n11\n00:00:36,000 --> 00:00:38,000\nYou've learned quite a bit in Unit 1, and I'm really hoping \n\n12\n00:00:38,000 --> 00:00:42,000\nthat you'll stick with me and learn even more in Unit 2.\n\n", "id": 14006}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiF8QQM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/80005", "type": "Nugget", "id": 80005}, {"nuggetType": "lecture", "name": "Meet The Assistant Instructor", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "21ea24a6-4390-4e4c-b910-7112ed390e5f", "name": "cs262_unit1_34_l_meet-the-assistant-instructor", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGPvMAww", "youtube_id": "OLc1cYJu_NU", "youtube_state": "done", "path": "Course/cs262/Media/59003", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nHi, I'm Peter Chapman.\n\n2\n00:00:02,000 --> 00:00:06,000\nLast semester I TA'd for CS101 where we built the search engine.\n\n3\n00:00:06,000 --> 00:00:08,000\nThis time around, we're going to build a web browser\n\n4\n00:00:08,000 --> 00:00:11,000\nusing the power of programming languages in CS262.\n\n5\n00:00:11,000 --> 00:00:15,000\nWhen I'm not working on my start-up search engine, searchwithpeter.info--\n\n6\n00:00:15,000 --> 00:00:18,000\nyou should check it out--I'm going to be helping you with homework answers\n\n7\n00:00:18,000 --> 00:00:21,000\nand answering questions in the forums,\n\n8\n00:00:21,000 --> 00:00:23,000\nso I'll see  you in class.\n\n", "id": 59003}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjYgAUM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/82008", "type": "Nugget", "id": 82008}, {"nuggetType": "lecture", "name": "Conclusion", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "9abf0153-a609-457e-b9bf-66502115e584", "name": "cs262_unit1_35_l_end", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGLZtDA", "youtube_id": "TmYmRt8wnEg", "youtube_state": "done", "path": "Course/cs262/Media/14006", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nWe've just finished learning about sets of strings,\n\n2\n00:00:04,000 --> 00:00:09,000\nregular languages, regular expressions, and finite state machines,\n\n3\n00:00:09,000 --> 00:00:12,000\na beautiful formalism and a lovely way of implementing it\n\n4\n00:00:12,000 --> 00:00:14,000\nin actual Python.\n\n5\n00:00:14,000 --> 00:00:18,000\nThis idea, this tool of regular expressions\n\n6\n00:00:18,000 --> 00:00:22,000\nspecifying sets of strings is a really powerful\n\n7\n00:00:22,000 --> 00:00:25,000\nand really expressive way of writing quite a few programs.\n\n8\n00:00:25,000 --> 00:00:28,000\nWe're going to see this come up later on in everything from\n\n9\n00:00:28,000 --> 00:00:32,000\nmail to web servers to web browsers\n\n10\n00:00:32,000 --> 00:00:36,000\nto writing our interpreter for JavaScript and HTML.\n\n11\n00:00:36,000 --> 00:00:38,000\nYou've learned quite a bit in Unit 1, and I'm really hoping \n\n12\n00:00:38,000 --> 00:00:42,000\nthat you'll stick with me and learn even more in Unit 2.\n\n", "id": 14006}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBi7iAUM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/83003", "type": "Nugget", "id": 83003}, {"nuggetType": "lecture", "name": "Save The World", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "2cfd8cea-abc2-4b19-af8d-bb6eeeab6db4", "name": "cs262_unit1_33_l_save-the-world", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGJx1DA", "youtube_id": "ITVuLKqHscM", "youtube_state": "done", "path": "Course/cs262/Media/15004", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:03,000\nLet's wrap up what we've learned in this unit.\n\n2\n00:00:03,000 --> 00:00:05,000\nStrings are just sequences of characters,\n\n3\n00:00:05,000 --> 00:00:10,000\nand manipulating strings is going to be critically important for making a web browser.\n\n4\n00:00:10,000 --> 00:00:13,000\nModern programming languages support regular expressions,\n\n5\n00:00:13,000 --> 00:00:17,000\nwhich are just a concise notation for specifying sets of strings,\n\n6\n00:00:17,000 --> 00:00:20,000\nand using regular expressions is more flexible\n\n7\n00:00:20,000 --> 00:00:24,000\nthan using fixed string matching like string.find.\n\n8\n00:00:24,000 --> 00:00:27,000\nWith regular expressions, we can define phone numbers,\n\n9\n00:00:27,000 --> 00:00:30,000\nwords, numbers, quoted strings,\n\n10\n00:00:30,000 --> 00:00:34,000\nand given a regular expression, we can search for and match it in a bigger string.\n\n11\n00:00:34,000 --> 00:00:39,000\nFinite state machines are a pictorial equivalent to regular expressions.\n\n12\n00:00:39,000 --> 00:00:43,000\nEvery regular expression, concatenation, plus, question mark, star,\n\n13\n00:00:43,000 --> 00:00:45,000\nhas an equivalent finite state machine.\n\n14\n00:00:45,000 --> 00:00:48,000\nAnd in fact, although I didn't show it, vice versa.\n\n15\n00:00:48,000 --> 00:00:51,000\nEvery regular expression has a finite state machine,\n\n16\n00:00:51,000 --> 00:00:53,000\nand every finite state machine has a regular expression.\n\n17\n00:00:53,000 --> 00:00:56,000\nAnd then every finite state machine can be converted\n\n18\n00:00:56,000 --> 00:00:58,000\nto a deterministic finite state machine.\n\n19\n00:00:58,000 --> 00:01:01,000\nNo epsilons, no ambiguity.\n\n20\n00:01:01,000 --> 00:01:03,000\nOnce we have a deterministic finite state machine,\n\n21\n00:01:03,000 --> 00:01:06,000\nwe can simulate it, and it turns out it's very easy--\n\n22\n00:01:06,000 --> 00:01:09,000\nabout 10 lines of recursive code--to see if a deterministic \n\n23\n00:01:09,000 --> 00:01:11,000\nfinite state machine accepts a string.\n\n24\n00:01:11,000 --> 00:01:13,000\nIn fact, you've written that code.\n\n25\n00:01:13,000 --> 00:01:16,000\nNow that you know how to implement regular expressions,\n\n26\n00:01:16,000 --> 00:01:19,000\ntake the regular expression, make a finite state machine,\n\n27\n00:01:19,000 --> 00:01:21,000\nmake it deterministic, call FSM sim.\n\n28\n00:01:21,000 --> 00:01:23,000\nWe'll just use Python's regular expression  library,\n\n29\n00:01:23,000 --> 00:01:25,000\nbut it's doing exactly those steps under the hood.\n\n30\n00:01:25,000 --> 00:01:27,000\nIt works the same way  you would.\n\n31\n00:01:27,000 --> 00:01:30,000\nIn our next exciting episode, we're going to use this knowledge\n\n32\n00:01:30,000 --> 00:01:33,000\nto specify important parts of HTML and JavaScript \n\n33\n00:01:33,000 --> 00:01:37,000\nlike string constants or hypertext tags.\n\n34\n00:01:37,000 --> 00:01:40,000\nAs the first step to writing our web browser,\n\n35\n00:01:40,000 --> 00:01:43,000\none great resource available to you as you revise this material\n\n36\n00:01:43,000 --> 00:01:46,000\nand work on the homework is the forums.\n\n37\n00:01:46,000 --> 00:01:48,000\nBe sure to check them out.\n\n38\n00:01:48,000 --> 00:01:50,000\nIf you were wondering about something, almost certainly someone else\n\n39\n00:01:50,000 --> 00:01:52,000\nwas wondering as well.\n\n40\n00:01:52,000 --> 00:01:55,000\nPost your question. Others will benefit from seeing it answered.\n\n41\n00:01:55,000 --> 00:01:57,000\nBe courteous, but be curious.\n\n42\n00:01:57,000 --> 00:01:59,000\nWe all benefit from questions.\n\n43\n00:01:59,000 --> 00:02:02,000\nAnd let me just leave you with this xkcd comic.\n\n44\n00:02:02,000 --> 00:02:05,000\nWhile they're talking about Pearl, everything said applies to Python,\n\n45\n00:02:05,000 --> 00:02:09,000\nand soon  you will be using regular expressions to save the world.\n\n", "id": 15004}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjopwUM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/87016", "type": "Nugget", "id": 87016}, {"nuggetType": "lecture", "name": "Designing Javascript", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "43a1c4de-f72c-4aee-9af2-f1a03e757c31", "name": "cs262_unit1_39_l_designing-javascript", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGO34BAw", "youtube_id": "8v9bwknKW2E", "youtube_state": "done", "path": "Course/cs262/Media/81005", "transcript": "\ufeff", "id": 81005}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjErwUM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/88004", "type": "Nugget", "id": 88004}, {"nuggetType": "lecture", "name": "Regular Expressions At Mozilla", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "080b805d-b0f8-4f5d-affa-325c80ef2bf8", "name": "cs262_unit1_37_l_regular-expressions-at-mozilla", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGMOvBQw", "youtube_id": "PzC8NXUZCYQ", "youtube_state": "done", "path": "Course/cs262/Media/88003", "transcript": "\ufeff", "id": 88003}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBj6xgUM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/91002", "type": "Nugget", "id": 91002}, {"nuggetType": "quiz", "name": "Nondet To Det", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjozgUM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/92008", "type": "Nugget", "id": 92008}, {"nuggetType": "lecture", "name": "Fsm Evolution Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "deeea393-68e6-4b0b-a57e-01b03680fea4", "name": "cs262_unit1_12_s_fsm-evolution", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGOJdDA", "youtube_id": "CnzEljM2k8A", "youtube_state": "done", "path": "Course/cs262/Media/12002", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nWell, here's one way to do it.\n\n2\n00:00:02,000 --> 00:00:09,000\nIn state 2, I could put another edge for a - z,\n\n3\n00:00:09,000 --> 00:00:19,000\nand now if there's a new input, like abc1, we would start here, a, b, c, 1, and accept.\n\n4\n00:00:19,000 --> 00:00:25,000\nHowever, there's an alternative answer where we add this edge to state 1,\n\n5\n00:00:25,000 --> 00:00:27,000\nstill labeled a - z.\n\n6\n00:00:27,000 --> 00:00:34,000\nNow if we see the abc1, it's a, b, c, 1.\n\n7\n00:00:34,000 --> 00:00:39,000\nBoth of these approaches work, and you'll just have to decide which one you like more.\n\n8\n00:00:39,000 --> 00:00:41,000\nThis is an instance of creativity.\n\n9\n00:00:41,000 --> 00:00:44,000\nTypically in computer science, we prefer the green solution \n\n10\n00:00:44,000 --> 00:00:48,000\nbecause the red solution is a little ambiguous.\n\n11\n00:00:48,000 --> 00:00:53,000\nHere in state 1, we have 2 edges going out of state 1, both labeled a - z.\n\n12\n00:00:53,000 --> 00:00:54,000\nThat could get a bit confusing.\n\n13\n00:00:54,000 --> 00:00:58,000\nBy contrast in the green solution--solution going off of state 2, \n\n14\n00:00:58,000 --> 00:01:00,000\nwe don't see as much.\n\n15\n00:01:00,000 --> 00:01:03,000\nWe can either transition here on 0 - 9 or transition on a - z, \n\n16\n00:01:03,000 --> 00:01:05,000\nbut we have to always know just what to do.\n\n", "id": 12002}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjS1gUM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/93010", "type": "Nugget", "id": 93010}, {"nuggetType": "quiz", "name": "Split", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBih5gUM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/95009", "type": "Nugget", "id": 95009}, {"nuggetType": "lecture", "name": "One Or More", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "072d4e90-3e03-4d32-b636-1756714e446b", "name": "cs262_unit1_09_s_one-or-more", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGOqEAQw", "youtube_id": "VTK-8AnbF6A", "youtube_state": "done", "path": "Course/cs262/Media/17002", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:06,000\nA good way to get started with such a problem is to write out what sorts of strings are matched.\n\n2\n00:00:06,000 --> 00:00:19,000\nThere are things like 1 space 1, 1 space 123, because of this plus, 2 space 456, and so on.\n\n3\n00:00:19,000 --> 00:00:22,000\nOne of the things that we notice quickly is that they all have a space,\n\n4\n00:00:22,000 --> 00:00:26,000\nthey all start with a single digit, and they don't have any letters in them.\n\n5\n00:00:26,000 --> 00:00:29,000\nIs a1 space 2 part of the possible return value?\n\n6\n00:00:29,000 --> 00:00:33,000\nWell, it would have to match this regular expression and be in the string.\n\n7\n00:00:33,000 --> 00:00:36,000\nIt's in the string but it doesn't match this regular expression,\n\n8\n00:00:36,000 --> 00:00:40,000\nbecause it starts with an \"a\" and none of our things start with an \"a.\"\n\n9\n00:00:40,000 --> 00:00:42,000\nHow about 1 space 2? That looks pretty good. \n\n10\n00:00:42,000 --> 00:00:47,000\nWe have 1 space 1, and we could pick a different digit, and it's in the string.\n\n11\n00:00:47,000 --> 00:00:50,000\nIt could be a part of our return value.\n\n12\n00:00:50,000 --> 00:00:55,000\n1 space 2b--it is in the string, but we never have any letters in this regular expression.\n\n13\n00:00:55,000 --> 00:00:57,000\nIt doesn't match.\n\n14\n00:00:57,000 --> 00:01:01,000\n2 space 3--this has the right format. It matches our regular expression.\n\n15\n00:01:01,000 --> 00:01:05,000\nBut it's not actually in the haystack string, so it can't be part of the return value.\n\n16\n00:01:05,000 --> 00:01:08,000\n44--this has the wrong format. We need a space in the middle.\n\n17\n00:01:08,000 --> 00:01:13,000\n3 space 44--this has the right format, it matches our regular expression,\n\n18\n00:01:13,000 --> 00:01:17,000\nand it actually occurs in the string. Great.\n\n19\n00:01:17,000 --> 00:01:21,000\n3 space 44d--this has the wrong format. Again, we're not matching any letters.\n\n20\n00:01:21,000 --> 00:01:24,000\nSo just these two.\n\n", "id": 17002}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjT_QUM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/98003", "type": "Nugget", "id": 98003}, {"nuggetType": "lecture", "name": "Split Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "7d0c99a7-7f7f-4b62-9652-b62799026275", "name": "cs262_unit1_03_s_split", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGMllDA", "youtube_id": "LzbcrMY674k", "youtube_state": "done", "path": "Course/cs262/Media/13001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nFor the first one, Python is fun, there is a space here and a space there.\n\n2\n00:00:04,000 --> 00:00:08,000\nThere will be three elements in the return list--Python, is, and fun.\n\n3\n00:00:08,000 --> 00:00:13,000\nThis next one reminds us that split only splits on spaces.\n\n4\n00:00:13,000 --> 00:00:16,000\nWe might be tempted to break up July and August, \n\n5\n00:00:16,000 --> 00:00:18,000\nbut the split function won't. \n\n6\n00:00:18,000 --> 00:00:24,000\nThere are only two elements of the return list--\"July-August\" and \"1842.\"\n\n7\n00:00:24,000 --> 00:00:29,000\nFinally, down here we might like to break this up into 6 times 9 equals 42,\n\n8\n00:00:29,000 --> 00:00:32,000\nbut officially there are no spaces in this string.\n\n9\n00:00:32,000 --> 00:00:36,000\nWe'll just get out a singleton list--a list containing one element, the original string.\n\n10\n00:00:36,000 --> 00:00:41,000\n\"July-August 1842\" is probably within a year of when Ada Lovelace wrote\n\n11\n00:00:41,000 --> 00:00:45,000\nthe first computer program for the difference engine or analytic engine at the time.\n\n12\n00:00:45,000 --> 00:00:47,000\nIt was to compute some mathematics.\n\n13\n00:00:47,000 --> 00:00:51,000\nAlso, if you're not sure why 6 times 9 would be 42--don't panic.\n\n14\n00:00:51,000 --> 00:00:54,000\nBut you may want to check out the works of Douglas Adams.\n\n", "id": 13001}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiLlQYM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/101003", "type": "Nugget", "id": 101003}, {"nuggetType": "lecture", "name": "Representing A Fsm", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "1ba7d880-9e46-4c1c-8cef-338871d08dd6", "name": "cs262_unit1_23_l_representing-a-fsm", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGNKMAQw", "youtube_id": "gbGCcDfQBEE", "youtube_state": "done", "path": "Course/cs262/Media/18002", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:03,000\nLet's zoom back to finite state machines at 88 miles an hour.\n\n2\n00:00:03,000 --> 00:00:08,000\nHere's a finite state machine that corresponds to the regular expression \"a+1+\".\n\n3\n00:00:08,000 --> 00:00:13,000\nLet's just verify that by tracing out the input, aa1, on this finite state machine.\n\n4\n00:00:13,000 --> 00:00:15,000\nWe start in the start state. We haven't seen anything yet.\n\n5\n00:00:15,000 --> 00:00:17,000\nWe see the a. We're in state 2. \n\n6\n00:00:17,000 --> 00:00:21,000\nWe see the a, self-loop back to state 2. We see the 1. We're in state 3.\n\n7\n00:00:21,000 --> 00:00:25,000\nOh! State 3 is an accepting state. Ha-za! \n\n8\n00:00:25,000 --> 00:00:29,000\nSurprisingly, this super high-tech sounding \"tracing with my finger\" approach\n\n9\n00:00:29,000 --> 00:00:35,000\nis actually pretty much exactly what computers do under the hood to check strings\n\n10\n00:00:35,000 --> 00:00:38,000\nagainst regular expressions or evaluate finite state machines.\n\n11\n00:00:38,000 --> 00:00:42,000\nYou really only have to keep track of where you are in the input and which state you're in\n\n12\n00:00:42,000 --> 00:00:44,000\nand not much else.\n\n13\n00:00:44,000 --> 00:00:45,000\nSo let's do this together.\n\n14\n00:00:45,000 --> 00:00:49,000\nWe'll write a computer program in Python to check to see if a finite state machine \n\n15\n00:00:49,000 --> 00:00:51,000\naccepts a string.\n\n16\n00:00:51,000 --> 00:00:55,000\nSo if I somehow give it this finite state machine an aa1 as input, \n\n17\n00:00:55,000 --> 00:00:57,000\nit should say, true.\n\n18\n00:00:57,000 --> 00:01:02,000\nIf I instead give it aa1b, it should say false because that string is not accepted.\n\n19\n00:01:02,000 --> 00:01:06,000\nBut the first big design decision is, how do we represent this finite state machine?\n\n20\n00:01:06,000 --> 00:01:12,000\nBy now, we know how to pass a Python program a number or a string or a list,\n\n21\n00:01:12,000 --> 00:01:15,000\nbut how do I pass in a picture?\n\n22\n00:01:15,000 --> 00:01:19,000\nWell, for the states 1, 2, 3, presumably, I could just pass in a list of the states.\n\n23\n00:01:19,000 --> 00:01:22,000\nIt's these edges, these arrows that go anywhere.\n\n24\n00:01:22,000 --> 00:01:23,000\nThat's what really matters.\n\n25\n00:01:23,000 --> 00:01:28,000\nWhat we really want to know from an edge is, if I'm in state 1, and the next input is \"a\",\n\n26\n00:01:28,000 --> 00:01:30,000\nwhere do I go?\n\n27\n00:01:30,000 --> 00:01:35,000\nSo let's use Python dictionaries or maps to do this.\n\n28\n00:01:35,000 --> 00:01:38,000\nI'll make a Python dictionary or map called edges,\n\n29\n00:01:38,000 --> 00:01:42,000\nand I'll just pass in my current state and the input letter,\n\n30\n00:01:42,000 --> 00:01:45,000\nand it will give me the new state at the end.\n\n31\n00:01:45,000 --> 00:01:51,000\nBefore we dive into it though, let's have a little refresher on maps and also tuples.\n\n32\n00:01:51,000 --> 00:01:54,000\nYou may have seen them before in a previous CS class,\n\n33\n00:01:54,000 --> 00:01:56,000\nbut if you haven't, I'll just go over them right now.\n\n34\n00:01:56,000 --> 00:02:01,000\nYou make a new map or dictionary in Python using open curly braces \n\n35\n00:02:01,000 --> 00:02:02,000\nand closed curly braces.\n\n36\n00:02:02,000 --> 00:02:09,000\nThe purpose of a map is to associate 1 thing with another.\n\n37\n00:02:09,000 --> 00:02:12,000\nFor example, here I'm making a map that's going to help me keep track of which things\n\n38\n00:02:12,000 --> 00:02:16,000\nin the world are flowers because I might easily forget this critical knowledge.\n\n39\n00:02:16,000 --> 00:02:22,000\nSo I can update my map by saying, oh, 'roses' should map to true in the is_flower dictionary.\n\n40\n00:02:22,000 --> 00:02:25,000\nBut 'dog' is not a flower, so that should map to false.\n\n41\n00:02:25,000 --> 00:02:29,000\nThen if I go look it up later, is_flower of 'rose' will return true.\n\n42\n00:02:29,000 --> 00:02:32,000\nThere's an alternative notation for specifying a map.\n\n43\n00:02:32,000 --> 00:02:35,000\nInside the curly braces you use to make a new map, you can actually just put \n\n44\n00:02:35,000 --> 00:02:41,000\nall of the bindings--'rose' maps to true. Colon. 'Dog' maps to false.\n\n45\n00:02:41,000 --> 00:02:42,000\nThere's a colon in the center.\n\n46\n00:02:42,000 --> 00:02:46,000\nNow at this point you're probably thinking, what's in a name?\n\n47\n00:02:46,000 --> 00:02:50,000\nIs this word, 'rose' really important, or would a 'rose' by any other name still smell as sweet?\n\n48\n00:02:50,000 --> 00:02:54,000\nWell, we may be able to tell synonyms, but Python cannot.\n\n49\n00:02:54,000 --> 00:02:59,000\nSo if I try something like, is_flower 'juliet', that's not defined in this mapping,\n\n50\n00:02:59,000 --> 00:03:03,000\nso we will get some sort of key error element not found exception.\n\n51\n00:03:03,000 --> 00:03:06,000\nFor Python dictionaries, you need to get the name exactly right.\n\n52\n00:03:06,000 --> 00:03:11,000\nDictionaries and mappings are synonyms. They both refer to the same thing.\n\n53\n00:03:11,000 --> 00:03:14,000\nA Python tuple is just an immutable list.\n\n54\n00:03:14,000 --> 00:03:16,000\nImmutable means you cannot change it.\n\n55\n00:03:16,000 --> 00:03:19,000\nOnce you make it, it is etched in stone.\n\n56\n00:03:19,000 --> 00:03:23,000\nFor example, I can make a tuple to hold the Cartesian coordinates of some object.\n\n57\n00:03:23,000 --> 00:03:26,000\nMaybe my point on the grid is at (1, 5).\n\n58\n00:03:26,000 --> 00:03:29,000\nI can access its elements the same way I would for a list.\n\n59\n00:03:29,000 --> 00:03:33,000\nThe 0th part of point is 1. The 1th part of point is 5.\n\n60\n00:03:33,000 --> 00:03:36,000\nAnd while Cartesian points may not be super exciting, \n\n61\n00:03:36,000 --> 00:03:41,000\nmany of you may have done navigation or taken long trips and used GPS coordinates\n\n62\n00:03:41,000 --> 00:03:43,000\nor longitude and latitude.\n\n63\n00:03:43,000 --> 00:03:46,000\nThe Taj Mahal is a UNESCO world-heritage site in India.\n\n64\n00:03:46,000 --> 00:03:50,000\nThese are its actual GPS coordinates. Go check it out!\n\n", "id": 18002}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiqtAYM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/105002", "type": "Nugget", "id": 105002}, {"nuggetType": "quiz", "name": "One Or More", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiTvAYM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/106003", "type": "Nugget", "id": 106003}, {"nuggetType": "lecture", "name": "Single Digits Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "ac5c8935-aecf-4081-8648-2e010065d1c5", "name": "cs262_unit1_05_s_single-digits", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGOmEAQw", "youtube_id": "TLKkPdMu9I0", "youtube_state": "done", "path": "Course/cs262/Media/17001", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nOne way to reason about this is just to write out all of the strings that this matches--\n\n2\n00:00:04,000 --> 00:00:11,000\n0, 1, 2--all the way up to 9. Ten different 1-digit strings.\n\n3\n00:00:11,000 --> 00:00:15,000\nZero is certainly in this set, so 0 matches 0 through 9.\n\n4\n00:00:15,000 --> 00:00:18,000\nOne matches 0 through 9. Remember the interpretation is everything \n\n5\n00:00:18,000 --> 00:00:22,000\nbetween and including the beginning up to and including the end.\n\n6\n00:00:22,000 --> 00:00:27,000\nTen, however, is a 2-letter string. It's too big.\n\n7\n00:00:27,000 --> 00:00:32,000\nThis regular expression only matches ten strings that are each 1 letter long.\n\n8\n00:00:32,000 --> 00:00:36,000\nThis one doesn't match. Similarly, 11 is just too large.\n\n9\n00:00:36,000 --> 00:00:43,000\n05 is very tempting, but regular expressions are string equations, not mathematical equations.\n\n10\n00:00:43,000 --> 00:00:47,000\nWhile 5 and 05 might have the same mathematical meaning,\n\n11\n00:00:47,000 --> 00:00:50,000\nour regular expression, which is concerned with strings,\n\n12\n00:00:50,000 --> 00:00:55,000\nmatches this one-letter string \"5\" but not this two-letter string \"05\".\n\n13\n00:00:55,000 --> 00:00:59,000\nThen \"9\"--well, that's right on the border. We totally match it.\n\n14\n00:00:59,000 --> 00:01:02,000\n\"Isak Dinesen\"--we don't match this for a number of reasons.\n\n15\n00:01:02,000 --> 00:01:07,000\nFirst, it doesn't contain 0 through 9, and second it's much too long.\n\n16\n00:01:07,000 --> 00:01:12,000\n\"Isak Dinesen\" was a pseudonym adopted by Karen Dinesen, a Danish author\n\n17\n00:01:12,000 --> 00:01:16,000\nwho wrote Out of Africa.\n\n18\n00:01:16,000 --> 00:01:18,000\nLet's imagine that's Africa.\n\n19\n00:01:18,000 --> 00:01:22,000\nThese regular expressions sound super cool, \n\n20\n00:01:22,000 --> 00:01:25,000\nand I'm going to show you how to use them in Python programs,\n\n21\n00:01:25,000 --> 00:01:28,000\nbut that's going to require one more step.\n\n", "id": 17001}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjJ0wYM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/109001", "type": "Nugget", "id": 109001}, {"nuggetType": "lecture", "name": "Disjunction Construction Solution", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "951a944b-cadc-436b-a45c-7f30e93197eb", "name": "cs262_unit1_15_s_disjunction-construction", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGMY-DA", "youtube_id": "prJPbvWdkbw", "youtube_state": "done", "path": "Course/cs262/Media/8006", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:02,000\nWell, here's one possible answer.\n\n2\n00:00:02,000 --> 00:00:07,000\nThe regular expression starts with r and then quotes, with either one to match ab.\n\n3\n00:00:07,000 --> 00:00:10,000\nWe mentioned before that any character that was left alone is matched exactly\n\n4\n00:00:10,000 --> 00:00:14,000\nor [0 - 9]+.\n\n", "id": 8006}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBix2wYM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/110001", "type": "Nugget", "id": 110001}, {"nuggetType": "lecture", "name": "Conclusion", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "9abf0153-a609-457e-b9bf-66502115e584", "name": "cs262_unit1_35_l_end", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch0LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGLZtDA", "youtube_id": "TmYmRt8wnEg", "youtube_state": "done", "path": "Course/cs262/Media/14006", "transcript": "\ufeff1\n00:00:00,000 --> 00:00:04,000\nWe've just finished learning about sets of strings,\n\n2\n00:00:04,000 --> 00:00:09,000\nregular languages, regular expressions, and finite state machines,\n\n3\n00:00:09,000 --> 00:00:12,000\na beautiful formalism and a lovely way of implementing it\n\n4\n00:00:12,000 --> 00:00:14,000\nin actual Python.\n\n5\n00:00:14,000 --> 00:00:18,000\nThis idea, this tool of regular expressions\n\n6\n00:00:18,000 --> 00:00:22,000\nspecifying sets of strings is a really powerful\n\n7\n00:00:22,000 --> 00:00:25,000\nand really expressive way of writing quite a few programs.\n\n8\n00:00:25,000 --> 00:00:28,000\nWe're going to see this come up later on in everything from\n\n9\n00:00:28,000 --> 00:00:32,000\nmail to web servers to web browsers\n\n10\n00:00:32,000 --> 00:00:36,000\nto writing our interpreter for JavaScript and HTML.\n\n11\n00:00:36,000 --> 00:00:38,000\nYou've learned quite a bit in Unit 1, and I'm really hoping \n\n12\n00:00:38,000 --> 00:00:42,000\nthat you'll stick with me and learn even more in Unit 2.\n\n", "id": 14006}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiZ4wYM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/111001", "type": "Nugget", "id": 111001}, {"nuggetType": "program", "name": "Disjunction Construction", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiB6wYM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/112001", "suppliedCode": "# Disjunction Construction\n\nimport re\n\n# Assign to the variable regexp a regular expression that matches either the\n# exact string ab or one or more digits.\n\nregexp = r\"\"\n\n# regexp matches:\n\n#print re.findall(regexp,\"ab\") == [\"ab\"]\n#>>> True\n\n#print re.findall(regexp,\"1\") == [\"1\"]\n#>>> True\n\n#print re.findall(regexp,\"123\") == [\"123\"]\n#>>> True\n\n\n# regexp does not match:\n\n#print re.findall(regexp,\"a\") != [\"a\"]\n#>>> True\n\n#print re.findall(regexp,\"abc\") != [\"abc\"]\n#>>> True\n\n#print re.findall(regexp,\"abc123\") != [\"abc123\"]\n#>>> True ", "type": "Nugget", "id": 112001}, {"nuggetType": "program", "name": "Phone It In", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjp8gYM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/113001", "suppliedCode": "# Cumulative Recap!\n\n# Suppose we want to recognize phone numbers with or without hyphens. The\n# regular expression you give should work for any number of groups of any (non-\n# empty) size, separated by 1 hyphen. Each group is [0-9]+.\n\n# Hint: Accept \"5\" but not \"-6\"\n\nimport re\n\nregexp = r\"\"\n\n# regexp matches:\n\n#print re.findall(regexp,\"123-4567\") == [\"123-4567\"]\n#>>> True\n\n#print re.findall(regexp,\"1234567\") == [\"1234567\"]\n#>>> True\n\n#print re.findall(regexp,\"08-78-88-88-88\") == [\"08-78-88-88-88\"]\n#>>> True\n\n#print re.findall(regexp,\"0878888888\") == [\"0878888888\"]\n#>>> True\n\n# regexp does not match:\n\n#print re.findall(regexp,\"-6\") != [\"-6\"]\n#>>> True\n\n\n", "type": "Nugget", "id": 113001}, {"nuggetType": "lecture", "name": "More Fsm Encoding", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "media": {"dotsub_id": "None", "name": "26_p_more-fsm-encoding.mp4", "parent": "agpzfnVkYWNpdHl1chELEgZDb3Vyc2UiBWNzMjYyDA", "type": "Media", "youtube_failure_reason": null, "key": "agpzfnVkYWNpdHl1ch4LEgZDb3Vyc2UiBWNzMjYyDAsSBU1lZGlhGIP3Agw", "youtube_id": "RFFZ4dS6jUQ", "youtube_state": "processing", "path": "Course/cs262/Media/48003", "transcript": null, "id": 48003}, "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBjR-gYM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/114001", "type": "Nugget", "id": 114001}, {"nuggetType": "program", "name": "More Fsm Encoding", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBi5ggcM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/115001", "suppliedCode": "# FSM Interpretation\n\n# Define edges and accepting to encode r\"[a-b][c-d]?\". Name your start state 1.\n\nedges = {}\n\naccepting = []\n\n\ndef fsmsim(string, current, edges, accepting):\n    if string == \"\":\n        return current in accepting\n    else:\n        letter = string[0]\n        if (current, letter) in edges:\n            destination = edges[(current, letter)]\n            remaining_string = string[1:]\n            return fsmsim(remaining_string, destination, edges, accepting)\n        else:\n            return False\n\n\n#print fsmsim(\"a\",1,edges,accepting)\n# >>> True\n\n#print fsmsim(\"b\",1,edges,accepting)\n# >>> True\n\n#print fsmsim(\"ad\",1,edges,accepting)\n# >>> True\n\n#print fsmsim(\"e\",1,edges,accepting)\n# >>> False\n", "type": "Nugget", "id": 115001}, {"nuggetType": "program", "name": "More FSM Encoding", "parent": "agpzfnVkYWNpdHl1cjILEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDA", "key": "agpzfnVkYWNpdHl1ckALEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GLkXDAsSBk51Z2dldBiRuQcM", "path": "Course/cs262/CourseRev/apr2012/Unit/3001/Nugget/122001", "suppliedCode": "# FSM Interpretation\n\n# Define edges and accepting to encode r\"[a-b][c-d]?\". Name your start state 1.\n\nedges = {}\n\naccepting = []\n\n\ndef fsmsim(string, current, edges, accepting):\n    if string == \"\":\n        return current in accepting\n    else:\n        letter = string[0]\n        if (current, letter) in edges:\n            destination = edges[(current, letter)]\n            remaining_string = string[1:]\n            return fsmsim(remaining_string, destination, edges, accepting)\n        else:\n            return False\n\n\n#print fsmsim(\"a\",1,edges,accepting)\n# >>> True\n\n#print fsmsim(\"b\",1,edges,accepting)\n# >>> True\n\n#print fsmsim(\"ad\",1,edges,accepting)\n# >>> True\n\n#print fsmsim(\"e\",1,edges,accepting)\n# >>> False\n", "type": "Nugget", "id": 122001}]}, {"name": "Homework 1", "parent": "agpzfnVkYWNpdHl1cicLEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgw", "type": "Unit", "evaluated": true, "closedAt": "04/24/2012 00:00", "nuggetLayout": [[null, {"nugget_key": "agpzfnVkYWNpdHl1ckELEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAwwLEgZOdWdnZXQY6fsDDA"}], [null, {"nugget_key": "agpzfnVkYWNpdHl1ckELEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAwwLEgZOdWdnZXQYgvQDDA"}], [null, {"nugget_key": "agpzfnVkYWNpdHl1ckELEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAwwLEgZOdWdnZXQY0oMEDA"}], [null, {"nugget_key": "agpzfnVkYWNpdHl1ckELEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAwwLEgZOdWdnZXQYlsUDDA"}], [null, {"nugget_key": "agpzfnVkYWNpdHl1ckELEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAwwLEgZOdWdnZXQYi5sEDA"}], [null, {"nugget_key": "agpzfnVkYWNpdHl1ckELEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAwwLEgZOdWdnZXQYopMEDA"}]], "availableAt": "", "key": "agpzfnVkYWNpdHl1cjMLEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAww", "path": "Course/cs262/CourseRev/apr2012/Unit/63001", "open": true, "id": 63001, "nuggets": [{"nuggetType": "quiz", "name": "General Concepts", "parent": "agpzfnVkYWNpdHl1cjMLEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAww", "key": "agpzfnVkYWNpdHl1ckELEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAwwLEgZOdWdnZXQY6fsDDA", "path": "Course/cs262/CourseRev/apr2012/Unit/63001/Nugget/65001", "type": "Nugget", "id": 65001}, {"nuggetType": "program", "name": "Summing Numbers", "parent": "agpzfnVkYWNpdHl1cjMLEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAww", "key": "agpzfnVkYWNpdHl1ckELEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAwwLEgZOdWdnZXQYgvQDDA", "path": "Course/cs262/CourseRev/apr2012/Unit/63001/Nugget/64002", "suppliedCode": "# Title: Summing Numbers\n\n# Write a procedure called sumnums(). Your procedure must accept as input a\n# single string. Your procedure must output an integer equal to the sum of\n# all integer numbers (one or more digits in sequence) within that string.\n# If there are no decimal numbers in the input string, your procedure must\n# return the integer 0. The input string will not contain any negative integers.\n#\n# Example Input: \"hello 2 all of you 44\"\n# Example Output: 46\n#\n# Hint: int(\"44\") == 44\n\nimport re\n\ndef sumnums(sentence): \n# write your code here\n\n         \n\n# This problem includes an example test case to help you tell if you are on\n# the right track. You may want to make your own additional tests as well.\n\ntest_case_input = \"\"\"The Act of Independence of Lithuania was signed \non February 16, 1918, by 20 council members.\"\"\"\n\ntest_case_output = 1954\n\nif sumnums(test_case_input) == test_case_output:\n  print \"Test case passed.\"\nelse:\n  print \"Test case failed:\" \n  print sumnums(test_case_input) \n", "type": "Nugget", "id": 64002}, {"nuggetType": "program", "name": "Single Hyphenated Words", "parent": "agpzfnVkYWNpdHl1cjMLEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAww", "key": "agpzfnVkYWNpdHl1ckELEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAwwLEgZOdWdnZXQY0oMEDA", "path": "Course/cs262/CourseRev/apr2012/Unit/63001/Nugget/66002", "suppliedCode": "# Title: Singly-Hyphenated Words\n\n# We examined hyphenated words in a quiz in class. In this problem you\n# will get a chance to handle them correctly. \n# \n# Assign to the variable regexp a Python regular expression that matches \n# both words (with letters a-z) and also singly-hyphenated words. If you \n# use grouping, you must use (?: and ) as your regular expression\n# parentheses. \n#\n# Examples: \n#\n# regexp exactly matches \"astronomy\"  \n# regexp exactly matches \"near-infrared\"  \n# regexp exactly matches \"x-ray\"  \n# regexp does not exactly match \"-tricky\" \n# regexp does not exactly match \"tricky-\" \n# regexp does not exactly match \"large - scale\" \n# regexp does not exactly match \"gamma-ray-burst\" \n# regexp does not exactly match \"\" \n\n# Your regular expression only needs to handle lowercase strings.\n\nimport re\n\nregexp = r\"\" # you should replace this with your regular expression\n\n# This problem includes an example test case to help you tell if you are on\n# the right track. You may want to make your own additional tests as well.\n\ntest_case_input = \"\"\"the wide-field infrared survey explorer is a nasa\ninfrared-wavelength space telescope in an earth-orbiting satellite which\nperformed an all-sky astronomical survey. be careful of -tricky tricky-\nhyphens --- be precise.\"\"\"\n\ntest_case_output = ['the', 'wide-field', 'infrared', 'survey', 'explorer',\n'is', 'a', 'nasa', 'infrared-wavelength', 'space', 'telescope', 'in', 'an',\n'earth-orbiting', 'satellite', 'which', 'performed', 'an', 'all-sky',\n'astronomical', 'survey', 'be', 'careful', 'of', 'tricky', 'tricky',\n'hyphens', 'be', 'precise']\n\nif re.findall(regexp, test_case_input) == test_case_output:\n  print \"Test case passed.\"\nelse:\n  print \"Test case failed:\" \n  print re.findall(regexp, test_case_input) \n", "type": "Nugget", "id": 66002}, {"nuggetType": "quiz", "name": "Fsm Completion", "parent": "agpzfnVkYWNpdHl1cjMLEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAww", "key": "agpzfnVkYWNpdHl1ckELEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAwwLEgZOdWdnZXQYlsUDDA", "path": "Course/cs262/CourseRev/apr2012/Unit/63001/Nugget/58006", "type": "Nugget", "id": 58006}, {"nuggetType": "program", "name": "Simulating Nondeterminism", "parent": "agpzfnVkYWNpdHl1cjMLEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAww", "key": "agpzfnVkYWNpdHl1ckELEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAwwLEgZOdWdnZXQYi5sEDA", "path": "Course/cs262/CourseRev/apr2012/Unit/63001/Nugget/69003", "suppliedCode": "# Title: Simulating Non-Determinism\n\n# Each regular expression can be converted to an equivalent finite state\n# machine. This is how regular expressions are implemented in practice. \n# We saw how non-deterministic finite state machines can be converted to\n# deterministic ones (often of a different size). It is also possible to\n# simulate non-deterministic machines directly -- and we'll do that now!\n#\n# In a given state, a non-deterministic machine may have *multiple*\n# outgoing edges labeled with the *same* character. \n#\n# To handle this ambiguity, we say that a non-deterministic finite state\n# machine accepts a string if there exists *any* path through the finite\n# state machine that consumes exactly that string as input and ends in an\n# accepting state. \n#\n# Write a procedure nfsmsim that works just like the fsmsim we covered\n# together, but handles also multiple outgoing edges and ambiguity. Do not\n# consider epsilon transitions. \n# \n# Formally, your procedure takes four arguments: a string, a starting\n# state, the edges (encoded as a dictionary mapping), and a list of\n# accepting states. \n#\n# To encode this ambiguity, we will change \"edges\" so that each state-input\n# pair maps to a *list* of destination states. \n#\n# For example, the regular expression r\"a+|(?:ab+c)\" might be encoded like\n# this:\nedges = { (1, 'a') : [2, 3],\n          (2, 'a') : [2],\n          (3, 'b') : [4, 3],\n          (4, 'c') : [5] }\naccepting = [2, 5] \n# It accepts both \"aaa\" (visiting states 1 2 2 and finally 2) and \"abbc\"\n# (visting states 1 3 3 4 and finally 5). \n\ndef nfsmsim(string, current, edges, accepting): \n# fill in your code here \n\n        \n\n# This problem includes some test cases to help you tell if you are on\n# the right track. You may want to make your own additional tests as well.\n\nprint \"Test case 1 passed: \" + str(nfsmsim(\"abc\", 1, edges, accepting) == True) \nprint \"Test case 2 passed: \" + str(nfsmsim(\"aaa\", 1, edges, accepting) == True) \nprint \"Test case 3 passed: \" + str(nfsmsim(\"abbbc\", 1, edges, accepting) == True) \nprint \"Test case 4 passed: \" + str(nfsmsim(\"aabc\", 1, edges, accepting) == False) \nprint \"Test case 5 passed: \" + str(nfsmsim(\"\", 1, edges, accepting) == False) \n", "type": "Nugget", "id": 69003}, {"nuggetType": "program", "name": "Reading Machine Minds", "parent": "agpzfnVkYWNpdHl1cjMLEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAww", "key": "agpzfnVkYWNpdHl1ckELEgZDb3Vyc2UiBWNzMjYyDAsSCUNvdXJzZVJldiIHYXByMjAxMgwLEgRVbml0GJnsAwwLEgZOdWdnZXQYopMEDA", "path": "Course/cs262/CourseRev/apr2012/Unit/63001/Nugget/68002", "suppliedCode": "# Title: Reading Machine Minds\n\n# It can be difficult to predict what strings a finite state machine will\n# accept. A tricky finite state machine may not accept any! A finite state\n# machine that accepts no strings is said to be *empty*. \n# \n# In this homework problem you will determine if a finite state machine is\n# empty or not. If it is not empty, you will prove that by returning a\n# string that it accepts. \n#\n# Formally, you will write a procedure nfsmaccepts() that takes four\n# arguments corresponding to a non-derministic finite state machine:\n#   the start (or current) state\n#   the edges (encoded as a mapping)\n#   the list of accepting states\n#   a list of states already visited (starts empty) \n#\n# If the finite state machine accepts any string, your procedure must\n# return one such string (your choice!). Otherwise, if the finite state\n# machine is empty, your procedure must return None (the value None, not\n# the string \"None\"). \n#\n# For example, this non-deterministic machine ...\nedges = { (1, 'a') : [2, 3],\n          (2, 'a') : [2],\n          (3, 'b') : [4, 2],\n          (4, 'c') : [5] }\naccepting = [5] \n# ... accepts exactly one string: \"abc\". By contrast, this\n# non-deterministic machine: \nedges2 = { (1, 'a') : [1],\n           (2, 'a') : [2] }\naccepting2 = [2] \n# ... accepts no strings (if you look closely, you'll see that you cannot\n# actually reach state 2 when starting in state 1). \n\n# Hint #1: This problem is trickier than it looks. If you do not keep track\n# of where you have been, your procedure may loop forever on the second\n# example. Before you make a recursive call, add the current state to the\n# list of visited states (and be sure to check the list of visited states\n# elsewhere). \n#\n# Hint #2: (Base Case) If the current state is accepting, you can return\n# \"\" as an accepting string.  \n# \n# Hint #3: (Recursion) If you have an outgoing edge labeled \"a\" that\n# goes to a state that accepts on the string \"bc\" (i.e., the recursive call\n# returns \"bc\"), then you can return \"abc\". \n#\n# Hint #4: You may want to iterate over all of the edges and only consider\n# those relevant to your current state. \"for edge in edges\" will iterate\n# over all of the keys in the mapping (i.e., over all of the (state,letter)\n# pairs) -- you'll have to write \"edges[edge]\" to get the destination list. \n\ndef nfsmaccepts(current, edges, accepting, visited): \n        # write your code here \n\n        \n\n# This problem includes some test cases to help you tell if you are on\n# the right track. You may want to make your own additional tests as well.\nprint \"Test 1: \" + str(nfsmaccepts(1, edges, accepting, []) == \"abc\") \nprint \"Test 2: \" + str(nfsmaccepts(1, edges, [4], []) == \"ab\") \nprint \"Test 3: \" + str(nfsmaccepts(1, edges2, accepting2, []) == None) \nprint \"Test 4: \" + str(nfsmaccepts(1, edges2, [1], []) == \"\")\n\n\n", "type": "Nugget", "id": 68002}]}], "path": "Course/cs262/CourseRev/apr2012", "type": "CourseRev", "id": "apr2012"}, "course_title": "Programming Languages", "progress": {}, "rev_name": "April 2012", "magik": false, "course_edit_url": "/edit_course?id=cs262"}}